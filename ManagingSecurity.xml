<?xml version='1.0' encoding='UTF-8'?>
<chapter xmlns="http://docbook.org/ns/docbook"
 xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en-US"
 xml:id="managingsecurity">
  <title xml:id="managingsecurity.title">Managing Security in a Lustre File System</title>
  <para>This chapter describes security features of the Lustre file system and
    includes the following sections:</para>
  <itemizedlist>
    <listitem>
      <para><xref linkend="managingSecurity.acl"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="managingSecurity.root_squash"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="managingSecurity.isolation"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="managingSecurity.sepol"/></para>
    </listitem>
  </itemizedlist>
  <section xml:id="managingSecurity.acl">
    <title><indexterm><primary>Access Control List (ACL)</primary></indexterm>
    Using ACLs</title>
    <para>An access control list (ACL), is a set of data that informs an
      operating system about permissions or access rights that each user or
      group has to specific system objects, such as directories or files. Each
      object has a unique security attribute that identifies users who have
      access to it. The ACL lists each object and user access privileges such as
      read, write or execute.</para>
    <section xml:id="managingSecurity.acl.howItWorks" remap="h3">
      <title><indexterm><primary>Access Control List (ACL)</primary><secondary>
        how they work</secondary></indexterm>How ACLs Work</title>
      <para>Implementing ACLs varies between operating systems. Systems that
        support the Portable Operating System Interface (POSIX) family of
        standards share a simple yet powerful file system permission model,
        which should be well-known to the Linux/UNIX administrator. ACLs add
        finer-grained permissions to this model, allowing for more complicated
        permission schemes. For a detailed explanation of ACLs on a Linux
        operating system, refer to the SUSE Labs article
        <link xl:href="http://wiki.lustre.org/images/5/57/PosixAccessControlInLinux.pdf">
          Posix Access Control Lists on Linux</link>.</para>
      <para>We have implemented ACLs according to this model. The Lustre
        software works with the standard Linux ACL tools, setfacl, getfacl, and
        the historical chacl, normally installed with the ACL package.</para>
      <note>
        <para>ACL support is a system-range feature, meaning that all clients
          have ACL enabled or not. You cannot specify which clients should
          enable ACL.</para>
      </note>
    </section>
    <section xml:id="managingSecurity.acl.using" remap="h3">
      <title><indexterm>
        <primary>Access Control List (ACL)</primary>
        <secondary>using</secondary>
      </indexterm>Using ACLs with the Lustre Software</title>
      <para>POSIX Access Control Lists (ACLs) can be used with the Lustre
        software. An ACL consists of file entries representing permissions based
        on standard POSIX file system object permissions that define three
        classes of user (owner, group and other). Each class is associated with
        a set of permissions [read (r), write (w) and execute (x)].</para>
      <itemizedlist>
        <listitem>
          <para>Owner class permissions define access privileges of the file
            owner.</para>
        </listitem>
        <listitem>
          <para>Group class permissions define access privileges of the owning
            group.</para>
        </listitem>
        <listitem>
          <para>Other class permissions define access privileges of all users
            not in the owner or group class.</para>
        </listitem>
      </itemizedlist>
      <para>The <literal>ls -l</literal> command displays the owner, group, and
        other class permissions in the first column of its output (for example,
        <literal>-rw-r- --</literal> for a regular file with read and write
        access for the owner class, read access for the group class, and no
        access for others).</para>
      <para>Minimal ACLs have three entries. Extended ACLs have more than the
        three entries. Extended ACLs also contain a mask entry and may contain
        any number of named user and named group entries.</para>
      <para>The MDS needs to be configured to enable ACLs. Use
        <literal>--mountfsoptions</literal> to enable ACLs when creating your
        configuration:</para>
      <screen>$ mkfs.lustre --fsname spfs --mountfsoptions=acl --mdt -mgs /dev/sda</screen>
      <para>Alternately, you can enable ACLs at run time by using the
        <literal>--acl</literal> option with <literal>mkfs.lustre</literal>:
      </para>
      <screen>$ mount -t lustre -o acl /dev/sda /mnt/mdt</screen>
      <para>To check ACLs on the MDS:</para>
      <screen>$ lctl get_param -n mdc.home-MDT0000-mdc-*.connect_flags | grep acl acl</screen>
      <para>To mount the client with no ACLs:</para>
      <screen>$ mount -t lustre -o noacl ibmds2@o2ib:/home /home</screen>
      <para>ACLs are enabled in a Lustre file system on a system-wide basis;
        either all clients enable ACLs or none do. Activating ACLs is controlled
        by MDS mount options <literal>acl</literal> / <literal>noacl</literal>
        (enable/disable ACLs). Client-side mount options acl/noacl are ignored.
        You do not need to change the client configuration, and the
        &apos;acl&apos; string will not appear in the client /etc/mtab. The
        client acl mount option is no longer needed. If a client is mounted with
        that option, then this message appears in the MDS syslog:</para>
      <screen>...MDS requires ACL support but client does not</screen>
      <para>The message is harmless but indicates a configuration issue, which
        should be corrected.</para>
      <para>If ACLs are not enabled on the MDS, then any attempts to reference
        an ACL on a client return an Operation not supported error.</para>
    </section>
    <section xml:id="managingSecurity.acl.examples" remap="h3">
        <title><indexterm>
          <primary>Access Control List (ACL)</primary>
          <secondary>examples</secondary>
        </indexterm>Examples</title>
      <para>These examples are taken directly from the POSIX paper referenced
        above. ACLs on a Lustre file system work exactly like ACLs on any Linux
        file system. They are manipulated with the standard tools in the
        standard manner. Below, we create a directory and allow a specific user
        access.</para>
      <screen>[root@client lustre]# umask 027
[root@client lustre]# mkdir rain
[root@client lustre]# ls -ld rain
drwxr-x---  2 root root 4096 Feb 20 06:50 rain
[root@client lustre]# getfacl rain
# file: rain
# owner: root
# group: root
user::rwx
group::r-x
other::---
 
[root@client lustre]# setfacl -m user:chirag:rwx rain
[root@client lustre]# ls -ld rain
drwxrwx---+ 2 root root 4096 Feb 20 06:50 rain
[root@client lustre]# getfacl --omit-header rain
user::rwx
user:chirag:rwx
group::r-x
mask::rwx
other::---</screen>
    </section>
  </section>
  <section xml:id="managingSecurity.root_squash">
    <title><indexterm>
      <primary>root squash</primary>
    </indexterm>Using Root Squash</title>
    <para>Root squash is a security feature which restricts super-user access
      rights to a Lustre file system. Without the root squash feature enabled,
      Lustre file system users on untrusted clients could access or modify files
      owned by root on the file system, including deleting them. Using the root
      squash feature restricts file access/modifications as the root user to
      only the specified clients. Note, however, that this does
      <emphasis>not</emphasis> prevent users on insecure clients from accessing
      files owned by <emphasis>other</emphasis> users.</para>
    <para>The root squash feature works by re-mapping the user ID (UID) and
      group ID (GID) of the root user to a UID and GID specified by the system
      administrator, via the Lustre configuration management server (MGS). The
      root squash feature also enables the Lustre file system administrator to
      specify a set of client for which UID/GID re-mapping does not apply.
    </para>
		<note><para>Nodemaps (<xref linkend="lustrenodemap.title" />) are an
		alternative to root squash, since it also allows root squash on a per-client
		basis.  With UID maps, the clients can even have a local root UID without
		actually having root access to the filesystem itself.</para></note>
    <section xml:id="managingSecurity.root_squash.config" remap="h3">
      <title><indexterm>
        <primary>root squash</primary>
        <secondary>configuring</secondary>
      </indexterm>Configuring Root Squash</title>
      <para>Root squash functionality is managed by two configuration
        parameters, <literal>root_squash</literal> and
        <literal>nosquash_nids</literal>.</para>
      <itemizedlist>
        <listitem>
          <para>The <literal>root_squash</literal> parameter specifies the UID
            and GID with which the root user accesses the Lustre file system.
          </para>
        </listitem>
        <listitem>
          <para>The <literal>nosquash_nids</literal> parameter specifies the set
            of clients to which root squash does not apply. LNet NID range
            syntax is used for this parameter (see the NID range syntax rules
            described in <xref linkend="managingSecurity.root_squash"/>). For
            example:</para>
        </listitem>
      </itemizedlist>
      <screen>nosquash_nids=172.16.245.[0-255/2]@tcp</screen>
      <para>In this example, root squash does not apply to TCP clients on subnet
        172.16.245.0 that have an even number as the last component of their IP
        address.</para>
    </section>
    <section xml:id="managingSecurity.root_squash.tuning">
      <title><indexterm>
        <primary>root squash</primary><secondary>enabling</secondary>
      </indexterm>Enabling and Tuning Root Squash</title>
      <para>The default value for <literal>nosquash_nids</literal> is NULL,
        which means that root squashing applies to all clients. Setting the root
        squash UID and GID to 0 turns root squash off.</para>
      <para>Root squash parameters can be set when the MDT is created
        (<literal>mkfs.lustre --mdt</literal>). For example:</para>
      <screen>mds# mkfs.lustre --reformat --fsname=testfs --mdt --mgs \
       --param &quot;mdt.root_squash=500:501&quot; \
       --param &quot;mdt.nosquash_nids=&apos;0@elan1 192.168.1.[10,11]&apos;&quot; /dev/sda1</screen>
      <para>Root squash parameters can also be changed on an unmounted device
        with <literal>tunefs.lustre</literal>. For example:</para>
      <screen>tunefs.lustre --param &quot;mdt.root_squash=65534:65534&quot;  \
--param &quot;mdt.nosquash_nids=192.168.0.13@tcp0&quot; /dev/sda1
</screen>
      <para>Root squash parameters can also be changed with the
      <literal>lctl conf_param</literal> command. For example:</para>
      <screen>mgs# lctl conf_param testfs.mdt.root_squash=&quot;1000:101&quot;
mgs# lctl conf_param testfs.mdt.nosquash_nids=&quot;*@tcp&quot;</screen>
      <para>To retrieve the current root squash parameter settings, the
      following <literal>lctl get_param</literal> commands can be used:</para>
      <screen>mgs# lctl get_param mdt.*.root_squash
mgs# lctl get_param mdt.*.nosquash_nids</screen>
      <note>
        <para>When using the lctl conf_param command, keep in mind:</para>
        <itemizedlist>
          <listitem>
            <para><literal>lctl conf_param</literal> must be run on a live MGS
            </para>
          </listitem>
          <listitem>
            <para><literal>lctl conf_param</literal> causes the parameter to
              change on all MDSs</para>
          </listitem>
          <listitem>
            <para><literal>lctl conf_param</literal> is to be used once per a
              parameter</para>
          </listitem>
        </itemizedlist>
      </note>
      <para>The root squash settings can also be changed temporarily with
      <literal>lctl set_param</literal> or persistently with
      <literal>lctl set_param -P</literal>.  For example:</para>
      <screen>mgs# lctl set_param mdt.testfs-MDT0000.root_squash="1:0"
mgs# lctl set_param -P mdt.testfs-MDT0000.root_squash="1:0"</screen>
      <para>The <literal>nosquash_nids</literal> list can be cleared with:</para>
      <screen>mgs# lctl conf_param testfs.mdt.nosquash_nids=&quot;NONE&quot;</screen>
      <para>- OR -</para>
      <screen>mgs# lctl conf_param testfs.mdt.nosquash_nids=&quot;clear&quot;</screen>
      <para>If the <literal>nosquash_nids</literal> value consists of several
        NID ranges (e.g. <literal>0@elan</literal>, <literal>1@elan1</literal>),
        the list of NID ranges must be quoted with single (&apos;) or double
        (&apos;&apos;) quotation marks. List elements must be separated with a
        space. For example:</para>
      <screen>mds# mkfs.lustre ... --param &quot;mdt.nosquash_nids=&apos;0@elan1 1@elan2&apos;&quot; /dev/sda1
lctl conf_param testfs.mdt.nosquash_nids=&quot;24@elan 15@elan1&quot;</screen>
      <para>These are examples of incorrect syntax:</para>
      <screen>mds# mkfs.lustre ... --param &quot;mdt.nosquash_nids=0@elan1 1@elan2&quot; /dev/sda1
lctl conf_param testfs.mdt.nosquash_nids=24@elan 15@elan1</screen>
      <para>To check root squash parameters, use the lctl get_param command:
      </para>
      <screen>mds# lctl get_param mdt.testfs-MDT0000.root_squash
lctl get_param mdt.*.nosquash_nids</screen>
      <note>
        <para>An empty nosquash_nids list is reported as NONE.</para>
      </note>
    </section>
    <section xml:id="managingSecurity.root_squash.tips" remap="h3">
        <title><indexterm>
          <primary>root squash</primary>
          <secondary>tips</secondary>
        </indexterm>Tips on Using Root Squash</title>
      <para>Lustre configuration management limits root squash in several ways.
      </para>
      <itemizedlist>
        <listitem>
          <para>The <literal>lctl conf_param</literal> value overwrites the
            parameter&apos;s previous value. If the new value uses an incorrect
            syntax, then the system continues with the old parameters and the
            previously-correct value is lost on remount. That is, be careful
            doing root squash tuning.</para>
        </listitem>
        <listitem>
          <para><literal>mkfs.lustre</literal> and
            <literal>tunefs.lustre</literal> do not perform parameter syntax
            checking. If the root squash parameters are incorrect, they are
            ignored on mount and the default values are used instead.</para>
        </listitem>
        <listitem>
          <para>Root squash parameters are parsed with rigorous syntax checking.
            The root_squash parameter should be specified as
            <literal>&lt;decnum&gt;:&lt;decnum&gt;</literal>. The
            <literal>nosquash_nids</literal> parameter should follow LNet NID
            range list syntax.</para>
        </listitem>
      </itemizedlist>
      <para>LNet NID range syntax:</para>
      <screen>&lt;nidlist&gt;     :== &lt;nidrange&gt; [ &apos; &apos; &lt;nidrange&gt; ]
&lt;nidrange&gt;   :== &lt;addrrange&gt; &apos;@&apos; &lt;net&gt;
&lt;addrrange&gt;  :== &apos;*&apos; |
           &lt;ipaddr_range&gt; |
           &lt;numaddr_range&gt;
&lt;ipaddr_range&gt;       :==
&lt;numaddr_range&gt;.&lt;numaddr_range&gt;.&lt;numaddr_range&gt;.&lt;numaddr_range&gt;
&lt;numaddr_range&gt;      :== &lt;number&gt; |
                   &lt;expr_list&gt;
&lt;expr_list&gt;  :== &apos;[&apos; &lt;range_expr&gt; [ &apos;,&apos; &lt;range_expr&gt;] &apos;]&apos;
&lt;range_expr&gt; :== &lt;number&gt; |
           &lt;number&gt; &apos;-&apos; &lt;number&gt; |
           &lt;number&gt; &apos;-&apos; &lt;number&gt; &apos;/&apos; &lt;number&gt;
&lt;net&gt;        :== &lt;netname&gt; | &lt;netname&gt;&lt;number&gt;
&lt;netname&gt;    :== &quot;lo&quot; | &quot;tcp&quot; | &quot;o2ib&quot;
           | &quot;ra&quot; | &quot;elan&quot;
&lt;number&gt;     :== &lt;nonnegative decimal&gt; | &lt;hexadecimal&gt;</screen>
      <note>
        <para>For networks using numeric addresses (e.g. elan), the address
          range must be specified in the
          <literal>&lt;numaddr_range&gt;</literal> syntax. For networks using
          IP addresses, the address range must be in the
          <literal>&lt;ipaddr_range&gt;</literal>. For example, if elan is using
          numeric addresses, <literal>1.2.3.4@elan</literal> is incorrect.
        </para>
      </note>
    </section>
  </section>
  <section xml:id="managingSecurity.isolation">
    <title><indexterm><primary>Isolation</primary></indexterm>
    Isolating Clients to a Sub-directory Tree</title>
    <para>Isolation is the Lustre implementation of the generic concept of
      multi-tenancy, which aims at providing separated namespaces from a single
      filesystem. Lustre Isolation enables different populations of users on
      the same file system beyond normal Unix permissions/ACLs, even when users
      on the clients may have root access. Those tenants share the same file
      system, but they are isolated from each other: they cannot access or even
      see each other’s files, and are not aware that they are sharing common
      file system resources.</para>
    <para>Lustre Isolation leverages the Fileset feature
      (<xref linkend="SystemConfigurationUtilities.fileset" />)
      to mount only a subdirectory of the filesystem rather than the root
      directory.
      In order to achieve isolation, the subdirectory mount, which presents to
      tenants only their own fileset, has to be imposed to the clients. To that
      extent, we make use of the nodemap feature
      (<xref linkend="lustrenodemap.title" />). We group all clients used by a
      tenant under a common nodemap entry, and we assign to this nodemap entry
      the fileset to which the tenant is restricted.</para>
    <section xml:id="managingSecurity.isolation.clientid" remap="h3">
      <title><indexterm><primary>Isolation</primary><secondary>
        client identification</secondary></indexterm>Identifying Clients</title>
      <para>Enforcing multi-tenancy on Lustre relies on the ability to properly
        identify the client nodes used by a tenant, and trust those identities.
        This can be achieved by having physical hardware and/or network
        security, so that client nodes have well-known NIDs. It is also possible
        to make use of strong authentication with Kerberos or Shared-Secret Key
	(see <xref linkend="lustressk" />).
	Kerberos prevents NID spoofing, as every client needs its own
	credentials, based on its NID, in order to connect to the servers.
	Shared-Secret Key also prevents tenant impersonation, because keys
	can be linked to a specific nodemap. See
	<xref linkend="ssknodemaprole" /> for detailed explanations.
</para>
    </section>
    <section xml:id="managingSecurity.isolation.configuring" remap="h3">
      <title><indexterm><primary>Isolation</primary><secondary>
        configuring</secondary></indexterm>Configuring Isolation</title>
      <para>Isolation on Lustre can be achieved by setting the
        <literal>fileset</literal> parameter on a nodemap entry. All clients
	belonging to this nodemap entry will automatically mount this fileset
	instead of the root directory. For example:</para>
      <screen>mgs# lctl nodemap_set_fileset --name tenant1 --fileset '/dir1'</screen>
      <para>So all clients matching the <literal>tenant1</literal> nodemap will
        be automatically presented the fileset <literal>/dir1</literal> when
	mounting. This means these clients are doing an implicit subdirectory
	mount on the subdirectory <literal>/dir1</literal>.
      </para>
      <note>
        <para>
	  If subdirectory defined as fileset does not exist on the file system,
	  it will prevent any client belonging to the nodemap from mounting
	  Lustre.
	</para>
      </note>
      <para>To delete the fileset parameter, just set it to an empty string:
      </para>
      <screen>mgs# lctl nodemap_set_fileset --name tenant1 --fileset ''</screen>
    </section>
    <section xml:id="managingSecurity.isolation.permanent" remap="h3">
      <title><indexterm><primary>Isolation</primary><secondary>
        making permanent</secondary></indexterm>Making Isolation Permanent
      </title>
      <para>In order to make isolation permanent, the fileset parameter on the
        nodemap has to be set with <literal>lctl set_param</literal> with the
      <literal>-P</literal> option.</para>
      <screen>mgs# lctl set_param nodemap.tenant1.fileset=/dir1
mgs# lctl set_param -P nodemap.tenant1.fileset=/dir1</screen>
      <para>This way the fileset parameter will be stored in the Lustre config
      logs, letting the servers retrieve the information after a restart.
      </para>
    </section>
  </section>
  <section xml:id="managingSecurity.sepol" condition='l2D'>
    <title><indexterm><primary>selinux policy check</primary></indexterm>
    Checking SELinux Policy Enforced by Lustre Clients</title>
    <para>SELinux provides a mechanism in Linux for supporting Mandatory Access
      Control (MAC) policies. When a MAC policy is enforced, the operating
      system’s (OS) kernel defines application rights, firewalling applications
      from compromising the entire system. Regular users do not have the ability to
      override the policy.</para>
    <para>One purpose of SELinux is to protect the
      <emphasis role="bold">OS</emphasis> from privilege escalation. To that
      extent, SELinux defines confined and unconfined domains for processes and
      users. Each process, user, file is assigned a security context, and
      rules define the allowed operations by processes and users on files.
    </para>
    <para>Another purpose of SELinux can be to protect
      <emphasis role="bold">data</emphasis> sensitivity, thanks to Multi-Level
      Security (MLS). MLS works on top of SELinux, by defining the concept of
      security levels in addition to domains. Each process, user and file is
      assigned a security level, and the model states that processes and users
      can read the same or lower security level, but can only write to their own
      or higher security level.
    </para>
    <para>From a file system perspective, the security context of files must be
      stored permanently. Lustre makes use of the
      <literal>security.selinux</literal> extended attributes on files to hold
      this information. Lustre supports SELinux on the client side. All you have
      to do to have MAC and MLS on Lustre is to enforce the appropriate SELinux
      policy (as provided by the Linux distribution) on all Lustre clients. No
      SELinux is required on Lustre servers.
    </para>
    <para>Because Lustre is a distributed file system, the specificity when
      using MLS is that Lustre really needs to make sure data is always accessed
      by nodes with the SELinux MLS policy properly enforced. Otherwise, data is
      not protected. This means Lustre has to check that SELinux is properly
      enforced on client side, with the right, unaltered policy. And if SELinux
      is not enforced as expected on a client, the server denies its access to
      Lustre.
    </para>
    <section xml:id="managingSecurity.sepol.determining" remap="h3">
      <title><indexterm><primary>selinux policy check</primary><secondary>
        determining</secondary></indexterm>Determining SELinux Policy Info
      </title>
      <para>A string that represents the SELinux Status info will be used by
        servers as a reference, to check if clients are enforcing SELinux
	properly. This reference string can be obtained on a client node known
	to enforce the right SELinux policy, by calling the
	<literal>l_getsepol</literal> command line utility:</para>
	<screen>client# l_getsepol
SELinux status info: 1:mls:31:40afb76d077c441b69af58cccaaa2ca63641ed6e21b0a887dc21a684f508b78f</screen>
	<para>The string describing the SELinux policy has the following
	  syntax:</para>
	<para><literal>mode:name:version:hash</literal></para>
	<para>where:</para>
	  <itemizedlist>
	    <listitem>
	      <para><literal>mode</literal> is a digit telling if SELinux is in
	        Permissive mode (0) or Enforcing mode (1)</para>
	    </listitem>
	    <listitem>
	      <para><literal>name</literal> is the name of the SELinux policy
	      </para>
	    </listitem>
	    <listitem>
	      <para><literal>version</literal> is the version of the SELinux
	      policy</para>
	    </listitem>
	    <listitem>
	      <para><literal>hash</literal> is the computed hash of the binary
	        representation of the policy, as exported in
	        /etc/selinux/<literal>name</literal>/policy/policy.
		<literal>version</literal></para>
	    </listitem>
	  </itemizedlist>
    </section>
    <section xml:id="managingSecurity.sepol.configuring" remap="h3">
      <title><indexterm><primary>selinux policy check</primary><secondary>
        enforcing</secondary></indexterm>Enforcing SELinux Policy Check</title>
      <para>SELinux policy check can be enforced by setting the
        <literal>sepol</literal> parameter on a nodemap entry. All clients
	belonging to this nodemap entry must enforce the SELinux policy
	described by this parameter, otherwise they are denied access to the
	Lustre file system. For example:</para>
      <screen>mgs# lctl nodemap_set_sepol --name restricted
     --sepol '1:mls:31:40afb76d077c441b69af58cccaaa2ca63641ed6e21b0a887dc21a684f508b78f'</screen>
      <para>So all clients matching the <literal>restricted</literal> nodemap
        must enforce the SELinux policy which description matches
	<literal>1:mls:31:40afb76d077c441b69af58cccaaa2ca63641ed6e21b0a887dc21a684f508b78f</literal>.
	If not, they will get Permission Denied when trying to mount or access
	files on the Lustre file system.</para>
      <para>To delete the <literal>sepol</literal> parameter, just set it to an
        empty string:</para>
      <screen>mgs# lctl nodemap_set_sepol --name restricted --sepol ''</screen>
      <para>See <xref linkend="lustrenodemap.title" /> for more details about
        the Nodemap feature.</para>
    </section>
    <section xml:id="managingSecurity.sepol.permanent" remap="h3">
      <title><indexterm><primary>selinux policy check</primary><secondary>
        making permanent</secondary></indexterm>Making SELinux Policy Check
	Permanent</title>
      <para>In order to make SELinux Policy check permanent, the sepol parameter
        on the nodemap has to be set with <literal>lctl set_param</literal> with
        the <literal>-P</literal> option.</para>
      <screen>mgs# lctl set_param nodemap.restricted.sepol=1:mls:31:40afb76d077c441b69af58cccaaa2ca63641ed6e21b0a887dc21a684f508b78f
mgs# lctl set_param -P nodemap.restricted.sepol=1:mls:31:40afb76d077c441b69af58cccaaa2ca63641ed6e21b0a887dc21a684f508b78f</screen>
      <para>This way the sepol parameter will be stored in the Lustre config
      logs, letting the servers retrieve the information after a restart.
      </para>
    </section>
    <section xml:id="managingSecurity.sepol.client" remap="h3">
      <title><indexterm><primary>selinux policy check</primary><secondary>
        sending client</secondary></indexterm>Sending SELinux Status Info from
	Clients</title>
      <para>In order for Lustre clients to send their SELinux status
	information, in	case SELinux is enabled locally, the
	<literal>send_sepol</literal> ptlrpc kernel module's parameter has to be
	set to a non-zero value. <literal>send_sepol</literal> accepts various
	values:</para>
	<itemizedlist>
	    <listitem>
	      <para>0: do not send SELinux policy info;</para>
	    </listitem>
	    <listitem>
	      <para>-1: fetch SELinux policy info for every request;</para>
	    </listitem>
	    <listitem>
	      <para>N > 0: only fetch SELinux policy info every N seconds. Use
	        <literal>N = 2^31-1</literal> to have SELinux policy info
		fetched only at mount time.</para>
	    </listitem>
	</itemizedlist>
	<para>Clients that are part of a nodemap on which
	  <literal>sepol</literal> is defined must send SELinux status info.
	  And the SELinux policy they enforce must match the representation
	  stored into the nodemap. Otherwise they will be denied access to the
	  Lustre file system.</para>
    </section>
  </section>
</chapter>
<!--
  vim:expandtab:shiftwidth=2:tabstop=8:
  -->
