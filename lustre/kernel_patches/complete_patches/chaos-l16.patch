


 0 files changed

--- linux-2.4.18-17.8.0/drivers/block/blkpg.c~dev_read_only	2002-12-06 14:52:29.000000000 -0800
+++ linux-2.4.18-17.8.0-zab/drivers/block/blkpg.c	2002-12-06 14:52:29.000000000 -0800
@@ -297,3 +297,38 @@ int blk_ioctl(kdev_t dev, unsigned int c
 }
 
 EXPORT_SYMBOL(blk_ioctl);
+
+#define NUM_DEV_NO_WRITE 16
+static int dev_no_write[NUM_DEV_NO_WRITE];
+
+/*
+ * Debug code for turning block devices "read-only" (will discard writes
+ * silently).  This is for filesystem crash/recovery testing.
+ */
+void dev_set_rdonly(kdev_t dev, int no_write)
+{
+	if (dev) {
+		printk(KERN_WARNING "Turning device %s read-only\n",
+		       bdevname(dev));
+		dev_no_write[no_write] = 0xdead0000 + dev;
+	}
+}
+
+int dev_check_rdonly(kdev_t dev) {
+	int i;
+
+	for (i = 0; i < NUM_DEV_NO_WRITE; i++) {
+		if ((dev_no_write[i] & 0xffff0000) == 0xdead0000 &&
+		    dev == (dev_no_write[i] & 0xffff))
+			return 1;
+	}
+	return 0;
+}
+
+void dev_clear_rdonly(int no_write) {
+	dev_no_write[no_write] = 0;
+}
+
+EXPORT_SYMBOL(dev_set_rdonly);
+EXPORT_SYMBOL(dev_check_rdonly);
+EXPORT_SYMBOL(dev_clear_rdonly);
--- linux-2.4.18-17.8.0/drivers/block/loop.c~dev_read_only	2002-12-06 14:52:29.000000000 -0800
+++ linux-2.4.18-17.8.0-zab/drivers/block/loop.c	2002-12-06 14:52:29.000000000 -0800
@@ -491,6 +491,9 @@ static int loop_make_request(request_que
 	spin_unlock_irq(&lo->lo_lock);
 
 	if (rw == WRITE) {
+		if (dev_check_rdonly(rbh->b_rdev))
+			goto err;
+
 		if (lo->lo_flags & LO_FLAGS_READ_ONLY)
 			goto err;
 	} else if (rw == READA) {
--- linux-2.4.18-17.8.0/drivers/ide/ide-disk.c~dev_read_only	2002-12-06 14:52:29.000000000 -0800
+++ linux-2.4.18-17.8.0-zab/drivers/ide/ide-disk.c	2002-12-06 14:52:29.000000000 -0800
@@ -557,6 +557,10 @@ static ide_startstop_t lba_48_rw_disk (i
  */
 static ide_startstop_t do_rw_disk (ide_drive_t *drive, struct request *rq, unsigned long block)
 {
+	if (rq->cmd == WRITE && dev_check_rdonly(rq->rq_dev)) {
+		ide_end_request(1, HWGROUP(drive));
+		return ide_stopped;
+	}
 	if (IDE_CONTROL_REG)
 		OUT_BYTE(drive->ctl,IDE_CONTROL_REG);
 

_



 fs/ext3/Makefile   |    2 ++
 fs/ext3/super.c    |    2 +-
 include/linux/fs.h |    1 +
 kernel/ksyms.c     |    5 +++++
 4 files changed, 9 insertions(+), 1 deletion(-)

--- linux-2.4.18-18/fs/ext3/Makefile~exports	Sat Apr  5 02:51:27 2003
+++ linux-2.4.18-18-braam/fs/ext3/Makefile	Sat Apr  5 02:54:45 2003
@@ -9,6 +9,8 @@
 
 O_TARGET := ext3.o
 
+export-objs :=	super.o inode.o
+
 obj-y    := balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o \
 		ioctl.o namei.o super.o symlink.o
 obj-m    := $(O_TARGET)
--- linux-2.4.18-18/fs/ext3/super.c~exports	Sat Apr  5 02:51:27 2003
+++ linux-2.4.18-18-braam/fs/ext3/super.c	Sat Apr  5 02:54:28 2003
@@ -1746,7 +1746,7 @@ static void __exit exit_ext3_fs(void)
 	unregister_filesystem(&ext3_fs_type);
 }
 
-EXPORT_NO_SYMBOLS;
+EXPORT_SYMBOL(ext3_bread);
 
 MODULE_AUTHOR("Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others");
 MODULE_DESCRIPTION("Second Extended Filesystem with journaling extensions");
--- linux-2.4.18-18/include/linux/fs.h~exports	Sat Apr  5 02:51:27 2003
+++ linux-2.4.18-18-braam/include/linux/fs.h	Sat Apr  5 02:54:29 2003
@@ -1046,6 +1046,7 @@ extern int unregister_filesystem(struct 
 extern struct vfsmount *kern_mount(struct file_system_type *);
 extern int may_umount(struct vfsmount *);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
+struct vfsmount *do_kern_mount(const char *type, int flags, char *name, void *data);
 extern void umount_tree(struct vfsmount *);
 
 #define kern_umount mntput
--- linux-2.4.18-18/kernel/ksyms.c~exports	Sat Apr  5 02:51:27 2003
+++ linux-2.4.18-18-braam/kernel/ksyms.c	Sat Apr  5 02:54:29 2003
@@ -306,6 +306,11 @@ EXPORT_SYMBOL_GPL(buffermem_pages);
 EXPORT_SYMBOL_GPL(nr_free_pages);
 EXPORT_SYMBOL_GPL(page_cache_size);
 
+/* lustre */
+EXPORT_SYMBOL(panic_notifier_list);
+EXPORT_SYMBOL(pagecache_lock_cacheline);
+EXPORT_SYMBOL(do_kern_mount);
+
 /* for stackable file systems (lofs, wrapfs, cryptfs, etc.) */
 EXPORT_SYMBOL(default_llseek);
 EXPORT_SYMBOL(dentry_open);

_



 0 files changed

--- linux-2.4.18-17.8.0/arch/i386/mm/init.c~kmem_cache_validate	2002-12-06 14:52:30.000000000 -0800
+++ linux-2.4.18-17.8.0-zab/arch/i386/mm/init.c	2002-12-06 14:52:30.000000000 -0800
@@ -43,6 +43,12 @@ unsigned long highstart_pfn, highend_pfn
 static unsigned long totalram_pages;
 static unsigned long totalhigh_pages;
 
+struct page *check_get_page(unsigned long kaddr)
+{
+#warning FIXME: Lustre team, is this solid?
+	return virt_to_page(kaddr);
+}
+
 int do_check_pgt_cache(int low, int high)
 {
 	int freed = 0;
--- linux-2.4.18-17.8.0/arch/ia64/mm/init.c~kmem_cache_validate	2002-12-06 14:52:30.000000000 -0800
+++ linux-2.4.18-17.8.0-zab/arch/ia64/mm/init.c	2002-12-06 14:52:30.000000000 -0800
@@ -37,6 +37,12 @@ unsigned long MAX_DMA_ADDRESS = PAGE_OFF
 
 static unsigned long totalram_pages;
 
+struct page *check_get_page(unsigned long kaddr)
+{
+#warning FIXME: Lustre team, is this solid?
+	return virt_to_page(kaddr);
+}
+
 int
 do_check_pgt_cache (int low, int high)
 {
--- linux-2.4.18-17.8.0/include/linux/slab.h~kmem_cache_validate	2002-12-06 14:52:30.000000000 -0800
+++ linux-2.4.18-17.8.0-zab/include/linux/slab.h	2002-12-06 14:52:30.000000000 -0800
@@ -57,6 +57,7 @@ extern int kmem_cache_destroy(kmem_cache
 extern int kmem_cache_shrink(kmem_cache_t *);
 extern void *kmem_cache_alloc(kmem_cache_t *, int);
 extern void kmem_cache_free(kmem_cache_t *, void *);
+extern int kmem_cache_validate(kmem_cache_t *cachep, void *objp);
 
 extern void *kmalloc(size_t, int);
 extern void kfree(const void *);
--- linux-2.4.18-17.8.0/kernel/ksyms.c~kmem_cache_validate	2002-12-06 14:52:30.000000000 -0800
+++ linux-2.4.18-17.8.0-zab/kernel/ksyms.c	2002-12-06 14:52:30.000000000 -0800
@@ -119,6 +119,7 @@ EXPORT_SYMBOL(kmem_cache_destroy);
 EXPORT_SYMBOL(kmem_cache_shrink);
 EXPORT_SYMBOL(kmem_cache_alloc);
 EXPORT_SYMBOL(kmem_cache_free);
+EXPORT_SYMBOL(kmem_cache_validate);
 EXPORT_SYMBOL(kmalloc);
 EXPORT_SYMBOL(kfree);
 EXPORT_SYMBOL(vfree);
--- linux-2.4.18-17.8.0/mm/slab.c~kmem_cache_validate	2002-12-06 14:52:30.000000000 -0800
+++ linux-2.4.18-17.8.0-zab/mm/slab.c	2002-12-06 14:52:30.000000000 -0800
@@ -1208,6 +1208,59 @@ failed:
  * Called with the cache-lock held.
  */
 
+extern struct page *check_get_page(unsigned long kaddr);
+struct page *page_mem_map(struct page *page);
+static int kmem_check_cache_obj (kmem_cache_t * cachep,
+				 slab_t *slabp, void * objp)
+{
+	int i;
+	unsigned int objnr;
+
+#if DEBUG
+	if (cachep->flags & SLAB_RED_ZONE) {
+		objp -= BYTES_PER_WORD;
+		if ( *(unsigned long *)objp != RED_MAGIC2)
+			/* Either write before start, or a double free. */
+			return 0;
+		if (*(unsigned long *)(objp+cachep->objsize -
+				BYTES_PER_WORD) != RED_MAGIC2)
+			/* Either write past end, or a double free. */
+			return 0;
+	}
+#endif
+
+	objnr = (objp-slabp->s_mem)/cachep->objsize;
+	if (objnr >= cachep->num)
+		return 0;
+	if (objp != slabp->s_mem + objnr*cachep->objsize)
+		return 0;
+
+	/* Check slab's freelist to see if this obj is there. */
+	for (i = slabp->free; i != BUFCTL_END; i = slab_bufctl(slabp)[i]) {
+		if (i == objnr)
+			return 0;
+	}
+	return 1;
+}
+
+
+int kmem_cache_validate(kmem_cache_t *cachep, void *objp)
+{
+	struct page *page = check_get_page((unsigned long)objp);
+
+	if (!VALID_PAGE(page))
+		return 0;
+
+	if (!PageSlab(page))
+		return 0;
+
+	/* XXX check for freed slab objects ? */
+	if (!kmem_check_cache_obj(cachep, GET_PAGE_SLAB(page), objp))
+		return 0;
+
+	return (cachep == GET_PAGE_CACHE(page));
+}
+
 #if DEBUG
 static int kmem_extra_free_checks (kmem_cache_t * cachep,
 			slab_t *slabp, void * objp)

_



 include/linux/lustre_version.h |    1 +
 1 files changed, 1 insertion(+)

--- /dev/null	Fri Aug 30 17:31:37 2002
+++ linux-2.4.18-18.8.0-l12-braam/include/linux/lustre_version.h	Thu Feb 13 07:58:33 2003
@@ -0,0 +1 @@
+#define LUSTRE_KERNEL_VERSION 15

_
 fs/dcache.c            |   20 ++
 fs/exec.c              |   18 +-
 fs/namei.c             |  347 ++++++++++++++++++++++++++++++++++++++++---------
 fs/nfsd/vfs.c          |    2 
 fs/open.c              |  120 ++++++++++++++--
 fs/stat.c              |    8 -
 include/linux/dcache.h |   28 +++
 include/linux/fs.h     |   27 +++
 kernel/ksyms.c         |    1 
 9 files changed, 486 insertions(+), 85 deletions(-)

--- lum/fs/dcache.c~vfs_intent-2.4.18-18	Fri Feb 28 11:50:28 2003
+++ lum-braam/fs/dcache.c	Fri Feb 28 11:50:28 2003
@@ -186,6 +186,13 @@ int d_invalidate(struct dentry * dentry)
 		spin_unlock(&dcache_lock);
 		return 0;
 	}
+
+	/* network invalidation by Lustre */
+	if (dentry->d_flags & DCACHE_LUSTRE_INVALID) {
+		spin_unlock(&dcache_lock);
+		return 0;
+	}
+
 	/*
 	 * Check whether to do a partial shrink_dcache
 	 * to get rid of unused child entries.
@@ -645,6 +652,7 @@ struct dentry * d_alloc(struct dentry * 
 	dentry->d_fsdata = NULL;
 	dentry->d_extra_attributes = NULL;
 	dentry->d_mounted = 0;
+	dentry->d_it = NULL;
 	INIT_LIST_HEAD(&dentry->d_hash);
 	INIT_LIST_HEAD(&dentry->d_lru);
 	INIT_LIST_HEAD(&dentry->d_subdirs);
@@ -859,13 +867,19 @@ void d_delete(struct dentry * dentry)
  * Adds a dentry to the hash according to its name.
  */
  
-void d_rehash(struct dentry * entry)
+void __d_rehash(struct dentry * entry, int lock)
 {
 	struct list_head *list = d_hash(entry->d_parent, entry->d_name.hash);
 	if (!list_empty(&entry->d_hash)) BUG();
-	spin_lock(&dcache_lock);
+	if (lock) spin_lock(&dcache_lock);
 	list_add(&entry->d_hash, list);
-	spin_unlock(&dcache_lock);
+	if (lock) spin_unlock(&dcache_lock);
+}
+EXPORT_SYMBOL(__d_rehash);
+
+void d_rehash(struct dentry * entry)
+{
+	__d_rehash(entry, 1);
 }
 
 #define do_switch(x,y) do { \
--- lum/fs/namei.c~vfs_intent-2.4.18-18	Fri Feb 28 11:50:28 2003
+++ lum-braam/fs/namei.c	Wed Mar 19 15:40:13 2003
@@ -94,6 +94,13 @@
  * XEmacs seems to be relying on it...
  */
 
+void intent_release(struct dentry *de, struct lookup_intent *it)
+{
+	if (it && de->d_op && de->d_op->d_intent_release)
+		de->d_op->d_intent_release(de, it);
+
+}
+
 /* In order to reduce some races, while at the same time doing additional
  * checking and hopefully speeding things up, we copy filenames to the
  * kernel data space before using them..
@@ -260,10 +267,19 @@ void path_release(struct nameidata *nd)
  * Internal lookup() using the new generic dcache.
  * SMP-safe
  */
-static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry *cached_lookup(struct dentry *parent, struct qstr *name,
+				    int flags, struct lookup_intent *it)
 {
 	struct dentry * dentry = d_lookup(parent, name);
 
+	if (dentry && dentry->d_op && dentry->d_op->d_revalidate2) {
+		if (!dentry->d_op->d_revalidate2(dentry, flags, it) &&
+		    !d_invalidate(dentry)) {
+			dput(dentry);
+			dentry = NULL;
+		}
+		return dentry;
+	} else
 	if (dentry && dentry->d_op && dentry->d_op->d_revalidate) {
 		if (!dentry->d_op->d_revalidate(dentry, flags) && !d_invalidate(dentry)) {
 			dput(dentry);
@@ -281,11 +297,14 @@ static struct dentry * cached_lookup(str
  * make sure that nobody added the entry to the dcache in the meantime..
  * SMP-safe
  */
-static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry *real_lookup(struct dentry *parent, struct qstr *name,
+				  int flags, struct lookup_intent *it)
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
 
+again:
+
 	down(&dir->i_sem);
 	/*
 	 * First re-do the cached lookup just in case it was created
@@ -300,6 +319,9 @@ static struct dentry * real_lookup(struc
 		result = ERR_PTR(-ENOMEM);
 		if (dentry) {
 			lock_kernel();
+			if (dir->i_op->lookup2)
+				result = dir->i_op->lookup2(dir, dentry, it);
+			else
 			result = dir->i_op->lookup(dir, dentry);
 			unlock_kernel();
 			if (result)
@@ -321,6 +343,12 @@ static struct dentry * real_lookup(struc
 			dput(result);
 			result = ERR_PTR(-ENOENT);
 		}
+	} else if (result->d_op && result->d_op->d_revalidate2) {
+		if (!result->d_op->d_revalidate2(result, flags, it) &&
+		    !d_invalidate(result)) {
+			dput(result);
+			goto again;
+		}
 	}
 	return result;
 }
@@ -334,7 +362,8 @@ int max_recursive_link = 5;
  * Without that kind of total limit, nasty chains of consecutive
  * symlinks can cause almost arbitrarily long lookups. 
  */
-static inline int do_follow_link(struct dentry *dentry, struct nameidata *nd)
+static inline int do_follow_link(struct dentry *dentry, struct nameidata *nd,
+				 struct lookup_intent *it)
 {
 	int err;
 	if (current->link_count >= max_recursive_link)
@@ -348,10 +377,14 @@ static inline int do_follow_link(struct 
 	current->link_count++;
 	current->total_link_count++;
 	UPDATE_ATIME(dentry->d_inode);
-	err = dentry->d_inode->i_op->follow_link(dentry, nd);
+	if (dentry->d_inode->i_op->follow_link2)
+		err = dentry->d_inode->i_op->follow_link2(dentry, nd, it);
+	else
+		err = dentry->d_inode->i_op->follow_link(dentry, nd);
 	current->link_count--;
 	return err;
 loop:
+	intent_release(dentry, it);
 	path_release(nd);
 	return -ELOOP;
 }
@@ -381,15 +414,26 @@ int follow_up(struct vfsmount **mnt, str
 	return __follow_up(mnt, dentry);
 }
 
-static inline int __follow_down(struct vfsmount **mnt, struct dentry **dentry)
+static inline int __follow_down(struct vfsmount **mnt, struct dentry **dentry,
+				struct lookup_intent *it)
 {
 	struct vfsmount *mounted;
 
 	spin_lock(&dcache_lock);
 	mounted = lookup_mnt(*mnt, *dentry);
 	if (mounted) {
+		int opc = 0, mode = 0;
 		*mnt = mntget(mounted);
 		spin_unlock(&dcache_lock);
+		if (it) {
+			opc = it->it_op;
+			mode = it->it_mode;
+		}
+		intent_release(*dentry, it);
+		if (it) {
+			it->it_op = opc;
+			it->it_mode = mode;
+		}
 		dput(*dentry);
 		mntput(mounted->mnt_parent);
 		*dentry = dget(mounted->mnt_root);
@@ -401,7 +445,7 @@ static inline int __follow_down(struct v
 
 int follow_down(struct vfsmount **mnt, struct dentry **dentry)
 {
-	return __follow_down(mnt,dentry);
+	return __follow_down(mnt,dentry,NULL);
 }
  
 static inline void follow_dotdot(struct nameidata *nd)
@@ -437,7 +481,7 @@ static inline void follow_dotdot(struct 
 		mntput(nd->mnt);
 		nd->mnt = parent;
 	}
-	while (d_mountpoint(nd->dentry) && __follow_down(&nd->mnt, &nd->dentry))
+	while (d_mountpoint(nd->dentry) && __follow_down(&nd->mnt, &nd->dentry, NULL))
 		;
 }
 
@@ -449,7 +493,8 @@ static inline void follow_dotdot(struct 
  *
  * We expect 'base' to be positive and a directory.
  */
-int link_path_walk(const char * name, struct nameidata *nd)
+int link_path_walk_it(const char *name, struct nameidata *nd,
+		      struct lookup_intent *it)
 {
 	struct dentry *dentry;
 	struct inode *inode;
@@ -526,18 +571,18 @@ int link_path_walk(const char * name, st
 				break;
 		}
 		/* This does the actual lookups.. */
-		dentry = cached_lookup(nd->dentry, &this, LOOKUP_CONTINUE);
+		dentry = cached_lookup(nd->dentry, &this, LOOKUP_CONTINUE, NULL);
 		if (!dentry) {
 			err = -EWOULDBLOCKIO;
 			if (atomic)
 				break;
-			dentry = real_lookup(nd->dentry, &this, LOOKUP_CONTINUE);
+			dentry = real_lookup(nd->dentry, &this, LOOKUP_CONTINUE, NULL);
 			err = PTR_ERR(dentry);
 			if (IS_ERR(dentry))
 				break;
 		}
 		/* Check mountpoints.. */
-		while (d_mountpoint(dentry) && __follow_down(&nd->mnt, &dentry))
+		while (d_mountpoint(dentry) && __follow_down(&nd->mnt, &dentry, NULL))
 			;
 
 		err = -ENOENT;
@@ -548,8 +593,8 @@ int link_path_walk(const char * name, st
 		if (!inode->i_op)
 			goto out_dput;
 
-		if (inode->i_op->follow_link) {
-			err = do_follow_link(dentry, nd);
+		if (inode->i_op->follow_link || inode->i_op->follow_link2) {
+			err = do_follow_link(dentry, nd, NULL);
 			dput(dentry);
 			if (err)
 				goto return_err;
@@ -565,7 +610,7 @@ int link_path_walk(const char * name, st
 			nd->dentry = dentry;
 		}
 		err = -ENOTDIR; 
-		if (!inode->i_op->lookup)
+		if (!inode->i_op->lookup && !inode->i_op->lookup2)
 			break;
 		continue;
 		/* here ends the main loop */
@@ -592,22 +637,23 @@ last_component:
 			if (err < 0)
 				break;
 		}
-		dentry = cached_lookup(nd->dentry, &this, 0);
+		dentry = cached_lookup(nd->dentry, &this, 0, it);
 		if (!dentry) {
 			err = -EWOULDBLOCKIO;
 			if (atomic)
 				break;
-			dentry = real_lookup(nd->dentry, &this, 0);
+			dentry = real_lookup(nd->dentry, &this, 0, it);
 			err = PTR_ERR(dentry);
 			if (IS_ERR(dentry))
 				break;
 		}
-		while (d_mountpoint(dentry) && __follow_down(&nd->mnt, &dentry))
+		while (d_mountpoint(dentry) && __follow_down(&nd->mnt, &dentry, it))
 			;
 		inode = dentry->d_inode;
 		if ((lookup_flags & LOOKUP_FOLLOW)
-		    && inode && inode->i_op && inode->i_op->follow_link) {
-			err = do_follow_link(dentry, nd);
+		    && inode && inode->i_op &&
+		    (inode->i_op->follow_link || inode->i_op->follow_link2)) {
+			err = do_follow_link(dentry, nd, it);
 			dput(dentry);
 			if (err)
 				goto return_err;
@@ -621,7 +667,8 @@ last_component:
 			goto no_inode;
 		if (lookup_flags & LOOKUP_DIRECTORY) {
 			err = -ENOTDIR; 
-			if (!inode->i_op || !inode->i_op->lookup)
+			if (!inode->i_op ||
+			    (!inode->i_op->lookup && !inode->i_op->lookup2))
 				break;
 		}
 		goto return_base;
@@ -645,7 +692,14 @@ return_reval:
 		 * Check the cached dentry for staleness.
 		 */
 		dentry = nd->dentry;
-		if (dentry && dentry->d_op && dentry->d_op->d_revalidate) {
+		if (dentry && dentry->d_op && dentry->d_op->d_revalidate2) {
+			err = -ESTALE;
+			if (!dentry->d_op->d_revalidate2(dentry, 0, it)) {
+				d_invalidate(dentry);
+				break;
+			}
+		} 
+                else if (dentry && dentry->d_op && dentry->d_op->d_revalidate){
 			err = -ESTALE;
 			if (!dentry->d_op->d_revalidate(dentry, 0)) {
 				d_invalidate(dentry);
@@ -658,15 +712,28 @@ out_dput:
 		dput(dentry);
 		break;
 	}
+	if (err)
+		intent_release(nd->dentry, it);
 	path_release(nd);
 return_err:
 	return err;
 }
 
+int link_path_walk(const char * name, struct nameidata *nd)
+{
+	return link_path_walk_it(name, nd, NULL);
+}
+
+int path_walk_it(const char * name, struct nameidata *nd, struct lookup_intent *it)
+{
+	current->total_link_count = 0;
+	return link_path_walk_it(name, nd, it);
+}
+
 int path_walk(const char * name, struct nameidata *nd)
 {
 	current->total_link_count = 0;
-	return link_path_walk(name, nd);
+	return link_path_walk_it(name, nd, NULL);
 }
 
 /* SMP-safe */
@@ -751,6 +818,17 @@ walk_init_root(const char *name, struct 
 }
 
 /* SMP-safe */
+int path_lookup_it(const char *path, unsigned flags, struct nameidata *nd,
+		   struct lookup_intent *it)
+{
+	int error = 0;
+	if (path_init(path, flags, nd))
+		error = path_walk_it(path, nd, it);
+	return error;
+}
+
+
+/* SMP-safe */
 int path_lookup(const char *path, unsigned flags, struct nameidata *nd)
 {
 	int error = 0;
@@ -779,7 +857,8 @@ int path_init(const char *name, unsigned
  * needs parent already locked. Doesn't follow mounts.
  * SMP-safe.
  */
-struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+struct dentry * lookup_hash_it(struct qstr *name, struct dentry * base,
+			       struct lookup_intent *it)
 {
 	struct dentry * dentry;
 	struct inode *inode;
@@ -802,13 +881,16 @@ struct dentry * lookup_hash(struct qstr 
 			goto out;
 	}
 
-	dentry = cached_lookup(base, name, 0);
+	dentry = cached_lookup(base, name, 0, it);
 	if (!dentry) {
 		struct dentry *new = d_alloc(base, name);
 		dentry = ERR_PTR(-ENOMEM);
 		if (!new)
 			goto out;
 		lock_kernel();
+		if (inode->i_op->lookup2)
+			dentry = inode->i_op->lookup2(inode, new, it);
+		else
 		dentry = inode->i_op->lookup(inode, new);
 		unlock_kernel();
 		if (!dentry)
@@ -820,6 +902,12 @@ out:
 	return dentry;
 }
 
+struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+{
+	return lookup_hash_it(name, base, NULL);
+}
+
+
 /* SMP-safe */
 struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
 {
@@ -841,7 +929,7 @@ struct dentry * lookup_one_len(const cha
 	}
 	this.hash = end_name_hash(hash);
 
-	return lookup_hash(&this, base);
+	return lookup_hash_it(&this, base, NULL);
 access:
 	return ERR_PTR(-EACCES);
 }
@@ -872,6 +960,23 @@ int __user_walk(const char *name, unsign
 	return err;
 }
 
+int __user_walk_it(const char *name, unsigned flags, struct nameidata *nd,
+		   struct lookup_intent *it)
+{
+	char *tmp;
+	int err;
+
+	tmp = getname(name);
+	err = PTR_ERR(tmp);
+	if (!IS_ERR(tmp)) {
+		err = 0;
+		if (path_init(tmp, flags, nd))
+			err = path_walk_it(tmp, nd, it);
+		putname(tmp);
+	}
+	return err;
+}
+
 /*
  * It's inline, so penalty for filesystems that don't use sticky bit is
  * minimal.
@@ -1045,14 +1150,17 @@ int may_open(struct nameidata *nd, int a
         return get_lease(inode, flag);
 }
 
+extern struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt,
+				   int flags, struct lookup_intent *it);
+
 struct file *filp_open(const char * pathname, int open_flags, int mode)
 {
 	int acc_mode, error = 0;
-	struct inode *inode;
 	struct dentry *dentry;
 	struct dentry *dir;
 	int flag = open_flags;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_OPEN, .it_flags = open_flags };
 	int count = 0;
 
 	if ((flag+1) & O_ACCMODE)
@@ -1066,7 +1174,7 @@ struct file *filp_open(const char * path
 	 * The simplest case - just a plain lookup.
 	 */
 	if (!(flag & O_CREAT)) {
-		error = path_lookup(pathname, lookup_flags(flag), &nd);
+		error = path_lookup_it(pathname, lookup_flags(flag), &nd, &it);
 		if (error)
 			return ERR_PTR(error);
 		dentry = nd.dentry;
@@ -1076,6 +1184,8 @@ struct file *filp_open(const char * path
 	/*
 	 * Create - we need to know the parent.
 	 */
+	it.it_mode = mode;
+	it.it_op |= IT_CREAT;
 	error = path_lookup(pathname, LOOKUP_PARENT, &nd);
 	if (error)
 		return ERR_PTR(error);
@@ -1091,7 +1201,7 @@ struct file *filp_open(const char * path
 
 	dir = nd.dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, &it);
 
 do_last:
 	error = PTR_ERR(dentry);
@@ -1100,6 +1210,7 @@ do_last:
 		goto exit;
 	}
 
+	it.it_mode = mode;
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		error = vfs_create(dir->d_inode, dentry,
@@ -1129,12 +1240,13 @@ do_last:
 		error = -ELOOP;
 		if (flag & O_NOFOLLOW)
 			goto exit_dput;
-		while (__follow_down(&nd.mnt,&dentry) && d_mountpoint(dentry));
+		while (__follow_down(&nd.mnt,&dentry,&it) && d_mountpoint(dentry));
 	}
 	error = -ENOENT;
 	if (!dentry->d_inode)
 		goto exit_dput;
-	if (dentry->d_inode->i_op && dentry->d_inode->i_op->follow_link)
+	if (dentry->d_inode->i_op && (dentry->d_inode->i_op->follow_link ||
+				      dentry->d_inode->i_op->follow_link2))
 		goto do_link;
 
 	dput(nd.dentry);
@@ -1149,11 +1261,13 @@ ok:
 	if (!S_ISREG(nd.dentry->d_inode->i_mode))
 		open_flags &= ~O_TRUNC;
 
-        return dentry_open(nd.dentry, nd.mnt, open_flags);
+	return dentry_open_it(nd.dentry, nd.mnt, open_flags, &it);
 
 exit_dput:
+	intent_release(dentry, &it);
 	dput(dentry);
 exit:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 	return ERR_PTR(error);
 
@@ -1172,10 +1286,15 @@ do_link:
 	 * are done. Procfs-like symlinks just set LAST_BIND.
 	 */
 	UPDATE_ATIME(dentry->d_inode);
-	error = dentry->d_inode->i_op->follow_link(dentry, &nd);
+	if (dentry->d_inode->i_op->follow_link2)
+		error = dentry->d_inode->i_op->follow_link2(dentry, &nd, &it);
+	else
+		error = dentry->d_inode->i_op->follow_link(dentry, &nd);
+	if (error)
+		intent_release(dentry, &it);
 	dput(dentry);
 	if (error)
-		return error;
+		return ERR_PTR(error);
 	if (nd.last_type == LAST_BIND) {
 		dentry = nd.dentry;
 		goto ok;
@@ -1194,13 +1313,15 @@ do_link:
 	}
 	dir = nd.dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, &it);
 	putname(nd.last.name);
 	goto do_last;
 }
 
+
 /* SMP-safe */
-static struct dentry *lookup_create(struct nameidata *nd, int is_dir)
+static struct dentry *lookup_create(struct nameidata *nd, int is_dir,
+				    struct lookup_intent *it)
 {
 	struct dentry *dentry;
 
@@ -1208,7 +1329,7 @@ static struct dentry *lookup_create(stru
 	dentry = ERR_PTR(-EEXIST);
 	if (nd->last_type != LAST_NORM)
 		goto fail;
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash_it(&nd->last, nd->dentry, it);
 	if (IS_ERR(dentry))
 		goto fail;
 	if (!is_dir && nd->last.name[nd->last.len] && !dentry->d_inode)
@@ -1264,7 +1385,19 @@ asmlinkage long sys_mknod(const char * f
 	error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
-	dentry = lookup_create(&nd, 0);
+
+	if (nd.dentry->d_inode->i_op->mknod2) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->mknod2(nd.dentry->d_inode,
+				   nd.last.name,
+				   nd.last.len,
+				   mode, dev);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto out2;
+	}
+
+	dentry = lookup_create(&nd, 0, NULL);
 	error = PTR_ERR(dentry);
 
 	mode &= ~current->fs->umask;
@@ -1285,6 +1418,7 @@ asmlinkage long sys_mknod(const char * f
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
+out2:
 	path_release(&nd);
 out:
 	putname(tmp);
@@ -1332,7 +1466,17 @@ asmlinkage long sys_mkdir(const char * p
 		error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
-		dentry = lookup_create(&nd, 1);
+		if (nd.dentry->d_inode->i_op->mkdir2) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->mkdir2(nd.dentry->d_inode,
+					   nd.last.name,
+					   nd.last.len,
+					   mode);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out2;
+		}
+		dentry = lookup_create(&nd, 1, NULL);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1340,6 +1484,7 @@ asmlinkage long sys_mkdir(const char * p
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+out2:
 		path_release(&nd);
 out:
 		putname(tmp);
@@ -1440,8 +1585,33 @@ asmlinkage long sys_rmdir(const char * p
 			error = -EBUSY;
 			goto exit1;
 	}
+	if (nd.dentry->d_inode->i_op->rmdir2) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		struct dentry *last;
+
+		down(&nd.dentry->d_inode->i_sem);
+		last = lookup_hash_it(&nd.last, nd.dentry, NULL);
+		up(&nd.dentry->d_inode->i_sem);
+		if (IS_ERR(last)) {
+			error = PTR_ERR(last);
+			goto exit1;
+		}
+		if (d_mountpoint(last)) {
+			dput(last);
+			error = -EBUSY;
+			goto exit1;
+		}
+		dput(last);
+
+		error = op->rmdir2(nd.dentry->d_inode,
+				   nd.last.name,
+				   nd.last.len);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit1;
+	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, NULL);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1499,8 +1669,17 @@ asmlinkage long sys_unlink(const char * 
 	error = -EISDIR;
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
+	if (nd.dentry->d_inode->i_op->unlink2) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->unlink2(nd.dentry->d_inode,
+				    nd.last.name,
+				    nd.last.len);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit1;
+	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, NULL);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/* Why not before? Because we want correct error value */
@@ -1567,15 +1746,26 @@ asmlinkage long sys_symlink(const char *
 		error = path_lookup(to, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
-		dentry = lookup_create(&nd, 0);
+		if (nd.dentry->d_inode->i_op->symlink2) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->symlink2(nd.dentry->d_inode,
+					     nd.last.name,
+					     nd.last.len,
+					     from);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out2;
+		}
+		dentry = lookup_create(&nd, 0, NULL);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+	out2:
 		path_release(&nd);
-out:
+	out:
 		putname(to);
 	}
 	putname(from);
@@ -1642,7 +1832,7 @@ asmlinkage long sys_link(const char * ol
 		struct dentry *new_dentry;
 		struct nameidata nd, old_nd;
 
-		error = __user_walk(oldname, LOOKUP_POSITIVE, &old_nd);
+		error = __user_walk_it(oldname, LOOKUP_POSITIVE, &old_nd, NULL);
 		if (error)
 			goto exit;
 		error = path_lookup(to, LOOKUP_PARENT, &nd);
@@ -1651,7 +1841,17 @@ asmlinkage long sys_link(const char * ol
 		error = -EXDEV;
 		if (old_nd.mnt != nd.mnt)
 			goto out_release;
-		new_dentry = lookup_create(&nd, 0);
+		if (nd.dentry->d_inode->i_op->link2) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->link2(old_nd.dentry->d_inode,
+					  nd.dentry->d_inode,
+					  nd.last.name,
+					  nd.last.len);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out_release;
+		}
+		new_dentry = lookup_create(&nd, 0, NULL);
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -1695,7 +1895,8 @@ exit:
  *	   locking].
  */
 int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+		   struct inode *new_dir, struct dentry *new_dentry,
+		   struct lookup_intent *it)
 {
 	int error;
 	struct inode *target;
@@ -1753,6 +1954,7 @@ int vfs_rename_dir(struct inode *old_dir
 		error = -EBUSY;
 	else 
 		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
+	intent_release(new_dentry, it);
 	if (target) {
 		if (!error)
 			target->i_flags |= S_DEAD;
@@ -1774,7 +1976,8 @@ out_unlock:
 }
 
 int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+		     struct inode *new_dir, struct dentry *new_dentry,
+		     struct lookup_intent *it)
 {
 	int error;
 
@@ -1805,6 +2008,7 @@ int vfs_rename_other(struct inode *old_d
 		error = -EBUSY;
 	else
 		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
+	intent_release(new_dentry, it);
 	double_up(&old_dir->i_zombie, &new_dir->i_zombie);
 	if (error)
 		return error;
@@ -1816,13 +2020,14 @@ int vfs_rename_other(struct inode *old_d
 }
 
 int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+	       struct inode *new_dir, struct dentry *new_dentry,
+	       struct lookup_intent *it)
 {
 	int error;
 	if (S_ISDIR(old_dentry->d_inode->i_mode))
-		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);
+		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry,it);
 	else
-		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);
+		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry,it);
 	if (!error) {
 		if (old_dir == new_dir)
 			inode_dir_notify(old_dir, DN_RENAME);
@@ -1864,7 +2069,7 @@ static inline int do_rename(const char *
 
 	double_lock(new_dir, old_dir);
 
-	old_dentry = lookup_hash(&oldnd.last, old_dir);
+	old_dentry = lookup_hash_it(&oldnd.last, old_dir, NULL);
 	error = PTR_ERR(old_dentry);
 	if (IS_ERR(old_dentry))
 		goto exit3;
@@ -1880,16 +2085,37 @@ static inline int do_rename(const char *
 		if (newnd.last.name[newnd.last.len])
 			goto exit4;
 	}
-	new_dentry = lookup_hash(&newnd.last, new_dir);
+	new_dentry = lookup_hash_it(&newnd.last, new_dir, NULL);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto exit4;
 
+	if (old_dir->d_inode->i_op->rename2) {
+		lock_kernel();
+		/* don't rename mount point. mds will take care of
+		 * the rest sanity checking */
+		if (d_mountpoint(old_dentry)||d_mountpoint(new_dentry)) {
+			error = -EBUSY;
+			goto exit5;
+		}
+
+		error = old_dir->d_inode->i_op->rename2(old_dir->d_inode,
+							new_dir->d_inode,
+							oldnd.last.name,
+							oldnd.last.len,
+							newnd.last.name,
+							newnd.last.len);
+		unlock_kernel();
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit5;
+	}
+
 	lock_kernel();
 	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
+				   new_dir->d_inode, new_dentry, NULL);
 	unlock_kernel();
-
+exit5:
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -1940,7 +2166,8 @@ out:
 }
 
 static inline int
-__vfs_follow_link(struct nameidata *nd, const char *link)
+__vfs_follow_link(struct nameidata *nd, const char *link,
+		  struct lookup_intent *it)
 {
 	int res = 0;
 	char *name;
@@ -1953,7 +2180,7 @@ __vfs_follow_link(struct nameidata *nd, 
 			/* weird __emul_prefix() stuff did it */
 			goto out;
 	}
-	res = link_path_walk(link, nd);
+	res = link_path_walk_it(link, nd, it);
 out:
 	if (current->link_count || res || nd->last_type!=LAST_NORM)
 		return res;
@@ -1975,7 +2202,13 @@ fail:
 
 int vfs_follow_link(struct nameidata *nd, const char *link)
 {
-	return __vfs_follow_link(nd, link);
+	return __vfs_follow_link(nd, link, NULL);
+}
+
+int vfs_follow_link_it(struct nameidata *nd, const char *link,
+		       struct lookup_intent *it)
+{
+	return __vfs_follow_link(nd, link, it);
 }
 
 /* get the link contents into pagecache */
@@ -2017,7 +2250,7 @@ int page_follow_link(struct dentry *dent
 {
 	struct page *page = NULL;
 	char *s = page_getlink(dentry, &page);
-	int res = __vfs_follow_link(nd, s);
+	int res = __vfs_follow_link(nd, s, NULL);
 	if (page) {
 		kunmap(page);
 		page_cache_release(page);
--- lum/fs/nfsd/vfs.c~vfs_intent-2.4.18-18	Fri Feb 28 11:50:28 2003
+++ lum-braam/fs/nfsd/vfs.c	Fri Feb 28 11:50:28 2003
@@ -1298,7 +1298,7 @@ nfsd_rename(struct svc_rqst *rqstp, stru
 			err = nfserr_perm;
 	} else
 #endif
-	err = vfs_rename(fdir, odentry, tdir, ndentry);
+	err = vfs_rename(fdir, odentry, tdir, ndentry, NULL);
 	unlock_kernel();
 	if (!err && EX_ISSYNC(tfhp->fh_export)) {
 		nfsd_sync_dir(tdentry);
--- lum/fs/open.c~vfs_intent-2.4.18-18	Fri Feb 28 11:50:28 2003
+++ lum-braam/fs/open.c	Fri Feb 28 11:50:28 2003
@@ -19,6 +19,8 @@
 #include <asm/uaccess.h>
 
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
+extern int path_walk_it(const char *name, struct nameidata *nd,
+			struct lookup_intent *it);
 
 int vfs_statfs(struct super_block *sb, struct statfs *buf)
 {
@@ -95,9 +97,10 @@ void fd_install(unsigned int fd, struct 
 	write_unlock(&files->file_lock);
 }
 
-int do_truncate(struct dentry *dentry, loff_t length)
+int do_truncate(struct dentry *dentry, loff_t length, int called_from_open)
 {
 	struct inode *inode = dentry->d_inode;
+	struct inode_operations *op = dentry->d_inode->i_op;
 	int error;
 	struct iattr newattrs;
 
@@ -108,7 +111,14 @@ int do_truncate(struct dentry *dentry, l
 	down(&inode->i_sem);
 	newattrs.ia_size = length;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
-	error = notify_change(dentry, &newattrs);
+	if (called_from_open)
+		newattrs.ia_valid |= ATTR_FROM_OPEN;
+	if (op->setattr_raw) {
+		newattrs.ia_valid |= ATTR_RAW;
+		newattrs.ia_ctime = CURRENT_TIME;
+		error = op->setattr_raw(inode, &newattrs);
+	} else 
+		error = notify_change(dentry, &newattrs);
 	up(&inode->i_sem);
 	return error;
 }
@@ -118,12 +128,13 @@ static inline long do_sys_truncate(const
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
 
-	error = user_path_walk(path, &nd);
+	error = user_path_walk_it(path, &nd, &it);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
@@ -163,11 +174,13 @@ static inline long do_sys_truncate(const
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
-		error = do_truncate(nd.dentry, length);
+		intent_release(nd.dentry, &it);
+		error = do_truncate(nd.dentry, length, 0);
 	}
 	put_write_access(inode);
 
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -215,7 +228,7 @@ static inline long do_sys_ftruncate(unsi
 
 	error = locks_verify_truncate(inode, file, length);
 	if (!error)
-		error = do_truncate(dentry, length);
+		error = do_truncate(dentry, length, 0);
 out_putf:
 	fput(file);
 out:
@@ -260,11 +273,13 @@ asmlinkage long sys_utime(char * filenam
 	struct inode * inode;
 	struct iattr newattrs;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, NULL);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
 
+	/* this is safe without a Lustre lock because it only depends
+	   on the super block */
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
@@ -279,11 +294,29 @@ asmlinkage long sys_utime(char * filenam
 			goto dput_and_out;
 
 		newattrs.ia_valid |= ATTR_ATIME_SET | ATTR_MTIME_SET;
-	} else {
+	}
+
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	}
+
+	error = -EROFS;
+	if (IS_RDONLY(inode))
+		goto dput_and_out;
+
+	error = -EPERM;
+	if (!times) {
 		if (current->fsuid != inode->i_uid &&
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
+
 	error = notify_change(nd.dentry, &newattrs);
 dput_and_out:
 	path_release(&nd);
@@ -304,12 +337,14 @@ asmlinkage long sys_utimes(char * filena
 	struct inode * inode;
 	struct iattr newattrs;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, NULL);
 
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
 
+	/* this is safe without a Lustre lock because it only depends
+	   on the super block */
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
@@ -324,7 +359,20 @@ asmlinkage long sys_utimes(char * filena
 		newattrs.ia_atime = times[0].tv_sec;
 		newattrs.ia_mtime = times[1].tv_sec;
 		newattrs.ia_valid |= ATTR_ATIME_SET | ATTR_MTIME_SET;
-	} else {
+	}
+
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	}
+
+	error = -EPERM;
+	if (!utimes) {
 		if (current->fsuid != inode->i_uid &&
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
@@ -347,6 +395,7 @@ asmlinkage long sys_access(const char * 
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -364,13 +413,14 @@ asmlinkage long sys_access(const char * 
 	else
 		current->cap_effective = current->cap_permitted;
 
-	res = user_path_walk(filename, &nd);
+	res = user_path_walk_it(filename, &nd, &it);
 	if (!res) {
 		res = permission(nd.dentry->d_inode, mode);
 		/* SuS v2 requires we report a read only fs too */
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 
@@ -385,8 +435,11 @@ asmlinkage long sys_chdir(const char * f
 {
 	int error;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = __user_walk(filename,LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY,&nd);
+	error = __user_walk_it(filename,
+			       LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY,
+			       &nd, &it);
 	if (error)
 		goto out;
 
@@ -397,6 +450,7 @@ asmlinkage long sys_chdir(const char * f
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -436,9 +490,10 @@ asmlinkage long sys_chroot(const char * 
 {
 	int error;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = __user_walk(filename, LOOKUP_POSITIVE | LOOKUP_FOLLOW |
-		      LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
+	error = __user_walk_it(filename, LOOKUP_POSITIVE | LOOKUP_FOLLOW |
+			       LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd, &it);
 	if (error)
 		goto out;
 
@@ -454,6 +509,7 @@ asmlinkage long sys_chroot(const char * 
 	set_fs_altroot();
 	error = 0;
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -508,6 +564,18 @@ asmlinkage long sys_chmod(const char * f
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
 
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_mode = mode;
+		newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	}
+
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
@@ -538,6 +606,20 @@ static int chown_common(struct dentry * 
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto out;
+
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = dentry->d_inode->i_op;
+
+		newattrs.ia_uid = user;
+		newattrs.ia_gid = group;
+		newattrs.ia_valid = ATTR_UID | ATTR_GID;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			return error;
+	}
+
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
@@ -628,7 +710,8 @@ extern ssize_t do_readahead(struct file 
 /* for files over a certains size it doesn't pay to do readahead on open */
 #define READAHEAD_CUTOFF 48000
 
-struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt,
+			    int flags, struct lookup_intent *it)
 {
 	struct file * f;
 	struct inode *inode;
@@ -649,7 +732,7 @@ struct file *dentry_open(struct dentry *
 		error = locks_verify_locked(inode);
 		if (!error) {
 			DQUOT_INIT(inode);
-			error = do_truncate(dentry, 0);
+			error = do_truncate(dentry, 0, 1);
 		}
 		if (error || !(f->f_mode & FMODE_WRITE))
 			put_write_access(inode);
@@ -693,6 +776,7 @@ struct file *dentry_open(struct dentry *
 		do_readahead(f, 0, (48 * 1024) >> PAGE_SHIFT);
 	
 
+	intent_release(dentry, it);
 	return f;
 
 cleanup_all:
@@ -707,11 +791,17 @@ cleanup_all:
 cleanup_file:
 	put_filp(f);
 cleanup_dentry:
+	intent_release(dentry, it);
 	dput(dentry);
 	mntput(mnt);
 	return ERR_PTR(error);
 }
 
+struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+{
+	return dentry_open_it(dentry, mnt, flags, NULL);
+}
+
 /*
  * Find an empty file descriptor entry, and mark it busy.
  */
--- lum/fs/stat.c~vfs_intent-2.4.18-18	Fri Feb 28 11:50:28 2003
+++ lum-braam/fs/stat.c	Fri Feb 28 11:50:28 2003
@@ -104,10 +104,12 @@ int vfs_stat(char *name, struct kstat *s
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = user_path_walk(name, &nd);
+	error = user_path_walk_it(name, &nd, &it);
 	if (!error) {
 		error = do_getattr(nd.mnt, nd.dentry, stat);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
@@ -117,10 +119,12 @@ int vfs_lstat(char *name, struct kstat *
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = user_path_walk_link(name, &nd);
+	error = user_path_walk_link_it(name, &nd, &it);
 	if (!error) {
 		error = do_getattr(nd.mnt, nd.dentry, stat);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
--- lum/fs/exec.c~vfs_intent-2.4.18-18	Fri Feb 28 11:50:28 2003
+++ lum-braam/fs/exec.c	Fri Feb 28 11:50:28 2003
@@ -103,13 +103,18 @@ static inline void put_binfmt(struct lin
  *
  * Also note that we take the address to load from from the file itself.
  */
+extern struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt,
+			    int flags, struct lookup_intent *it);
+int path_lookup_it(const char *path, unsigned flags, struct nameidata *nd,
+		   struct lookup_intent *it);
 asmlinkage long sys_uselib(const char * library)
 {
 	struct file * file;
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_OPEN, .it_flags = O_RDONLY };
 
-	error = user_path_walk(library, &nd);
+	error = user_path_walk_it(library, &nd, &it);
 	if (error)
 		goto out;
 
@@ -121,7 +126,8 @@ asmlinkage long sys_uselib(const char * 
 	if (error)
 		goto exit;
 
-	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
+	file = dentry_open_it(nd.dentry, nd.mnt, O_RDONLY, &it);
+	intent_release(nd.dentry, &it);
 	error = PTR_ERR(file);
 	if (IS_ERR(file))
 		goto out;
@@ -350,8 +356,9 @@ struct file *open_exec(const char *name)
 	struct inode *inode;
 	struct file *file;
 	int err = 0;
+	struct lookup_intent it = { .it_op = IT_OPEN, .it_flags = O_RDONLY };
 
-	err = path_lookup(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, &nd);
+	err = path_lookup_it(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, &nd, &it);
 	file = ERR_PTR(err);
 	if (!err) {
 		inode = nd.dentry->d_inode;
@@ -363,7 +370,8 @@ struct file *open_exec(const char *name)
 				err = -EACCES;
 			file = ERR_PTR(err);
 			if (!err) {
-				file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
+				file = dentry_open_it(nd.dentry, nd.mnt, O_RDONLY, &it);
+				intent_release(nd.dentry, &it);
 				if (!IS_ERR(file)) {
 					err = deny_write_access(file);
 					if (err) {
@@ -976,7 +984,7 @@ int do_coredump(long signr, struct pt_re
 		goto close_fail;
 	if (!file->f_op->write)
 		goto close_fail;
-	if (do_truncate(file->f_dentry, 0) != 0)
+	if (do_truncate(file->f_dentry, 0, 0) != 0)
 		goto close_fail;
 
 	retval = binfmt->core_dump(signr, regs, file);
--- lum/include/linux/dcache.h~vfs_intent-2.4.18-18	Fri Feb 28 11:50:28 2003
+++ lum-braam/include/linux/dcache.h	Fri Feb 28 11:50:28 2003
@@ -6,6 +6,25 @@
 #include <asm/atomic.h>
 #include <linux/mount.h>
 
+#define IT_OPEN     (1)
+#define IT_CREAT    (1<<1)
+#define IT_READDIR  (1<<2)
+#define IT_GETATTR  (1<<3)
+#define IT_LOOKUP   (1<<4)
+#define IT_UNLINK   (1<<5)
+
+struct lookup_intent {
+	int it_op;
+	int it_mode;
+	int it_flags;
+	int it_disposition;
+	int it_status;
+	struct iattr *it_iattr;
+	__u64 it_lock_handle[2];
+	int it_lock_mode;
+	void *it_data;
+};
+
 /*
  * linux/include/linux/dcache.h
  *
@@ -78,6 +97,7 @@ struct dentry {
 	unsigned long d_time;		/* used by d_revalidate */
 	struct dentry_operations  *d_op;
 	struct super_block * d_sb;	/* The root of the dentry tree */
+	struct lookup_intent *d_it;
 	unsigned long d_vfs_flags;
 	void * d_fsdata;		/* fs-specific data */
 	void * d_extra_attributes;	/* TUX-specific data */
@@ -91,8 +111,15 @@ struct dentry_operations {
 	int (*d_delete)(struct dentry *);
 	void (*d_release)(struct dentry *);
 	void (*d_iput)(struct dentry *, struct inode *);
+	int (*d_revalidate2)(struct dentry *, int, struct lookup_intent *);
+	void (*d_intent_release)(struct dentry *, struct lookup_intent *);
 };
 
+/* defined in fs/namei.c */
+extern void intent_release(struct dentry *de, struct lookup_intent *it);
+/* defined in fs/dcache.c */
+extern void __d_rehash(struct dentry * entry, int lock);
+
 /* the dentry parameter passed to d_hash and d_compare is the parent
  * directory of the entries to be compared. It is used in case these
  * functions need any directory specific information for determining
@@ -124,6 +151,7 @@ d_iput:		no		no		yes
 					 * s_nfsd_free_path semaphore will be down
 					 */
 #define DCACHE_REFERENCED	0x0008  /* Recently used, don't discard. */
+#define DCACHE_LUSTRE_INVALID	0x0010  /* Lustre invalidated */
 
 extern spinlock_t dcache_lock;
 
--- lum/include/linux/fs.h~vfs_intent-2.4.18-18	Fri Feb 28 11:50:28 2003
+++ lum-braam/include/linux/fs.h	Wed Mar 19 15:45:36 2003
@@ -338,6 +338,8 @@ extern void set_bh_page(struct buffer_he
 #define ATTR_MTIME_SET	256
 #define ATTR_FORCE	512	/* Not a change, but a change it */
 #define ATTR_ATTR_FLAG	1024
+#define ATTR_RAW	2048	/* file system, not vfs will massage attrs */
+#define ATTR_FROM_OPEN	4096	/* called from open path, ie O_TRUNC */
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
@@ -576,6 +578,7 @@ struct file {
 
 	/* needed for tty driver, and maybe others */
 	void			*private_data;
+	struct lookup_intent    *f_intent;
 
 	/* preallocated helper kiobuf to speedup O_DIRECT */
 	struct kiobuf		*f_iobuf;
@@ -836,7 +839,9 @@ extern int vfs_symlink(struct inode *, s
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *);
-extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+		struct inode *new_dir, struct dentry *new_dentry,
+		struct lookup_intent *it);
 
 /*
  * File types
@@ -897,20 +902,33 @@ struct file_operations {
 struct inode_operations {
 	int (*create) (struct inode *,struct dentry *,int);
 	struct dentry * (*lookup) (struct inode *,struct dentry *);
+	struct dentry * (*lookup2) (struct inode *,struct dentry *, struct lookup_intent *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
+	int (*link2) (struct inode *,struct inode *, const char *, int);
 	int (*unlink) (struct inode *,struct dentry *);
+	int (*unlink2) (struct inode *, const char *, int);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
+	int (*symlink2) (struct inode *, const char *, int, const char *);
 	int (*mkdir) (struct inode *,struct dentry *,int);
+	int (*mkdir2) (struct inode *, const char *, int,int);
 	int (*rmdir) (struct inode *,struct dentry *);
+	int (*rmdir2) (struct inode *, const char *, int);
 	int (*mknod) (struct inode *,struct dentry *,int,int);
+	int (*mknod2) (struct inode *, const char *, int,int,int);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
+	int (*rename2) (struct inode *, struct inode *,
+			const char *oldname, int oldlen,
+			const char *newname, int newlen);
 	int (*readlink) (struct dentry *, char *,int);
 	int (*follow_link) (struct dentry *, struct nameidata *);
+	int (*follow_link2) (struct dentry *, struct nameidata *,
+			     struct lookup_intent *it);
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int);
 	int (*revalidate) (struct dentry *);
 	int (*setattr) (struct dentry *, struct iattr *);
+	int (*setattr_raw) (struct inode *, struct iattr *);
 	int (*getattr) (struct dentry *, struct iattr *);
 };
 
@@ -1112,7 +1130,7 @@ static inline int get_lease(struct inode
 
 asmlinkage long sys_open(const char *, int, int);
 asmlinkage long sys_close(unsigned int);	/* yes, it's really unsigned */
-extern int do_truncate(struct dentry *, loff_t start);
+extern int do_truncate(struct dentry *, loff_t start, int called_from_open);
 
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
@@ -1381,6 +1399,7 @@ typedef int (*read_actor_t)(read_descrip
 extern loff_t default_llseek(struct file *file, loff_t offset, int origin);
 
 extern int FASTCALL(__user_walk(const char *, unsigned, struct nameidata *));
+extern int FASTCALL(__user_walk_it(const char *, unsigned, struct nameidata *, struct lookup_intent *it));
 extern int FASTCALL(path_init(const char *, unsigned, struct nameidata *));
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
@@ -1392,6 +1411,8 @@ extern struct dentry * lookup_one_len(co
 extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
 #define user_path_walk(name,nd)	 __user_walk(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd)
 #define user_path_walk_link(name,nd) __user_walk(name, LOOKUP_POSITIVE, nd)
+#define user_path_walk_it(name,nd,it)  __user_walk_it(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd, it)
+#define user_path_walk_link_it(name,nd,it) __user_walk_it(name, LOOKUP_POSITIVE, nd, it)
 
 extern void inode_init_once(struct inode *);
 extern void iput(struct inode *);
@@ -1492,6 +1513,8 @@ extern struct file_operations generic_ro
 
 extern int vfs_readlink(struct dentry *, char *, int, const char *);
 extern int vfs_follow_link(struct nameidata *, const char *);
+extern int vfs_follow_link_it(struct nameidata *, const char *,
+			      struct lookup_intent *it);
 extern int page_readlink(struct dentry *, char *, int);
 extern int page_follow_link(struct dentry *, struct nameidata *);
 extern struct inode_operations page_symlink_inode_operations;
--- lum/kernel/ksyms.c~vfs_intent-2.4.18-18	Fri Feb 28 11:50:28 2003
+++ lum-braam/kernel/ksyms.c	Fri Feb 28 11:50:28 2003
@@ -293,6 +293,7 @@ EXPORT_SYMBOL(read_cache_page);
 EXPORT_SYMBOL(set_page_dirty);
 EXPORT_SYMBOL(vfs_readlink);
 EXPORT_SYMBOL(vfs_follow_link);
+EXPORT_SYMBOL(vfs_follow_link_it);
 EXPORT_SYMBOL(page_readlink);
 EXPORT_SYMBOL(page_follow_link);
 EXPORT_SYMBOL(page_symlink_inode_operations);

_



 fs/inode.c         |   21 ++++++++++++++-------
 fs/super.c         |    4 ++--
 include/linux/fs.h |    2 +-
 3 files changed, 17 insertions(+), 10 deletions(-)

--- linux-2.4.20/fs/inode.c~invalidate_show	2003-04-08 23:34:36.000000000 -0600
+++ linux-2.4.20-braam/fs/inode.c	2003-04-08 23:34:36.000000000 -0600
@@ -553,7 +553,8 @@ static void dispose_list(struct list_hea
 /*
  * Invalidate all inodes for a device.
  */
-static int invalidate_list(struct list_head *head, struct super_block * sb, struct list_head * dispose)
+static int invalidate_list(struct list_head *head, struct super_block * sb,
+			   struct list_head * dispose, int show)
 {
 	struct list_head *next;
 	int busy = 0, count = 0;
@@ -578,6 +579,11 @@ static int invalidate_list(struct list_h
 			count++;
 			continue;
 		}
+		if (show)
+			printk(KERN_ERR
+			       "inode busy: dev %s:%lu (%p) mode %o count %u\n",
+			       kdevname(sb->s_dev), inode->i_ino, inode,
+			       inode->i_mode, atomic_read(&inode->i_count));
 		busy = 1;
 	}
 	/* only unused inodes may be cached with i_count zero */
@@ -596,22 +602,23 @@ static int invalidate_list(struct list_h
 /**
  *	invalidate_inodes	- discard the inodes on a device
  *	@sb: superblock
+ *	@show: whether we should display any busy inodes found
  *
  *	Discard all of the inodes for a given superblock. If the discard
  *	fails because there are busy inodes then a non zero value is returned.
  *	If the discard is successful all the inodes have been discarded.
  */
  
-int invalidate_inodes(struct super_block * sb)
+int invalidate_inodes(struct super_block * sb, int show)
 {
 	int busy;
 	LIST_HEAD(throw_away);
 
 	spin_lock(&inode_lock);
-	busy = invalidate_list(&inode_in_use, sb, &throw_away);
-	busy |= invalidate_list(&inode_unused, sb, &throw_away);
-	busy |= invalidate_list(&sb->s_dirty, sb, &throw_away);
-	busy |= invalidate_list(&sb->s_locked_inodes, sb, &throw_away);
+	busy = invalidate_list(&inode_in_use, sb, &throw_away, show);
+	busy |= invalidate_list(&inode_unused, sb, &throw_away, show);
+	busy |= invalidate_list(&sb->s_dirty, sb, &throw_away, show);
+	busy |= invalidate_list(&sb->s_locked_inodes, sb, &throw_away, show);
 	spin_unlock(&inode_lock);
 
 	dispose_list(&throw_away);
@@ -637,7 +644,7 @@ int invalidate_device(kdev_t dev, int do
 		 * hold).
 		 */
 		shrink_dcache_sb(sb);
-		res = invalidate_inodes(sb);
+		res = invalidate_inodes(sb, 0);
 		drop_super(sb);
 	}
 	invalidate_buffers(dev);
--- linux-2.4.20/fs/super.c~invalidate_show	2003-04-08 23:34:36.000000000 -0600
+++ linux-2.4.20-braam/fs/super.c	2003-04-08 23:34:36.000000000 -0600
@@ -835,7 +835,7 @@ void kill_super(struct super_block *sb)
 	lock_super(sb);
 	lock_kernel();
 	sb->s_flags &= ~MS_ACTIVE;
-	invalidate_inodes(sb);	/* bad name - it should be evict_inodes() */
+	invalidate_inodes(sb, 0);  /* bad name - it should be evict_inodes() */
 	if (sop) {
 		if (sop->write_super && sb->s_dirt)
 			sop->write_super(sb);
@@ -844,7 +844,7 @@ void kill_super(struct super_block *sb)
 	}
 
 	/* Forget any remaining inodes */
-	if (invalidate_inodes(sb)) {
+	if (invalidate_inodes(sb, 1)) {
 		printk(KERN_ERR "VFS: Busy inodes after unmount. "
 			"Self-destruct in 5 seconds.  Have a nice day...\n");
 	}
--- linux-2.4.20/include/linux/fs.h~invalidate_show	2003-04-08 23:34:36.000000000 -0600
+++ linux-2.4.20-braam/include/linux/fs.h	2003-04-08 23:34:36.000000000 -0600
@@ -1237,7 +1237,7 @@ static inline void mark_buffer_dirty_ino
 extern void set_buffer_flushtime(struct buffer_head *);
 extern void balance_dirty(void);
 extern int check_disk_change(kdev_t);
-extern int invalidate_inodes(struct super_block *);
+extern int invalidate_inodes(struct super_block *, int);
 extern int invalidate_device(kdev_t, int);
 extern void invalidate_inode_pages(struct inode *);
 extern void invalidate_inode_pages2(struct address_space *);

_
 fs/Makefile     |    4 +++-
 fs/inode.c      |    4 +++-
 mm/Makefile     |    2 +-
 mm/page_alloc.c |    1 +
 mm/vmscan.c     |    3 +++
 5 files changed, 11 insertions(+), 3 deletions(-)

--- linux-2.4.18-18/fs/inode.c~iod-rmap-exports	Thu Apr  3 00:40:01 2003
+++ linux-2.4.18-18-braam/fs/inode.c	Thu Apr  3 00:40:01 2003
@@ -5,6 +5,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/string.h>
 #include <linux/mm.h>
@@ -66,7 +67,8 @@ static LIST_HEAD(anon_hash_chain); /* fo
  * NOTE! You also have to own the lock if you change
  * the i_state of an inode while it is in use..
  */
-static spinlock_t inode_lock = SPIN_LOCK_UNLOCKED;
+spinlock_t inode_lock = SPIN_LOCK_UNLOCKED;
+EXPORT_SYMBOL(inode_lock);
 
 /*
  * Statistics gathering..
--- linux-2.4.18-18/fs/Makefile~iod-rmap-exports	Thu Apr  3 00:40:01 2003
+++ linux-2.4.18-18-braam/fs/Makefile	Thu Apr  3 00:40:29 2003
@@ -1,3 +1,5 @@
+
+
 #
 # Makefile for the Linux filesystems.
 #
@@ -7,7 +9,7 @@
 
 O_TARGET := fs.o
 
-export-objs :=	filesystems.o open.o dcache.o buffer.o
+export-objs :=	filesystems.o open.o dcache.o buffer.o inode.o
 mod-subdirs :=	nls
 
 obj-y :=	open.o read_write.o devices.o file_table.o buffer.o \
--- linux-2.4.18-18/mm/vmscan.c~iod-rmap-exports	Thu Apr  3 00:40:01 2003
+++ linux-2.4.18-18-braam/mm/vmscan.c	Thu Apr  3 00:40:01 2003
@@ -14,6 +14,8 @@
  *  Multiqueue VM started 5.8.00, Rik van Riel.
  */
 
+#include <linux/config.h>
+#include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/kernel_stat.h>
 #include <linux/swap.h>
@@ -837,6 +839,7 @@ void wakeup_kswapd(unsigned int gfp_mask
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&kswapd_done, &wait);
 }
+EXPORT_SYMBOL(wakeup_kswapd);
 
 static void wakeup_memwaiters(void)
 {
--- linux-2.4.18-18/mm/Makefile~iod-rmap-exports	Thu Apr  3 00:40:01 2003
+++ linux-2.4.18-18-braam/mm/Makefile	Thu Apr  3 00:40:01 2003
@@ -9,7 +9,7 @@
 
 O_TARGET := mm.o
 
-export-objs := shmem.o filemap.o memory.o page_alloc.o mempool.o
+export-objs := shmem.o filemap.o memory.o page_alloc.o mempool.o vmscan.o
 
 obj-y	 := memory.o mmap.o filemap.o mprotect.o mlock.o mremap.o \
 	    vmalloc.o slab.o bootmem.o swap.o vmscan.o page_io.o \
--- linux-2.4.18-18/mm/page_alloc.c~iod-rmap-exports	Thu Apr  3 00:40:01 2003
+++ linux-2.4.18-18-braam/mm/page_alloc.c	Thu Apr  3 00:40:01 2003
@@ -31,6 +31,7 @@ int nr_active_pages;
 int nr_inactive_dirty_pages;
 int nr_inactive_clean_pages;
 pg_data_t *pgdat_list;
+EXPORT_SYMBOL(pgdat_list);
 
 /*
  * The zone_table array is used to look up the address of the

_
 include/linux/mm.h |    1 +
 mm/filemap.c       |    3 ++-
 2 files changed, 3 insertions(+), 1 deletion(-)

--- linux-2.4.18-18/include/linux/mm.h~export-truncate	2003-04-05 02:54:55.000000000 -0700
+++ linux-2.4.18-18-braam/include/linux/mm.h	2003-04-09 17:37:46.000000000 -0600
@@ -650,6 +650,7 @@ struct zone_t;
 /* filemap.c */
 extern void remove_inode_page(struct page *);
 extern unsigned long page_unuse(struct page *);
+extern void truncate_complete_page(struct page *);
 extern void truncate_inode_pages(struct address_space *, loff_t);
 
 /* generic vm_area_ops exported for stackable file systems */
--- linux-2.4.18-18/mm/filemap.c~export-truncate	2003-04-05 02:54:55.000000000 -0700
+++ linux-2.4.18-18-braam/mm/filemap.c	2003-04-09 17:37:46.000000000 -0600
@@ -245,7 +245,7 @@ static inline void truncate_partial_page
 		do_flushpage(page, partial);
 }
 
-static void truncate_complete_page(struct page *page)
+void truncate_complete_page(struct page *page)
 {
 	/*
 	 * Leave it on the LRU if it gets converted into anonymous buffers
@@ -266,6 +266,7 @@ static void truncate_complete_page(struc
 	remove_inode_page(page);
 	page_cache_release(page);
 }
+EXPORT_SYMBOL_GPL(truncate_complete_page);
 
 static int FASTCALL(truncate_list_pages(struct list_head *, unsigned long, unsigned *));
 static int truncate_list_pages(struct list_head *head, unsigned long start, unsigned *partial)

_
--- ./fs/ext3/super.c	2002/03/05 06:18:59	2.1
+++ ./fs/ext3/super.c	2002/03/05 06:26:56
@@ -529,6 +529,12 @@
 				       "EXT3 Check option not supported\n");
 #endif
 		}
+		else if (!strcmp (this_char, "index"))
+#ifdef CONFIG_EXT3_INDEX
+			set_opt (*mount_options, INDEX);
+#else
+			printk("EXT3 index option not supported\n");
+#endif
 		else if (!strcmp (this_char, "debug"))
 			set_opt (*mount_options, DEBUG);
 		else if (!strcmp (this_char, "errors")) {
@@ -702,6 +708,12 @@
 	es->s_mtime = cpu_to_le32(CURRENT_TIME);
 	ext3_update_dynamic_rev(sb);
 	EXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);
+
+	if (test_opt(sb, INDEX))
+		EXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX);
+	else if (EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))
+		set_opt (EXT3_SB(sb)->s_mount_opt, INDEX);
+
 	ext3_commit_super (sb, es, 1);
 	if (test_opt (sb, DEBUG))
 		printk (KERN_INFO
--- ./fs/ext3/namei.c	2002/03/05 06:18:59	2.1
+++ ./fs/ext3/namei.c	2002/03/06 00:13:18
@@ -16,6 +16,10 @@
  *        David S. Miller (davem@caip.rutgers.edu), 1995
  *  Directory entry file type support and forward compatibility hooks
  *  	for B-tree directories by Theodore Ts'o (tytso@mit.edu), 1998
+ *  Hash Tree Directory indexing (c)
+ *  	Daniel Phillips, 2001
+ *  Hash Tree Directory indexing porting
+ *  	Christopher Li, 2002
  */
 
 #include <linux/fs.h>
@@ -33,7 +33,7 @@
 #include <linux/string.h>
 #include <linux/locks.h>
 #include <linux/quotaops.h>
-
+#include <linux/slab.h>
 
 /*
  * define how far ahead to read directories while searching them.
@@ -38,6 +42,437 @@
 #define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)
 #define NAMEI_RA_INDEX(c,b)  (((c) * NAMEI_RA_BLOCKS) + (b))
 
+static struct buffer_head *ext3_append(handle_t *handle,
+					struct inode *inode,
+					u32 *block, int *err)
+{
+	struct buffer_head *bh;
+
+	*block = inode->i_size >> inode->i_sb->s_blocksize_bits;
+
+	if ((bh = ext3_bread(handle, inode, *block, 1, err))) {
+		inode->i_size += inode->i_sb->s_blocksize;
+		EXT3_I(inode)->i_disksize = inode->i_size;
+		ext3_journal_get_write_access(handle,bh);
+	}
+	return bh;
+}
+
+#ifndef assert
+#define assert(test) J_ASSERT(test)
+#endif
+
+#ifndef swap
+#define swap(x, y) do { typeof(x) z = x; x = y; y = z; } while (0)
+#endif
+
+typedef struct { u32 v; } le_u32;
+typedef struct { u16 v; } le_u16;
+
+#define dxtrace_on(command) command
+#define dxtrace_off(command)
+
+struct fake_dirent
+{
+	/*le*/u32 inode;
+	/*le*/u16 rec_len;
+	u8 name_len;
+	u8 file_type;
+};
+
+struct dx_countlimit
+{
+	le_u16 limit;
+	le_u16 count;
+};
+
+struct dx_entry
+{
+	le_u32 hash;
+	le_u32 block;
+};
+
+/*
+ * dx_root_info is laid out so that if it should somehow get overlaid by a
+ * dirent the two low bits of the hash version will be zero.  Therefore, the
+ * hash version mod 4 should never be 0.  Sincerely, the paranoia department.
+ */
+
+struct dx_root
+{
+	struct fake_dirent dot;
+	char dot_name[4];
+	struct fake_dirent dotdot;
+	char dotdot_name[4];
+	struct dx_root_info
+	{
+		le_u32 reserved_zero;
+		u8 hash_version; /* 0 now, 1 at release */
+		u8 info_length; /* 8 */
+		u8 indirect_levels;
+		u8 unused_flags;
+	}
+	info;
+	struct dx_entry	entries[0];
+};
+
+struct dx_node
+{
+	struct fake_dirent fake;
+	struct dx_entry	entries[0];
+};
+
+
+struct dx_frame
+{
+	struct buffer_head *bh;
+	struct dx_entry *entries;
+	struct dx_entry *at;
+};
+
+struct dx_map_entry
+{
+	u32 hash;
+	u32 offs;
+};
+
+typedef struct ext3_dir_entry_2 ext3_dirent;
+static inline unsigned dx_get_block (struct dx_entry *entry);
+static void dx_set_block (struct dx_entry *entry, unsigned value);
+static inline unsigned dx_get_hash (struct dx_entry *entry);
+static void dx_set_hash (struct dx_entry *entry, unsigned value);
+static unsigned dx_get_count (struct dx_entry *entries);
+static unsigned dx_get_limit (struct dx_entry *entries);
+static void dx_set_count (struct dx_entry *entries, unsigned value);
+static void dx_set_limit (struct dx_entry *entries, unsigned value);
+static unsigned dx_root_limit (struct inode *dir, unsigned infosize);
+static unsigned dx_node_limit (struct inode *dir);
+static unsigned dx_hack_hash (const u8 *name, int len);
+static struct dx_frame *dx_probe (struct inode *dir, u32 hash, struct dx_frame *frame);
+static void dx_release (struct dx_frame *frames);
+static int dx_make_map (ext3_dirent *de, int size, struct dx_map_entry map[]);
+static void dx_sort_map(struct dx_map_entry *map, unsigned count);
+static ext3_dirent *dx_copy_dirents (char *from, char *to,
+     struct dx_map_entry *map, int count);
+static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);
+
+
+#ifdef CONFIG_EXT3_INDEX
+/*
+ * Future: use high four bits of block for coalesce-on-delete flags
+ * Mask them off for now.
+ */
+
+static inline unsigned dx_get_block (struct dx_entry *entry)
+{
+	return le32_to_cpu(entry->block.v) & 0x00ffffff;
+}
+
+static inline void dx_set_block (struct dx_entry *entry, unsigned value)
+{
+	entry->block.v = cpu_to_le32(value);
+}
+
+static inline unsigned dx_get_hash (struct dx_entry *entry)
+{
+	return le32_to_cpu(entry->hash.v);
+}
+
+static inline void dx_set_hash (struct dx_entry *entry, unsigned value)
+{
+	entry->hash.v = cpu_to_le32(value);
+}
+
+static inline unsigned dx_get_count (struct dx_entry *entries)
+{
+	return le16_to_cpu(((struct dx_countlimit *) entries)->count.v);
+}
+
+static inline unsigned dx_get_limit (struct dx_entry *entries)
+{
+	return le16_to_cpu(((struct dx_countlimit *) entries)->limit.v);
+}
+
+static inline void dx_set_count (struct dx_entry *entries, unsigned value)
+{
+	((struct dx_countlimit *) entries)->count.v = cpu_to_le16(value);
+}
+
+static inline void dx_set_limit (struct dx_entry *entries, unsigned value)
+{
+	((struct dx_countlimit *) entries)->limit.v = cpu_to_le16(value);
+}
+
+static inline unsigned dx_root_limit (struct inode *dir, unsigned infosize)
+{
+	unsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(1) -
+		EXT3_DIR_REC_LEN(2) - infosize;
+	return 0? 20: entry_space / sizeof(struct dx_entry);
+}
+
+static inline unsigned dx_node_limit (struct inode *dir)
+{
+	unsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(0);
+	return 0? 22: entry_space / sizeof(struct dx_entry);
+}
+
+/* Hash function - not bad, but still looking for an ideal default */
+
+static unsigned dx_hack_hash (const u8 *name, int len)
+{
+	u32 hash0 = 0x12a3fe2d, hash1 = 0x37abe8f9;
+	while (len--)
+	{
+		u32 hash = hash1 + (hash0 ^ (*name++ * 7152373));
+		if (hash & 0x80000000) hash -= 0x7fffffff;
+		hash1 = hash0;
+		hash0 = hash;
+	}
+	return hash0;
+}
+
+#define dx_hash(s,n) (dx_hack_hash(s,n) << 1)
+
+/*
+ * Debug
+ */
+#ifdef DX_DEBUG
+#define dxtrace dxtrace_on
+static void dx_show_index (char * label, struct dx_entry *entries)
+{
+	int i, n = dx_get_count (entries);
+	printk("%s index ", label);
+	for (i = 0; i < n; i++)
+	{
+		printk("%x->%u ", i? dx_get_hash(entries + i): 0, dx_get_block(entries + i));
+	}
+	printk("\n");
+}
+
+struct stats
+{ 
+	unsigned names;
+	unsigned space;
+	unsigned bcount;
+};
+
+static struct stats dx_show_leaf (ext3_dirent *de, int size, int show_names)
+{
+	unsigned names = 0, space = 0;
+	char *base = (char *) de;
+	printk("names: ");
+	while ((char *) de < base + size)
+	{
+		if (de->inode)
+		{
+			if (show_names)
+			{
+				int len = de->name_len;
+				char *name = de->name;
+				while (len--) printk("%c", *name++);
+				printk(":%x.%u ", dx_hash (de->name, de->name_len), ((char *) de - base));
+			}
+			space += EXT3_DIR_REC_LEN(de->name_len);
+	 		names++;
+		}
+		de = (ext3_dirent *) ((char *) de + le16_to_cpu(de->rec_len));
+	}
+	printk("(%i)\n", names);
+	return (struct stats) { names, space, 1 };
+}
+
+struct stats dx_show_entries (struct inode *dir, struct dx_entry *entries, int levels)
+{
+	unsigned blocksize = dir->i_sb->s_blocksize;
+	unsigned count = dx_get_count (entries), names = 0, space = 0, i;
+	unsigned bcount = 0;
+	struct buffer_head *bh;
+	int err;
+	printk("%i indexed blocks...\n", count);
+	for (i = 0; i < count; i++, entries++)
+	{
+		u32 block = dx_get_block(entries), hash = i? dx_get_hash(entries): 0;
+		u32 range = i < count - 1? (dx_get_hash(entries + 1) - hash): ~hash;
+		struct stats stats;
+		printk("%s%3u:%03u hash %8x/%8x ",levels?"":"   ", i, block, hash, range);
+		if (!(bh = ext3_bread (NULL,dir, block, 0,&err))) continue;
+		stats = levels?
+		   dx_show_entries (dir, ((struct dx_node *) bh->b_data)->entries, levels - 1):
+		   dx_show_leaf ((ext3_dirent *) bh->b_data, blocksize, 0);
+		names += stats.names;
+		space += stats.space;
+		bcount += stats.bcount;
+		brelse (bh);
+	}
+	if (bcount)
+		printk("%snames %u, fullness %u (%u%%)\n", levels?"":"   ",
+			names, space/bcount,(space/bcount)*100/blocksize);
+	return (struct stats) { names, space, bcount};
+}
+#else
+#define dxtrace dxtrace_off
+#endif
+
+/*
+ * Probe for a directory leaf block to search
+ */
+
+static struct dx_frame *
+dx_probe(struct inode *dir, u32 hash, struct dx_frame *frame_in)
+{
+	unsigned count, indirect;
+	struct dx_entry *at, *entries, *p, *q, *m;
+	struct dx_root *root;
+	struct buffer_head *bh;
+	struct dx_frame *frame = frame_in;
+	int err;
+
+	frame->bh = NULL;
+	if (!(bh = ext3_bread(NULL, dir, 0, 0, &err)))
+		goto fail;
+	root = (struct dx_root *) bh->b_data;
+	if (root->info.hash_version > 0 || root->info.unused_flags & 1) {
+		brelse(bh);
+		goto fail;
+	}
+	if ((indirect = root->info.indirect_levels) > 1) {
+		brelse(bh);
+		goto fail;
+	}
+	entries = (struct dx_entry *) (((char *) &root->info) + root->info.info_length);
+	assert (dx_get_limit(entries) == dx_root_limit(dir, root->info.info_length));
+	dxtrace (printk("Look up %x", hash));
+	while (1)
+	{
+		count = dx_get_count(entries);
+		assert (count && count <= dx_get_limit(entries));
+		p = entries + 1;
+		q = entries + count - 1;
+		while (p <= q)
+		{
+			m = p + (q - p)/2;
+			dxtrace(printk("."));
+			if (dx_get_hash(m) > hash)
+				q = m - 1;
+			else
+				p = m + 1;
+		}
+
+		if (0) // linear search cross check
+		{
+			unsigned n = count - 1;
+			at = entries;
+			while (n--)
+			{
+				dxtrace(printk(","));
+				if (dx_get_hash(++at) > hash)
+				{
+					at--;
+					break;
+				}
+			}
+			assert (at == p - 1);
+		}
+
+		at = p - 1;
+		dxtrace(printk(" %x->%u\n", at == entries? 0: dx_get_hash(at), dx_get_block(at)));
+		frame->bh = bh;
+		frame->entries = entries;
+		frame->at = at;
+		if (!indirect--) return frame;
+		if (!(bh = ext3_bread (NULL,dir, dx_get_block(at), 0,&err)))
+			goto fail2;
+		at = entries = ((struct dx_node *) bh->b_data)->entries;
+		assert (dx_get_limit(entries) == dx_node_limit (dir));
+		frame++;
+	}
+fail2:
+	while (frame >= frame_in) {
+		brelse(frame->bh);
+		frame--;
+	}
+fail:
+	return NULL;
+}
+
+static void dx_release (struct dx_frame *frames)
+{
+	if (frames[0].bh == NULL)
+		return;
+
+	if (((struct dx_root *)frames[0].bh->b_data)->info.indirect_levels)
+		brelse (frames[1].bh);
+	brelse (frames[0].bh);
+}
+
+/*
+ * Directory block splitting, compacting
+ */
+
+static int dx_make_map (ext3_dirent *de, int size, struct dx_map_entry map[])
+{
+	int count = 0;
+	char *base = (char *) de;
+	while ((char *) de < base + size) {
+		if (de->name_len && de->inode) {
+			map[count].hash = dx_hash (de->name, de->name_len);
+			map[count].offs = (u32) ((char *) de - base);
+			count++;
+		}
+		de = (ext3_dirent *) ((char *) de + le16_to_cpu(de->rec_len));
+	}
+	return count;
+}
+
+static void dx_sort_map (struct dx_map_entry *map, unsigned count)
+{
+        struct dx_map_entry *p, *q, *top = map + count - 1;
+        int more;
+        /* Combsort until bubble sort doesn't suck */
+        while (count > 2)
+	{
+                count = count*10/13;
+                if (count - 9 < 2) /* 9, 10 -> 11 */
+                        count = 11;
+                for (p = top, q = p - count; q >= map; p--, q--)
+                        if (p->hash < q->hash)
+                                swap(*p, *q);
+        }
+        /* Garden variety bubble sort */
+        do {
+                more = 0;
+                q = top;
+                while (q-- > map)
+		{
+                        if (q[1].hash >= q[0].hash)
+				continue;
+                        swap(*(q+1), *q);
+                        more = 1;
+		}
+	} while(more);
+}
+
+static void dx_insert_block(struct dx_frame *frame, u32 hash, u32 block)
+{
+	struct dx_entry *entries = frame->entries;
+	struct dx_entry *old = frame->at, *new = old + 1;
+	int count = dx_get_count(entries);
+
+	assert(count < dx_get_limit(entries));
+	assert(old < entries + count);
+	memmove(new + 1, new, (char *)(entries + count) - (char *)(new));
+	dx_set_hash(new, hash);
+	dx_set_block(new, block);
+	dx_set_count(entries, count + 1);
+}
+#endif
+
+static void ext3_update_dx_flag(struct inode *inode)
+{
+	if (!test_opt(inode->i_sb, INDEX))
+		EXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;
+}
+
 /*
  * NOTE! unlike strncmp, ext3_match returns 1 for success, 0 for failure.
  *
@@ -95,6 +529,15 @@
 }
 
 /*
+ * p is at least 6 bytes before the end of page
+ */
+static inline ext3_dirent *ext3_next_entry(ext3_dirent *p)
+{
+	return (ext3_dirent *)((char*)p + le16_to_cpu(p->rec_len));
+}
+
+
+/*
  *	ext3_find_entry()
  *
  * finds an entry in the specified directory with the wanted name. It
@@ -105,6 +548,8 @@
  * The returned buffer_head has ->b_count elevated.  The caller is expected
  * to brelse() it when appropriate.
  */
+
+	
 static struct buffer_head * ext3_find_entry (struct dentry *dentry,
 					struct ext3_dir_entry_2 ** res_dir)
 {
@@ -119,10 +564,70 @@
 	int num = 0;
 	int nblocks, i, err;
 	struct inode *dir = dentry->d_parent->d_inode;
+	ext3_dirent *de, *top;
 
 	*res_dir = NULL;
 	sb = dir->i_sb;
+	if (dentry->d_name.len > EXT3_NAME_LEN)
+		return NULL;
+	if (ext3_dx && is_dx(dir)) {
+		u32 hash = dx_hash(dentry->d_name.name, dentry->d_name.len);
+		struct dx_frame frames[2], *frame;
+		if (!(frame = dx_probe (dir, hash, frames)))
+			return NULL;
+dxnext:
+		block = dx_get_block(frame->at);
+		if (!(bh = ext3_bread (NULL,dir, block, 0, &err)))
+			goto dxfail;
+		de = (ext3_dirent *) bh->b_data;
+		top = (ext3_dirent *) ((char *) de + sb->s_blocksize -
+				EXT3_DIR_REC_LEN(0));
+		for (; de < top; de = ext3_next_entry(de))
+			if (ext3_match(dentry->d_name.len, dentry->d_name.name, de)) {
+				if (!ext3_check_dir_entry("ext3_find_entry",
+					  dir, de, bh,
+					  (block<<EXT3_BLOCK_SIZE_BITS(sb))
+					   +((char *)de - bh->b_data))) {
+					brelse (bh);
+					goto dxfail;
+				}
+				*res_dir = de;
+				goto dxfound;
+			}
+		brelse (bh);
+		/* Same hash continues in next block?  Search on. */
+		if (++(frame->at) == frame->entries + dx_get_count(frame->entries))
+		{
+			struct buffer_head *bh2;
+			if (frame == frames)
+				goto dxfail;
+			if (++(frames->at) == frames->entries + dx_get_count(frames->entries))
+				goto dxfail;
+			/* should omit read if not continued */
+			if (!(bh2 = ext3_bread (NULL, dir,
+						dx_get_block(frames->at),
+						0, &err)))
+				goto dxfail;
+			brelse (frame->bh);
+			frame->bh = bh2;
+			frame->at = frame->entries = ((struct dx_node *) bh2->b_data)->entries;
+			/* Subtle: the 0th entry has the count, find the hash in frame above */
+			if ((dx_get_hash(frames->at) & -2) == hash)
+				goto dxnext;
+			goto dxfail;
+		}
+		if ((dx_get_hash(frame->at) & -2) == hash)
+			goto dxnext;
+dxfail:
+		dxtrace(printk("%s not found\n", name));
+		dx_release (frames);
+		return NULL;
+dxfound:
+		dx_release (frames);
+		return bh;
 
+	}
+	
 	nblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);
 	start = dir->u.ext3_i.i_dir_start_lookup;
 	if (start >= nblocks)
@@ -237,6 +748,90 @@
 		de->file_type = ext3_type_by_mode[(mode & S_IFMT)>>S_SHIFT];
 }
 
+static ext3_dirent *
+dx_copy_dirents (char *from, char *to, struct dx_map_entry *map, int count)
+{
+	unsigned rec_len = 0;
+
+	while (count--) {
+		ext3_dirent *de = (ext3_dirent *) (from + map->offs);
+		rec_len = EXT3_DIR_REC_LEN(de->name_len);
+		memcpy (to, de, rec_len);
+		((ext3_dirent *) to)->rec_len = rec_len;
+		to += rec_len;
+		map++;
+	}
+	return (ext3_dirent *) (to - rec_len);
+}
+
+#ifdef CONFIG_EXT3_INDEX
+static ext3_dirent *do_split(handle_t *handle, struct inode *dir,
+			struct buffer_head **bh,struct dx_frame *frame,
+			u32 hash, int *error)
+{
+	unsigned count;
+	struct buffer_head *bh2;
+	u32 newblock;
+	u32 hash2;
+	struct dx_map_entry *map;
+	char *data1 = (*bh)->b_data, *data2, *data3;
+	unsigned split;
+	ext3_dirent *de, *de2;
+
+	bh2 = ext3_append (handle, dir, &newblock, error);
+	if (!(bh2))
+	{
+		brelse(*bh);
+		*bh = NULL;
+		return (ext3_dirent *)bh2;
+	}
+
+	BUFFER_TRACE(*bh, "get_write_access");
+	ext3_journal_get_write_access(handle, *bh);
+	BUFFER_TRACE(frame->bh, "get_write_access");
+	ext3_journal_get_write_access(handle, frame->bh);
+
+	data2 = bh2->b_data;
+
+	map = kmalloc(sizeof(*map) * PAGE_CACHE_SIZE/EXT3_DIR_REC_LEN(1) + 1,
+		      GFP_KERNEL);
+	if (!map)
+		panic("no memory for do_split\n");
+	count = dx_make_map((ext3_dirent *)data1, dir->i_sb->s_blocksize, map);
+	split = count/2; // need to adjust to actual middle
+	dx_sort_map (map, count);
+	hash2 = map[split].hash;
+	dxtrace(printk("Split block %i at %x, %i/%i\n",
+		dx_get_block(frame->at), hash2, split, count-split));
+
+	/* Fancy dance to stay within two buffers */
+	de2 = dx_copy_dirents (data1, data2, map + split, count - split);
+	data3 = (char *) de2 + de2->rec_len;
+	de = dx_copy_dirents (data1, data3, map, split);
+	memcpy(data1, data3, (char *) de + de->rec_len - data3);
+	de = (ext3_dirent *) ((char *) de - data3 + data1); // relocate de
+	de->rec_len = cpu_to_le16(data1 + dir->i_sb->s_blocksize - (char *)de);
+	de2->rec_len = cpu_to_le16(data2 + dir->i_sb->s_blocksize-(char *)de2);
+	dxtrace(dx_show_leaf((ext3_dirent *)data1, dir->i_sb->s_blocksize, 1));
+	dxtrace(dx_show_leaf((ext3_dirent *)data2, dir->i_sb->s_blocksize, 1));
+
+	/* Which block gets the new entry? */
+	if (hash >= hash2)
+	{
+		swap(*bh, bh2);
+		de = de2;
+	}
+	dx_insert_block(frame, hash2 + (hash2 == map[split-1].hash), newblock);
+	ext3_journal_dirty_metadata (handle, bh2);
+	brelse (bh2);
+	ext3_journal_dirty_metadata (handle, frame->bh);
+	dxtrace(dx_show_index ("frame", frame->entries));
+	kfree(map);
+	return de;
+}
+#endif
+
+
 /*
  *	ext3_add_entry()
  *
@@ -255,118 +849,278 @@
 	struct inode *inode)
 {
 	struct inode *dir = dentry->d_parent->d_inode;
-	const char *name = dentry->d_name.name;
-	int namelen = dentry->d_name.len;
 	unsigned long offset;
-	unsigned short rec_len;
 	struct buffer_head * bh;
-	struct ext3_dir_entry_2 * de, * de1;
-	struct super_block * sb;
+	ext3_dirent *de;
+	struct super_block * sb = dir->i_sb;
 	int	retval;
+	unsigned short reclen = EXT3_DIR_REC_LEN(dentry->d_name.len);
 
-	sb = dir->i_sb;
+	unsigned nlen, rlen;
+	u32 block, blocks;
+	char *top;
 
-	if (!namelen)
+	if (!dentry->d_name.len)
 		return -EINVAL;
-	bh = ext3_bread (handle, dir, 0, 0, &retval);
-	if (!bh)
-		return retval;
-	rec_len = EXT3_DIR_REC_LEN(namelen);
-	offset = 0;
-	de = (struct ext3_dir_entry_2 *) bh->b_data;
-	while (1) {
-		if ((char *)de >= sb->s_blocksize + bh->b_data) {
-			brelse (bh);
-			bh = NULL;
-			bh = ext3_bread (handle, dir,
-				offset >> EXT3_BLOCK_SIZE_BITS(sb), 1, &retval);
-			if (!bh)
-				return retval;
-			if (dir->i_size <= offset) {
-				if (dir->i_size == 0) {
-					brelse(bh);
-					return -ENOENT;
+	if (ext3_dx && is_dx(dir)) {
+		struct dx_frame frames[2], *frame;
+		struct dx_entry *entries, *at;
+		u32 hash;
+		char *data1;
+
+		hash = dx_hash(dentry->d_name.name, dentry->d_name.len);
+		/* FIXME: do something if dx_probe() fails here */
+		frame = dx_probe(dir, hash, frames);
+		entries = frame->entries;
+		at = frame->at;
+
+		if (!(bh = ext3_bread(handle,dir, dx_get_block(at), 0,&retval)))
+			goto dxfail1;
+
+		BUFFER_TRACE(bh, "get_write_access");
+		ext3_journal_get_write_access(handle, bh);
+
+		data1 = bh->b_data;
+		de = (ext3_dirent *) data1;
+		top = data1 + (0? 200: sb->s_blocksize);
+		while ((char *) de < top)
+		{
+			/* FIXME: check EEXIST and dir */
+			nlen = EXT3_DIR_REC_LEN(de->name_len);
+			rlen = le16_to_cpu(de->rec_len);
+			if ((de->inode? rlen - nlen: rlen) >= reclen)
+				goto dx_add;
+			de = (ext3_dirent *) ((char *) de + rlen);
+		}
+		/* Block full, should compress but for now just split */
+		dxtrace(printk("using %u of %u node entries\n",
+			dx_get_count(entries), dx_get_limit(entries)));
+		/* Need to split index? */
+		if (dx_get_count(entries) == dx_get_limit(entries))
+		{
+			u32 newblock;
+			unsigned icount = dx_get_count(entries);
+			int levels = frame - frames;
+			struct dx_entry *entries2;
+			struct dx_node *node2;
+			struct buffer_head *bh2;
+			if (levels && dx_get_count(frames->entries) == dx_get_limit(frames->entries))
+				goto dxfull;
+			bh2 = ext3_append (handle, dir, &newblock, &retval);
+			if (!(bh2))
+				goto dxfail2;
+			node2 = (struct dx_node *)(bh2->b_data);
+			entries2 = node2->entries;
+			node2->fake.rec_len = cpu_to_le16(sb->s_blocksize);
+			node2->fake.inode = 0;
+			BUFFER_TRACE(frame->bh, "get_write_access");
+			ext3_journal_get_write_access(handle, frame->bh);
+			if (levels)
+			{
+				unsigned icount1 = icount/2, icount2 = icount - icount1;
+				unsigned hash2 = dx_get_hash(entries + icount1);
+				dxtrace(printk("Split index %i/%i\n", icount1, icount2));
+				
+				BUFFER_TRACE(frame->bh, "get_write_access"); /* index root */
+				ext3_journal_get_write_access(handle, frames[0].bh);
+				
+				memcpy ((char *) entries2, (char *) (entries + icount1),
+					icount2 * sizeof(struct dx_entry));
+				dx_set_count (entries, icount1);
+				dx_set_count (entries2, icount2);
+				dx_set_limit (entries2, dx_node_limit(dir));
+
+				/* Which index block gets the new entry? */
+				if (at - entries >= icount1) {
+					frame->at = at = at - entries - icount1 + entries2;
+					frame->entries = entries = entries2;
+					swap(frame->bh, bh2);
 				}
-
-				ext3_debug ("creating next block\n");
-
-				BUFFER_TRACE(bh, "get_write_access");
-				ext3_journal_get_write_access(handle, bh);
-				de = (struct ext3_dir_entry_2 *) bh->b_data;
-				de->inode = 0;
-				de->rec_len = le16_to_cpu(sb->s_blocksize);
-				dir->u.ext3_i.i_disksize =
-					dir->i_size = offset + sb->s_blocksize;
-				dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
-				ext3_mark_inode_dirty(handle, dir);
+				dx_insert_block (frames + 0, hash2, newblock);
+				dxtrace(dx_show_index ("node", frames[1].entries));
+				dxtrace(dx_show_index ("node",
+					((struct dx_node *) bh2->b_data)->entries));
+				ext3_journal_dirty_metadata(handle, bh2);
+				brelse (bh2);
 			} else {
-
-				ext3_debug ("skipping to next block\n");
-
-				de = (struct ext3_dir_entry_2 *) bh->b_data;
+				dxtrace(printk("Creating second level index...\n"));
+				memcpy((char *) entries2, (char *) entries,
+					icount * sizeof(struct dx_entry));
+				dx_set_limit(entries2, dx_node_limit(dir));
+
+				/* Set up root */
+				dx_set_count(entries, 1);
+				dx_set_block(entries + 0, newblock);
+				((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels = 1;
+
+				/* Add new access path frame */
+				frame = frames + 1;
+				frame->at = at = at - entries + entries2;
+				frame->entries = entries = entries2;
+				frame->bh = bh2;
+				ext3_journal_get_write_access(handle, frame->bh);
 			}
+			ext3_journal_dirty_metadata(handle, frames[0].bh);
 		}
-		if (!ext3_check_dir_entry ("ext3_add_entry", dir, de, bh,
-					   offset)) {
-			brelse (bh);
-			return -ENOENT;
-		}
-		if (ext3_match (namelen, name, de)) {
+		de = do_split(handle, dir, &bh, frame, hash, &retval);
+		dx_release (frames);
+		if (!(de))
+			goto fail;
+		nlen = EXT3_DIR_REC_LEN(de->name_len);
+		rlen = le16_to_cpu(de->rec_len);
+		goto add;
+
+dx_add:
+		dx_release (frames);
+		goto add;
+
+dxfull:
+		ext3_warning(sb, __FUNCTION__, "Directory index full!\n");
+		retval = -ENOSPC;
+dxfail2:
+		brelse(bh);
+dxfail1:
+		dx_release (frames);
+		goto fail1;
+	}
+
+	blocks = dir->i_size >> sb->s_blocksize_bits;
+	for (block = 0, offset = 0; block < blocks; block++) {
+		bh = ext3_bread(handle, dir, block, 0, &retval);
+		if(!bh)
+			return retval;
+		de = (ext3_dirent *)bh->b_data;
+		top = bh->b_data + sb->s_blocksize - reclen;
+		while ((char *) de <= top) {
+			if (!ext3_check_dir_entry("ext3_add_entry", dir, de,
+						  bh, offset)) {
+				brelse (bh);
+				return -EIO;
+			}
+			if (ext3_match(dentry->d_name.len,dentry->d_name.name,de)) {
 				brelse (bh);
 				return -EEXIST;
-		}
-		if ((le32_to_cpu(de->inode) == 0 &&
-				le16_to_cpu(de->rec_len) >= rec_len) ||
-		    (le16_to_cpu(de->rec_len) >=
-				EXT3_DIR_REC_LEN(de->name_len) + rec_len)) {
-			BUFFER_TRACE(bh, "get_write_access");
-			ext3_journal_get_write_access(handle, bh);
-			/* By now the buffer is marked for journaling */
-			offset += le16_to_cpu(de->rec_len);
-			if (le32_to_cpu(de->inode)) {
-				de1 = (struct ext3_dir_entry_2 *) ((char *) de +
-					EXT3_DIR_REC_LEN(de->name_len));
-				de1->rec_len =
-					cpu_to_le16(le16_to_cpu(de->rec_len) -
-					EXT3_DIR_REC_LEN(de->name_len));
-				de->rec_len = cpu_to_le16(
-						EXT3_DIR_REC_LEN(de->name_len));
-				de = de1;
 			}
-			de->file_type = EXT3_FT_UNKNOWN;
-			if (inode) {
-				de->inode = cpu_to_le32(inode->i_ino);
-				ext3_set_de_type(dir->i_sb, de, inode->i_mode);
-			} else
-				de->inode = 0;
-			de->name_len = namelen;
-			memcpy (de->name, name, namelen);
-			/*
-			 * XXX shouldn't update any times until successful
-			 * completion of syscall, but too many callers depend
-			 * on this.
-			 *
-			 * XXX similarly, too many callers depend on
-			 * ext3_new_inode() setting the times, but error
-			 * recovery deletes the inode, so the worst that can
-			 * happen is that the times are slightly out of date
-			 * and/or different from the directory change time.
-			 */
-			dir->i_mtime = dir->i_ctime = CURRENT_TIME;
-			dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
-			dir->i_version = ++event;
-			ext3_mark_inode_dirty(handle, dir);
-			BUFFER_TRACE(bh, "call ext3_journal_dirty_metadata");
-			ext3_journal_dirty_metadata(handle, bh);
+			nlen = EXT3_DIR_REC_LEN(de->name_len);
+			rlen = le16_to_cpu(de->rec_len);
+			if ((de->inode ? rlen - nlen: rlen) >= reclen)
+				goto add;
+			de = (ext3_dirent *)((char *)de + rlen);
+			offset += rlen;
+		}
+		if (ext3_dx && blocks == 1 && test_opt(sb, INDEX))
+			goto dx_make_index;
+		brelse(bh);
+	}
+	bh = ext3_append(handle, dir, &block, &retval);
+	if (!bh)
+		return retval;
+	de = (ext3_dirent *) bh->b_data;
+	de->inode = 0;
+	de->rec_len = cpu_to_le16(rlen = sb->s_blocksize);
+	nlen = 0;
+	goto add;
+
+add:
+	BUFFER_TRACE(bh, "get_write_access");
+	ext3_journal_get_write_access(handle, bh);
+	/* By now the buffer is marked for journaling */
+	if (de->inode) {
+		ext3_dirent *de1 = (ext3_dirent *)((char *)de + nlen);
+		de1->rec_len = cpu_to_le16(rlen - nlen);
+		de->rec_len = cpu_to_le16(nlen);
+		de = de1;
+	}
+	de->file_type = EXT3_FT_UNKNOWN;
+	if (inode) {
+		de->inode = cpu_to_le32(inode->i_ino);
+		ext3_set_de_type(dir->i_sb, de, inode->i_mode);
+	} else
+		de->inode = 0;
+	de->name_len = dentry->d_name.len;
+	memcpy (de->name, dentry->d_name.name, dentry->d_name.len);
+	/*
+	 * XXX shouldn't update any times until successful
+	 * completion of syscall, but too many callers depend
+	 * on this.
+	 *
+	 * XXX similarly, too many callers depend on
+	 * ext3_new_inode() setting the times, but error
+	 * recovery deletes the inode, so the worst that can
+	 * happen is that the times are slightly out of date
+	 * and/or different from the directory change time.
+	 */
+	dir->i_mtime = dir->i_ctime = CURRENT_TIME;
+	ext3_update_dx_flag(dir);
+	dir->i_version = ++event;
+	ext3_mark_inode_dirty(handle, dir);
+	BUFFER_TRACE(bh, "call ext3_journal_dirty_metadata");
+	ext3_journal_dirty_metadata(handle, bh);
+	brelse(bh);
+	return 0;
+
+dx_make_index:
+	{
+		struct buffer_head *bh2;
+		struct dx_root *root;
+		struct dx_frame frames[2], *frame;
+		struct dx_entry *entries;
+		ext3_dirent *de2;
+		char *data1;
+		unsigned len;
+		u32 hash;
+		
+		dxtrace(printk("Creating index\n"));
+		ext3_journal_get_write_access(handle, bh);
+		root = (struct dx_root *) bh->b_data;
+		
+		EXT3_I(dir)->i_flags |= EXT3_INDEX_FL;
+		bh2 = ext3_append (handle, dir, &block, &retval);
+		if (!(bh2))
+		{
 			brelse(bh);
-			return 0;
+			return retval;
 		}
-		offset += le16_to_cpu(de->rec_len);
-		de = (struct ext3_dir_entry_2 *)
-			((char *) de + le16_to_cpu(de->rec_len));
+		data1 = bh2->b_data;
+
+		/* The 0th block becomes the root, move the dirents out */
+		de = (ext3_dirent *) &root->info;
+		len = ((char *) root) + sb->s_blocksize - (char *) de;
+		memcpy (data1, de, len);
+		de = (ext3_dirent *) data1;
+		top = data1 + len;
+		while (((char *) de2=(char*)de+le16_to_cpu(de->rec_len)) < top)
+			de = de2;
+		de->rec_len = cpu_to_le16(data1 + sb->s_blocksize - (char *)de);
+		/* Initialize the root; the dot dirents already exist */
+		de = (ext3_dirent *) (&root->dotdot);
+		de->rec_len = cpu_to_le16(sb->s_blocksize-EXT3_DIR_REC_LEN(2));
+		memset (&root->info, 0, sizeof(root->info));
+		root->info.info_length = sizeof(root->info);
+		entries = root->entries;
+		dx_set_block (entries, 1);
+		dx_set_count (entries, 1);
+		dx_set_limit (entries, dx_root_limit(dir, sizeof(root->info)));
+
+		/* Initialize as for dx_probe */
+		hash = dx_hash (dentry->d_name.name, dentry->d_name.len);
+		frame = frames;
+		frame->entries = entries;
+		frame->at = entries;
+		frame->bh = bh;
+		bh = bh2;
+		de = do_split(handle,dir, &bh, frame, hash, &retval);
+		dx_release (frames);
+		if (!(de))
+			return retval;
+		nlen = EXT3_DIR_REC_LEN(de->name_len);
+		rlen = le16_to_cpu(de->rec_len);
+		goto add;
 	}
-	brelse (bh);
-	return -ENOSPC;
+fail1:
+	return retval;
+fail:
+	return -ENOENT;
 }
 
 /*
@@ -451,7 +1212,8 @@
 	struct inode * inode;
 	int err;
 
-	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS + 3);
+	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS +
+					EXT3_INDEX_EXTRA_TRANS_BLOCKS + 3);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 
@@ -478,7 +1240,8 @@
 	struct inode *inode;
 	int err;
 
-	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS + 3);
+	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS +
+			 		EXT3_INDEX_EXTRA_TRANS_BLOCKS + 3);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 
@@ -507,7 +1270,8 @@
 	if (dir->i_nlink >= EXT3_LINK_MAX)
 		return -EMLINK;
 
-	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS + 3);
+	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS +
+					EXT3_INDEX_EXTRA_TRANS_BLOCKS + 3);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 
@@ -550,7 +1320,7 @@
 	if (err)
 		goto out_no_entry;
 	dir->i_nlink++;
-	dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
+	ext3_update_dx_flag(dir);
 	ext3_mark_inode_dirty(handle, dir);
 	d_instantiate(dentry, inode);
 out_stop:
@@ -832,7 +1596,7 @@
 	ext3_mark_inode_dirty(handle, inode);
 	dir->i_nlink--;
 	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
-	dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
+	ext3_update_dx_flag(dir);
 	ext3_mark_inode_dirty(handle, dir);
 
 end_rmdir:
@@ -878,7 +1642,7 @@
 	if (retval)
 		goto end_unlink;
 	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
-	dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
+	ext3_update_dx_flag(dir);
 	ext3_mark_inode_dirty(handle, dir);
 	inode->i_nlink--;
 	if (!inode->i_nlink)
@@ -904,7 +1668,8 @@
 	if (l > dir->i_sb->s_blocksize)
 		return -ENAMETOOLONG;
 
-	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS + 5);
+	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS +
+			 		EXT3_INDEX_EXTRA_TRANS_BLOCKS + 5);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 
@@ -959,7 +1724,8 @@
 	if (inode->i_nlink >= EXT3_LINK_MAX)
 		return -EMLINK;
 
-	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS);
+	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS +
+					EXT3_INDEX_EXTRA_TRANS_BLOCKS);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 
@@ -995,7 +1761,8 @@
 
 	old_bh = new_bh = dir_bh = NULL;
 
-	handle = ext3_journal_start(old_dir, 2 * EXT3_DATA_TRANS_BLOCKS + 2);
+	handle = ext3_journal_start(old_dir, 2 * EXT3_DATA_TRANS_BLOCKS +
+			 		EXT3_INDEX_EXTRA_TRANS_BLOCKS + 2);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 
@@ -1077,7 +1844,7 @@
 		new_inode->i_ctime = CURRENT_TIME;
 	}
 	old_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME;
-	old_dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
+	ext3_update_dx_flag(old_dir);
 	if (dir_bh) {
 		BUFFER_TRACE(dir_bh, "get_write_access");
 		ext3_journal_get_write_access(handle, dir_bh);
@@ -1089,7 +1856,7 @@
 			new_inode->i_nlink--;
 		} else {
 			new_dir->i_nlink++;
-			new_dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
+			ext3_update_dx_flag(new_dir);
 			ext3_mark_inode_dirty(handle, new_dir);
 		}
 	}
--- ./include/linux/ext3_fs.h	2002/03/05 06:18:59	2.1
+++ ./include/linux/ext3_fs.h	2002/03/05 06:26:56
@@ -339,6 +339,7 @@
   #define EXT3_MOUNT_WRITEBACK_DATA	0x0C00	/* No data ordering */
 #define EXT3_MOUNT_UPDATE_JOURNAL	0x1000	/* Update the journal format */
 #define EXT3_MOUNT_NO_UID32		0x2000  /* Disable 32-bit UIDs */
+#define EXT3_MOUNT_INDEX		0x4000  /* Enable directory index */
 
 /* Compatibility, for having both ext2_fs.h and ext3_fs.h included at once */
 #ifndef _LINUX_EXT2_FS_H
@@ -575,6 +576,24 @@
 #define EXT3_DIR_ROUND			(EXT3_DIR_PAD - 1)
 #define EXT3_DIR_REC_LEN(name_len)	(((name_len) + 8 + EXT3_DIR_ROUND) & \
 					 ~EXT3_DIR_ROUND)
+/*
+ * Hash Tree Directory indexing
+ * (c) Daniel Phillips, 2001
+ */
+
+#define CONFIG_EXT3_INDEX
+
+#ifdef CONFIG_EXT3_INDEX
+  enum {ext3_dx = 1};
+  #define is_dx(dir) (EXT3_I(dir)->i_flags & EXT3_INDEX_FL)
+#define EXT3_DIR_LINK_MAX(dir) (!is_dx(dir) && (dir)->i_nlink >= EXT3_LINK_MAX)
+#define EXT3_DIR_LINK_EMPTY(dir) ((dir)->i_nlink == 2 || (dir)->i_nlink == 1)
+#else
+  enum {ext3_dx = 0};
+  #define is_dx(dir) 0
+#define EXT3_DIR_LINK_MAX(dir) ((dir)->i_nlink >= EXT3_LINK_MAX)
+#define EXT3_DIR_LINK_EMPTY(dir) ((dir)->i_nlink == 2)
+#endif
 
 #ifdef __KERNEL__
 /*
--- ./include/linux/ext3_jbd.h	2002/03/05 06:18:59	2.1
+++ ./include/linux/ext3_jbd.h	2002/03/05 06:33:54
@@ -63,6 +63,8 @@
 
 #define EXT3_RESERVE_TRANS_BLOCKS	12
 
+#define EXT3_INDEX_EXTRA_TRANS_BLOCKS	8
+
 int
 ext3_mark_iloc_dirty(handle_t *handle, 
 		     struct inode *inode,
 fs/ext3/ialloc.c           |    2 
 fs/ext3/inode.c            |   29 -
 fs/ext3/namei.c            |   12 
 fs/ext3/super.c            |   21 
 fs/ext3/xattr.c            | 1247 +++++++++++++++++++++++++++++++++++++++++++++
 include/linux/ext3_fs.h    |   46 -
 include/linux/ext3_jbd.h   |    8 
 include/linux/ext3_xattr.h |  155 +++++
 include/linux/xattr.h      |   15 
 9 files changed, 1486 insertions(+), 49 deletions(-)

--- linux-2.4.18-18/fs/ext3/ialloc.c~linux-2.4.18ea-0.8.26	Sat Apr  5 02:54:56 2003
+++ linux-2.4.18-18-braam/fs/ext3/ialloc.c	Sat Apr  5 03:03:06 2003
@@ -17,6 +17,7 @@
 #include <linux/jbd.h>
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
+#include <linux/ext3_xattr.h>
 #include <linux/stat.h>
 #include <linux/string.h>
 #include <linux/locks.h>
@@ -216,6 +217,7 @@ void ext3_free_inode (handle_t *handle, 
 	 * as writing the quota to disk may need the lock as well.
 	 */
 	DQUOT_INIT(inode);
+	ext3_xattr_drop_inode(handle, inode);
 	DQUOT_FREE_INODE(inode);
 	DQUOT_DROP(inode);
 
--- linux-2.4.18-18/fs/ext3/inode.c~linux-2.4.18ea-0.8.26	Sat Apr  5 02:54:56 2003
+++ linux-2.4.18-18-braam/fs/ext3/inode.c	Sat Apr  5 03:03:06 2003
@@ -39,6 +39,18 @@
  */
 #undef SEARCH_FROM_ZERO
 
+/*
+ * Test whether an inode is a fast symlink.
+ */
+static inline int ext3_inode_is_fast_symlink(struct inode *inode)
+{
+	int ea_blocks = EXT3_I(inode)->i_file_acl ?
+		(inode->i_sb->s_blocksize >> 9) : 0;
+
+	return (S_ISLNK(inode->i_mode) &&
+		inode->i_blocks - ea_blocks == 0);
+}
+
 /* The ext3 forget function must perform a revoke if we are freeing data
  * which has been journaled.  Metadata (eg. indirect blocks) must be
  * revoked in all cases. 
@@ -48,7 +60,7 @@
  * still needs to be revoked.
  */
 
-static int ext3_forget(handle_t *handle, int is_metadata,
+int ext3_forget(handle_t *handle, int is_metadata,
 		       struct inode *inode, struct buffer_head *bh,
 		       int blocknr)
 {
@@ -164,9 +176,7 @@ void ext3_delete_inode (struct inode * i
 {
 	handle_t *handle;
 	
-	if (is_bad_inode(inode) ||
-	    inode->i_ino == EXT3_ACL_IDX_INO ||
-	    inode->i_ino == EXT3_ACL_DATA_INO)
+	if (is_bad_inode(inode))
 		goto no_delete;
 
 	lock_kernel();
@@ -1861,6 +1871,8 @@ void ext3_truncate(struct inode * inode)
 	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 	    S_ISLNK(inode->i_mode)))
 		return;
+	if (ext3_inode_is_fast_symlink(inode))
+		return;
 	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
 		return;
 
@@ -2008,8 +2020,6 @@ int ext3_get_inode_loc (struct inode *in
 	struct ext3_group_desc * gdp;
 		
 	if ((inode->i_ino != EXT3_ROOT_INO &&
-		inode->i_ino != EXT3_ACL_IDX_INO &&
-		inode->i_ino != EXT3_ACL_DATA_INO &&
 		inode->i_ino != EXT3_JOURNAL_INO &&
 		inode->i_ino < EXT3_FIRST_INO(inode->i_sb)) ||
 		inode->i_ino > le32_to_cpu(
@@ -2136,10 +2146,7 @@ void ext3_read_inode(struct inode * inod
 
 	brelse (iloc.bh);
 
-	if (inode->i_ino == EXT3_ACL_IDX_INO ||
-	    inode->i_ino == EXT3_ACL_DATA_INO)
-		/* Nothing to do */ ;
-	else if (S_ISREG(inode->i_mode)) {
+	if (S_ISREG(inode->i_mode)) {
 		inode->i_op = &ext3_file_inode_operations;
 		inode->i_fop = &ext3_file_operations;
 		inode->i_mapping->a_ops = &ext3_aops;
@@ -2147,7 +2154,7 @@ void ext3_read_inode(struct inode * inod
 		inode->i_op = &ext3_dir_inode_operations;
 		inode->i_fop = &ext3_dir_operations;
 	} else if (S_ISLNK(inode->i_mode)) {
-		if (!inode->i_blocks)
+		if (ext3_inode_is_fast_symlink(inode))
 			inode->i_op = &ext3_fast_symlink_inode_operations;
 		else {
 			inode->i_op = &page_symlink_inode_operations;
--- linux-2.4.18-18/fs/ext3/namei.c~linux-2.4.18ea-0.8.26	Sat Apr  5 02:54:56 2003
+++ linux-2.4.18-18-braam/fs/ext3/namei.c	Sat Apr  5 03:03:06 2003
@@ -27,6 +27,7 @@
 #include <linux/sched.h>
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
+#include <linux/ext3_xattr.h>
 #include <linux/fcntl.h>
 #include <linux/stat.h>
 #include <linux/string.h>
@@ -1183,6 +1184,7 @@ static int ext3_add_nondir(handle_t *han
 		d_instantiate(dentry, inode);
 		return 0;
 	}
+	ext3_xattr_drop_inode(handle, inode);
 	ext3_dec_count(handle, inode);
 	iput(inode);
 	return err;
@@ -1268,15 +1270,14 @@ static int ext3_mkdir(struct inode * dir
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, S_IFDIR);
+	inode = ext3_new_inode (handle, dir, S_IFDIR | mode);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_stop;
 
 	inode->i_op = &ext3_dir_inode_operations;
 	inode->i_fop = &ext3_dir_operations;
-	inode->i_size = inode->u.ext3_i.i_disksize = inode->i_sb->s_blocksize;
-	inode->i_blocks = 0;	
+	inode->i_size = EXT3_I(inode)->i_disksize = inode->i_sb->s_blocksize;
 	dir_block = ext3_bread (handle, inode, 0, 1, &err);
 	if (!dir_block) {
 		inode->i_nlink--; /* is this nlink == 0? */
@@ -1303,9 +1304,6 @@ static int ext3_mkdir(struct inode * dir
 	BUFFER_TRACE(dir_block, "call ext3_journal_dirty_metadata");
 	ext3_journal_dirty_metadata(handle, dir_block);
 	brelse (dir_block);
-	inode->i_mode = S_IFDIR | mode;
-	if (dir->i_mode & S_ISGID)
-		inode->i_mode |= S_ISGID;
 	ext3_mark_inode_dirty(handle, inode);
 	err = ext3_add_entry (handle, dentry, inode);
 	if (err)
@@ -1671,7 +1669,7 @@ static int ext3_symlink (struct inode * 
 	if (IS_ERR(inode))
 		goto out_stop;
 
-	if (l > sizeof (inode->u.ext3_i.i_data)) {
+	if (l > sizeof(EXT3_I(inode)->i_data)) {
 		inode->i_op = &page_symlink_inode_operations;
 		inode->i_mapping->a_ops = &ext3_aops;
 		/*
--- linux-2.4.18-18/fs/ext3/super.c~linux-2.4.18ea-0.8.26	Sat Apr  5 02:54:56 2003
+++ linux-2.4.18-18-braam/fs/ext3/super.c	Sat Apr  5 03:03:06 2003
@@ -24,6 +24,7 @@
 #include <linux/jbd.h>
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
+#include <linux/ext3_xattr.h>
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/locks.h>
@@ -404,6 +405,7 @@ void ext3_put_super (struct super_block 
 	kdev_t j_dev = sbi->s_journal->j_dev;
 	int i;
 
+	ext3_xattr_put_super(sb);
 	journal_destroy(sbi->s_journal);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		EXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);
@@ -1748,14 +1750,25 @@ int ext3_statfs (struct super_block * sb
 
 static DECLARE_FSTYPE_DEV(ext3_fs_type, "ext3", ext3_read_super);
 
-static int __init init_ext3_fs(void)
+static void exit_ext3_fs(void)
 {
-        return register_filesystem(&ext3_fs_type);
+	unregister_filesystem(&ext3_fs_type);
+	exit_ext3_xattr_user();
+	exit_ext3_xattr();
 }
 
-static void __exit exit_ext3_fs(void)
+static int __init init_ext3_fs(void)
 {
-	unregister_filesystem(&ext3_fs_type);
+	int error = init_ext3_xattr();
+	if (!error)
+		error = init_ext3_xattr_user();
+	if (!error)
+		error = register_filesystem(&ext3_fs_type);
+	if (!error)
+		return 0;
+
+	exit_ext3_fs();
+	return error;
 }
 
 EXPORT_SYMBOL(ext3_bread);
--- /dev/null	Fri Aug 30 17:31:37 2002
+++ linux-2.4.18-18-braam/fs/ext3/xattr.c	Sat Apr  5 02:54:56 2003
@@ -0,0 +1,1247 @@
+/*
+ * linux/fs/ext3/xattr.c
+ *
+ * Copyright (C) 2001 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
+ *
+ * Fix by Harrison Xing <harrison@mountainviewdata.com>.
+ * Ext3 code with a lot of help from Eric Jarman <ejarman@acm.org>.
+ * Extended attributes for symlinks and special files added per
+ *  suggestion of Luka Renko <luka.renko@hermes.si>.
+ */
+
+/*
+ * Extended attributes are stored on disk blocks allocated outside of
+ * any inode. The i_file_acl field is then made to point to this allocated
+ * block. If all extended attributes of an inode are identical, these
+ * inodes may share the same extended attribute block. Such situations
+ * are automatically detected by keeping a cache of recent attribute block
+ * numbers and hashes over the block's contents in memory.
+ *
+ *
+ * Extended attribute block layout:
+ *
+ *   +------------------+
+ *   | header           |
+ *    entry 1          | |
+ *   | entry 2          | | growing downwards
+ *   | entry 3          | v
+ *   | four null bytes  |
+ *   | . . .            |
+ *   | value 1          | ^
+ *   | value 3          | | growing upwards
+ *   | value 2          | |
+ *   +------------------+
+ *
+ * The block header is followed by multiple entry descriptors. These entry
+ * descriptors are variable in size, and alligned to EXT3_XATTR_PAD
+ * byte boundaries. The entry descriptors are sorted by attribute name,
+ * so that two extended attribute blocks can be compared efficiently.
+ *
+ * Attribute values are aligned to the end of the block, stored in
+ * no specific order. They are also padded to EXT3_XATTR_PAD byte
+ * boundaries. No additional gaps are left between them.
+ *
+ * Locking strategy
+ * ----------------
+ * The VFS already holds the BKL and the inode->i_sem semaphore when any of
+ * the xattr inode operations are called, so we are guaranteed that only one
+ * processes accesses extended attributes of an inode at any time.
+ *
+ * For writing we also grab the ext3_xattr_sem semaphore. This ensures that
+ * only a single process is modifying an extended attribute block, even
+ * if the block is shared among inodes.
+ *
+ * Note for porting to 2.5
+ * -----------------------
+ * The BKL will no longer be held in the xattr inode operations.
+ */
+
+#include <linux/fs.h>
+#include <linux/locks.h>
+#include <linux/slab.h>
+#include <linux/ext3_jbd.h>
+#include <linux/ext3_fs.h>
+#include <linux/ext3_xattr.h>
+#ifdef CONFIG_EXT3_FS_XATTR_SHARING
+#include <linux/mbcache.h>
+#endif
+#include <linux/quotaops.h>
+#include <asm/semaphore.h>
+#include <linux/compatmac.h>
+#include <linux/module.h>
+
+/* These symbols may be needed by a module. */
+EXPORT_SYMBOL(ext3_xattr_register);
+EXPORT_SYMBOL(ext3_xattr_unregister);
+EXPORT_SYMBOL(ext3_xattr_get);
+EXPORT_SYMBOL(ext3_xattr_list);
+EXPORT_SYMBOL(ext3_xattr_set);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+# define mark_buffer_dirty(bh) mark_buffer_dirty(bh, 1)
+#endif
+
+#define HDR(bh) ((struct ext3_xattr_header *)((bh)->b_data))
+#define ENTRY(ptr) ((struct ext3_xattr_entry *)(ptr))
+#define FIRST_ENTRY(bh) ENTRY(HDR(bh)+1)
+#define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)
+
+#ifdef EXT3_XATTR_DEBUG
+# define ea_idebug(inode, f...) do { \
+		printk(KERN_DEBUG "inode %s:%ld: ", \
+			kdevname(inode->i_dev), inode->i_ino); \
+		printk(f); \
+		printk("\n"); \
+	} while (0)
+# define ea_bdebug(bh, f...) do { \
+		printk(KERN_DEBUG "block %s:%ld: ", \
+			kdevname(bh->b_dev), bh->b_blocknr); \
+		printk(f); \
+		printk("\n"); \
+	} while (0)
+#else
+# define ea_idebug(f...)
+# define ea_bdebug(f...)
+#endif
+
+static int ext3_xattr_set2(handle_t *, struct inode *, struct buffer_head *,
+			   struct ext3_xattr_header *);
+
+#ifdef CONFIG_EXT3_FS_XATTR_SHARING
+
+static int ext3_xattr_cache_insert(struct buffer_head *);
+static struct buffer_head *ext3_xattr_cache_find(struct inode *,
+						 struct ext3_xattr_header *);
+static void ext3_xattr_cache_remove(struct buffer_head *);
+static void ext3_xattr_rehash(struct ext3_xattr_header *,
+			      struct ext3_xattr_entry *);
+
+static struct mb_cache *ext3_xattr_cache;
+
+#else
+# define ext3_xattr_cache_insert(bh) 0
+# define ext3_xattr_cache_find(inode, header) NULL
+# define ext3_xattr_cache_remove(bh) do {} while(0)
+# define ext3_xattr_rehash(header, entry) do {} while(0)
+#endif
+
+/*
+ * If a file system does not share extended attributes among inodes,
+ * we should not need the ext3_xattr_sem semaphore. However, the
+ * filesystem may still contain shared blocks, so we always take
+ * the lock.
+ */
+
+DECLARE_MUTEX(ext3_xattr_sem);
+
+static inline void
+ext3_xattr_lock(void)
+{
+	down(&ext3_xattr_sem);
+}
+
+static inline void
+ext3_xattr_unlock(void)
+{
+	up(&ext3_xattr_sem);
+}
+
+static inline int
+ext3_xattr_new_block(handle_t *handle, struct inode *inode,
+		     int * errp, int force)
+{
+	struct super_block *sb = inode->i_sb;
+	int goal = le32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block) +
+		EXT3_I(inode)->i_block_group * EXT3_BLOCKS_PER_GROUP(sb);
+
+	/* How can we enforce the allocation? */
+	int block = ext3_new_block(handle, inode, goal, 0, 0, errp);
+#ifdef OLD_QUOTAS
+	if (!*errp)
+		inode->i_blocks += inode->i_sb->s_blocksize >> 9;
+#endif
+	return block;
+}
+
+static inline int
+ext3_xattr_quota_alloc(struct inode *inode, int force)
+{
+	/* How can we enforce the allocation? */
+#ifdef OLD_QUOTAS
+	int error = DQUOT_ALLOC_BLOCK(inode->i_sb, inode, 1);
+	if (!error)
+		inode->i_blocks += inode->i_sb->s_blocksize >> 9;
+#else
+	int error = DQUOT_ALLOC_BLOCK(inode, 1);
+#endif
+	return error;
+}
+
+#ifdef OLD_QUOTAS
+
+static inline void
+ext3_xattr_quota_free(struct inode *inode)
+{
+	DQUOT_FREE_BLOCK(inode->i_sb, inode, 1);
+	inode->i_blocks -= inode->i_sb->s_blocksize >> 9;
+}
+
+static inline void
+ext3_xattr_free_block(handle_t *handle, struct inode * inode,
+		      unsigned long block)
+{
+	ext3_free_blocks(handle, inode, block, 1);
+	inode->i_blocks -= inode->i_sb->s_blocksize >> 9;
+}
+
+#else
+# define ext3_xattr_quota_free(inode) \
+	DQUOT_FREE_BLOCK(inode, 1)
+# define ext3_xattr_free_block(handle, inode, block) \
+	ext3_free_blocks(handle, inode, block, 1)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18)
+
+static inline struct buffer_head *
+sb_bread(struct super_block *sb, int block)
+{
+	return bread(sb->s_dev, block, sb->s_blocksize);
+}
+
+static inline struct buffer_head *
+sb_getblk(struct super_block *sb, int block)
+{
+	return getblk(sb->s_dev, block, sb->s_blocksize);
+}
+
+#endif
+
+struct ext3_xattr_handler *ext3_xattr_handlers[EXT3_XATTR_INDEX_MAX];
+rwlock_t ext3_handler_lock = RW_LOCK_UNLOCKED;
+
+int
+ext3_xattr_register(int name_index, struct ext3_xattr_handler *handler)
+{
+	int error = -EINVAL;
+
+	if (name_index > 0 && name_index <= EXT3_XATTR_INDEX_MAX) {
+		write_lock(&ext3_handler_lock);
+		if (!ext3_xattr_handlers[name_index-1]) {
+			ext3_xattr_handlers[name_index-1] = handler;
+			error = 0;
+		}
+		write_unlock(&ext3_handler_lock);
+	}
+	return error;
+}
+
+void
+ext3_xattr_unregister(int name_index, struct ext3_xattr_handler *handler)
+{
+	if (name_index > 0 || name_index <= EXT3_XATTR_INDEX_MAX) {
+		write_lock(&ext3_handler_lock);
+		ext3_xattr_handlers[name_index-1] = NULL;
+		write_unlock(&ext3_handler_lock);
+	}
+}
+
+static inline const char *
+strcmp_prefix(const char *a, const char *a_prefix)
+{
+	while (*a_prefix && *a == *a_prefix) {
+		a++;
+		a_prefix++;
+	}
+	return *a_prefix ? NULL : a;
+}
+
+/*
+ * Decode the extended attribute name, and translate it into
+ * the name_index and name suffix.
+ */
+static inline struct ext3_xattr_handler *
+ext3_xattr_resolve_name(const char **name)
+{
+	struct ext3_xattr_handler *handler = NULL;
+	int i;
+
+	if (!*name)
+		return NULL;
+	read_lock(&ext3_handler_lock);
+	for (i=0; i<EXT3_XATTR_INDEX_MAX; i++) {
+		if (ext3_xattr_handlers[i]) {
+			const char *n = strcmp_prefix(*name,
+				ext3_xattr_handlers[i]->prefix);
+			if (n) {
+				handler = ext3_xattr_handlers[i];
+				*name = n;
+				break;
+			}
+		}
+	}
+	read_unlock(&ext3_handler_lock);
+	return handler;
+}
+
+static inline struct ext3_xattr_handler *
+ext3_xattr_handler(int name_index)
+{
+	struct ext3_xattr_handler *handler = NULL;
+	if (name_index > 0 && name_index <= EXT3_XATTR_INDEX_MAX) {
+		read_lock(&ext3_handler_lock);
+		handler = ext3_xattr_handlers[name_index-1];
+		read_unlock(&ext3_handler_lock);
+	}
+	return handler;
+}
+
+/*
+ * Inode operation getxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+ssize_t
+ext3_getxattr(struct dentry *dentry, const char *name,
+	      void *buffer, size_t size)
+{
+	struct ext3_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	handler = ext3_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->get(inode, name, buffer, size);
+}
+
+/*
+ * Inode operation listxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+ssize_t
+ext3_listxattr(struct dentry *dentry, char *buffer, size_t size)
+{
+	return ext3_xattr_list(dentry->d_inode, buffer, size);
+}
+
+/*
+ * Inode operation setxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+int
+ext3_setxattr(struct dentry *dentry, const char *name,
+	      void *value, size_t size, int flags)
+{
+	struct ext3_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	if (size == 0)
+		value = "";  /* empty EA, do not remove */
+	handler = ext3_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->set(inode, name, value, size, flags);
+}
+
+/*
+ * Inode operation removexattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+int
+ext3_removexattr(struct dentry *dentry, const char *name)
+{
+	struct ext3_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	handler = ext3_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->set(inode, name, NULL, 0, XATTR_REPLACE);
+}
+
+/*
+ * ext3_xattr_get()
+ *
+ * Copy an extended attribute into the buffer
+ * provided, or compute the buffer size required.
+ * Buffer is NULL to compute the size of the buffer required.
+ *
+ * Returns a negative error number on failure, or the number of bytes
+ * used / required on success.
+ */
+int
+ext3_xattr_get(struct inode *inode, int name_index, const char *name,
+	       void *buffer, size_t buffer_size)
+{
+	struct buffer_head *bh = NULL;
+	struct ext3_xattr_entry *entry;
+	unsigned int block, size;
+	char *end;
+	int name_len, error;
+
+	ea_idebug(inode, "name=%d.%s, buffer=%p, buffer_size=%ld",
+		  name_index, name, buffer, (long)buffer_size);
+
+	if (name == NULL)
+		return -EINVAL;
+	if (!EXT3_I(inode)->i_file_acl)
+		return -ENOATTR;
+	block = EXT3_I(inode)->i_file_acl;
+	ea_idebug(inode, "reading block %d", block);
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh)
+		return -EIO;
+	ea_bdebug(bh, "b_count=%d, refcount=%d",
+		atomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));
+	end = bh->b_data + bh->b_size;
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+bad_block:	ext3_error(inode->i_sb, "ext3_xattr_get",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		error = -EIO;
+		goto cleanup;
+	}
+	/* find named attribute */
+	name_len = strlen(name);
+
+	error = -ERANGE;
+	if (name_len > 255)
+		goto cleanup;
+	entry = FIRST_ENTRY(bh);
+	while (!IS_LAST_ENTRY(entry)) {
+		struct ext3_xattr_entry *next =
+			EXT3_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+		if (name_index == entry->e_name_index &&
+		    name_len == entry->e_name_len &&
+		    memcmp(name, entry->e_name, name_len) == 0)
+			goto found;
+		entry = next;
+	}
+	/* Check the remaining name entries */
+	while (!IS_LAST_ENTRY(entry)) {
+		struct ext3_xattr_entry *next =
+			EXT3_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+		entry = next;
+	}
+	if (ext3_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	error = -ENOATTR;
+	goto cleanup;
+found:
+	/* check the buffer size */
+	if (entry->e_value_block != 0)
+		goto bad_block;
+	size = le32_to_cpu(entry->e_value_size);
+	if (size > inode->i_sb->s_blocksize ||
+	    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)
+		goto bad_block;
+
+	if (ext3_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	if (buffer) {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto cleanup;
+		/* return value of attribute */
+		memcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),
+			size);
+	}
+	error = size;
+
+cleanup:
+	brelse(bh);
+
+	return error;
+}
+
+/*
+ * ext3_xattr_list()
+ *
+ * Copy a list of attribute names into the buffer
+ * provided, or compute the buffer size required.
+ * Buffer is NULL to compute the size of the buffer required.
+ *
+ * Returns a negative error number on failure, or the number of bytes
+ * used / required on success.
+ */
+int
+ext3_xattr_list(struct inode *inode, char *buffer, size_t buffer_size)
+{
+	struct buffer_head *bh = NULL;
+	struct ext3_xattr_entry *entry;
+	unsigned int block, size = 0;
+	char *buf, *end;
+	int error;
+
+	ea_idebug(inode, "buffer=%p, buffer_size=%ld",
+		  buffer, (long)buffer_size);
+
+	if (!EXT3_I(inode)->i_file_acl)
+		return 0;
+	block = EXT3_I(inode)->i_file_acl;
+	ea_idebug(inode, "reading block %d", block);
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh)
+		return -EIO;
+	ea_bdebug(bh, "b_count=%d, refcount=%d",
+		atomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));
+	end = bh->b_data + bh->b_size;
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+bad_block:	ext3_error(inode->i_sb, "ext3_xattr_list",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		error = -EIO;
+		goto cleanup;
+	}
+	/* compute the size required for the list of attribute names */
+	for (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);
+	     entry = EXT3_XATTR_NEXT(entry)) {
+		struct ext3_xattr_handler *handler;
+		struct ext3_xattr_entry *next =
+			EXT3_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+
+		handler = ext3_xattr_handler(entry->e_name_index);
+		if (handler) {
+			size += handler->list(NULL, inode, entry->e_name,
+					      entry->e_name_len) + 1;
+		}
+	}
+
+	if (ext3_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	if (!buffer) {
+		error = size;
+		goto cleanup;
+	} else {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto cleanup;
+	}
+
+	/* list the attribute names */
+	buf = buffer;
+	for (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);
+	     entry = EXT3_XATTR_NEXT(entry)) {
+		struct ext3_xattr_handler *handler;
+
+		handler = ext3_xattr_handler(entry->e_name_index);
+		if (handler) {
+			buf += handler->list(buf, inode, entry->e_name,
+					     entry->e_name_len);
+			*buf++ = '\0';
+		}
+	}
+	error = size;
+
+cleanup:
+	brelse(bh);
+
+	return error;
+}
+
+/*
+ * If the EXT3_FEATURE_COMPAT_EXT_ATTR feature of this file system is
+ * not set, set it.
+ */
+static void ext3_xattr_update_super_block(handle_t *handle,
+					  struct super_block *sb)
+{
+	if (EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_EXT_ATTR))
+		return;
+
+	lock_super(sb);
+	ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+	EXT3_SB(sb)->s_feature_compat |= EXT3_FEATURE_COMPAT_EXT_ATTR;
+#endif
+	EXT3_SB(sb)->s_es->s_feature_compat |=
+		cpu_to_le32(EXT3_FEATURE_COMPAT_EXT_ATTR);
+	sb->s_dirt = 1;
+	ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
+	unlock_super(sb);
+}
+
+/*
+ * ext3_xattr_set()
+ *
+ * Create, replace or remove an extended attribute for this inode. Buffer
+ * is NULL to remove an existing extended attribute, and non-NULL to
+ * either replace an existing extended attribute, or create a new extended
+ * attribute. The flags XATTR_REPLACE and XATTR_CREATE
+ * specify that an extended attribute must exist and must not exist
+ * previous to the call, respectively.
+ *
+ * Returns 0, or a negative error number on failure.
+ */
+int
+ext3_xattr_set(handle_t *handle, struct inode *inode, int name_index,
+	       const char *name, void *value, size_t value_len, int flags)
+{
+	struct super_block *sb = inode->i_sb;
+	struct buffer_head *bh = NULL;
+	struct ext3_xattr_header *header = NULL;
+	struct ext3_xattr_entry *here, *last;
+	unsigned int name_len;
+	int min_offs = sb->s_blocksize, not_found = 1, free, error;
+	char *end;
+	
+	/*
+	 * header -- Points either into bh, or to a temporarily
+	 *           allocated buffer.
+	 * here -- The named entry found, or the place for inserting, within
+	 *         the block pointed to by header.
+	 * last -- Points right after the last named entry within the block
+	 *         pointed to by header.
+	 * min_offs -- The offset of the first value (values are aligned
+	 *             towards the end of the block).
+	 * end -- Points right after the block pointed to by header.
+	 */
+	
+	ea_idebug(inode, "name=%d.%s, value=%p, value_len=%ld",
+		  name_index, name, value, (long)value_len);
+
+	if (IS_RDONLY(inode))
+		return -EROFS;
+	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
+		return -EPERM;
+	if (value == NULL)
+		value_len = 0;
+	if (name == NULL)
+		return -EINVAL;
+	name_len = strlen(name);
+	if (name_len > 255 || value_len > sb->s_blocksize)
+		return -ERANGE;
+	ext3_xattr_lock();
+
+	if (EXT3_I(inode)->i_file_acl) {
+		/* The inode already has an extended attribute block. */
+		int block = EXT3_I(inode)->i_file_acl;
+
+		bh = sb_bread(sb, block);
+		error = -EIO;
+		if (!bh)
+			goto cleanup;
+		ea_bdebug(bh, "b_count=%d, refcount=%d",
+			atomic_read(&(bh->b_count)),
+			le32_to_cpu(HDR(bh)->h_refcount));
+		header = HDR(bh);
+		end = bh->b_data + bh->b_size;
+		if (header->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||
+		    header->h_blocks != cpu_to_le32(1)) {
+bad_block:		ext3_error(sb, "ext3_xattr_set",
+				"inode %ld: bad block %d", inode->i_ino, block);
+			error = -EIO;
+			goto cleanup;
+		}
+		/* Find the named attribute. */
+		here = FIRST_ENTRY(bh);
+		while (!IS_LAST_ENTRY(here)) {
+			struct ext3_xattr_entry *next = EXT3_XATTR_NEXT(here);
+			if ((char *)next >= end)
+				goto bad_block;
+			if (!here->e_value_block && here->e_value_size) {
+				int offs = le16_to_cpu(here->e_value_offs);
+				if (offs < min_offs)
+					min_offs = offs;
+			}
+			not_found = name_index - here->e_name_index;
+			if (!not_found)
+				not_found = name_len - here->e_name_len;
+			if (!not_found)
+				not_found = memcmp(name, here->e_name,name_len);
+			if (not_found <= 0)
+				break;
+			here = next;
+		}
+		last = here;
+		/* We still need to compute min_offs and last. */
+		while (!IS_LAST_ENTRY(last)) {
+			struct ext3_xattr_entry *next = EXT3_XATTR_NEXT(last);
+			if ((char *)next >= end)
+				goto bad_block;
+			if (!last->e_value_block && last->e_value_size) {
+				int offs = le16_to_cpu(last->e_value_offs);
+				if (offs < min_offs)
+					min_offs = offs;
+			}
+			last = next;
+		}
+
+		/* Check whether we have enough space left. */
+		free = min_offs - ((char*)last - (char*)header) - sizeof(__u32);
+	} else {
+		/* We will use a new extended attribute block. */
+		free = sb->s_blocksize -
+			sizeof(struct ext3_xattr_header) - sizeof(__u32);
+		here = last = NULL;  /* avoid gcc uninitialized warning. */
+	}
+
+	if (not_found) {
+		/* Request to remove a nonexistent attribute? */
+		error = -ENOATTR;
+		if (flags & XATTR_REPLACE)
+			goto cleanup;
+		error = 0;
+		if (value == NULL)
+			goto cleanup;
+		else
+			free -= EXT3_XATTR_LEN(name_len);
+	} else {
+		/* Request to create an existing attribute? */
+		error = -EEXIST;
+		if (flags & XATTR_CREATE)
+			goto cleanup;
+		if (!here->e_value_block && here->e_value_size) {
+			unsigned int size = le32_to_cpu(here->e_value_size);
+
+			if (le16_to_cpu(here->e_value_offs) + size > 
+			    sb->s_blocksize || size > sb->s_blocksize)
+				goto bad_block;
+			free += EXT3_XATTR_SIZE(size);
+		}
+	}
+	free -= EXT3_XATTR_SIZE(value_len);
+	error = -ENOSPC;
+	if (free < 0)
+		goto cleanup;
+
+	/* Here we know that we can set the new attribute. */
+
+	if (header) {
+		if (header->h_refcount == cpu_to_le32(1)) {
+			ea_bdebug(bh, "modifying in-place");
+			ext3_xattr_cache_remove(bh);
+			error = ext3_journal_get_write_access(handle, bh);
+			if (error)
+				goto cleanup;
+		} else {
+			int offset;
+
+			ea_bdebug(bh, "cloning");
+			header = kmalloc(bh->b_size, GFP_KERNEL);
+			error = -ENOMEM;
+			if (header == NULL)
+				goto cleanup;
+			memcpy(header, HDR(bh), bh->b_size);
+			header->h_refcount = cpu_to_le32(1);
+			offset = (char *)header - bh->b_data;
+			here = ENTRY((char *)here + offset);
+			last = ENTRY((char *)last + offset);
+		}
+	} else {
+		/* Allocate a buffer where we construct the new block. */
+		header = kmalloc(sb->s_blocksize, GFP_KERNEL);
+		error = -ENOMEM;
+		if (header == NULL)
+			goto cleanup;
+		memset(header, 0, sb->s_blocksize);
+		end = (char *)header + sb->s_blocksize;
+		header->h_magic = cpu_to_le32(EXT3_XATTR_MAGIC);
+		header->h_blocks = header->h_refcount = cpu_to_le32(1);
+		last = here = ENTRY(header+1);
+	}
+
+	if (not_found) {
+		/* Insert the new name. */
+		int size = EXT3_XATTR_LEN(name_len);
+		int rest = (char *)last - (char *)here;
+		memmove((char *)here + size, here, rest);
+		memset(here, 0, size);
+		here->e_name_index = name_index;
+		here->e_name_len = name_len;
+		memcpy(here->e_name, name, name_len);
+	} else {
+		/* Remove the old value. */
+		if (!here->e_value_block && here->e_value_size) {
+			char *first_val = (char *)header + min_offs;
+			int offs = le16_to_cpu(here->e_value_offs);
+			char *val = (char *)header + offs;
+			size_t size = EXT3_XATTR_SIZE(
+				le32_to_cpu(here->e_value_size));
+			memmove(first_val + size, first_val, val - first_val);
+			memset(first_val, 0, size);
+			here->e_value_offs = 0;
+			min_offs += size;
+
+			/* Adjust all value offsets. */
+			last = ENTRY(header+1);
+			while (!IS_LAST_ENTRY(last)) {
+				int o = le16_to_cpu(last->e_value_offs);
+				if (!last->e_value_block && o < offs)
+					last->e_value_offs =
+						cpu_to_le16(o + size);
+				last = EXT3_XATTR_NEXT(last);
+			}
+		}
+		if (value == NULL) {
+			/* Remove this attribute. */
+			if (EXT3_XATTR_NEXT(ENTRY(header+1)) == last) {
+				/* This block is now empty. */
+				error = ext3_xattr_set2(handle, inode, bh,NULL);
+				goto cleanup;
+			} else {
+				/* Remove the old name. */
+				int size = EXT3_XATTR_LEN(name_len);
+				last = ENTRY((char *)last - size);
+				memmove(here, (char*)here + size,
+					(char*)last - (char*)here);
+				memset(last, 0, size);
+			}
+		}
+	}
+
+	if (value != NULL) {
+		/* Insert the new value. */
+		here->e_value_size = cpu_to_le32(value_len);
+		if (value_len) {
+			size_t size = EXT3_XATTR_SIZE(value_len);
+			char *val = (char *)header + min_offs - size;
+			here->e_value_offs =
+				cpu_to_le16((char *)val - (char *)header);
+			memset(val + size - EXT3_XATTR_PAD, 0,
+			       EXT3_XATTR_PAD); /* Clear the pad bytes. */
+			memcpy(val, value, value_len);
+		}
+	}
+	ext3_xattr_rehash(header, here);
+
+	error = ext3_xattr_set2(handle, inode, bh, header);
+
+cleanup:
+	brelse(bh);
+	if (!(bh && header == HDR(bh)))
+		kfree(header);
+	ext3_xattr_unlock();
+
+	return error;
+}
+
+/*
+ * Second half of ext3_xattr_set(): Update the file system.
+ */
+static int
+ext3_xattr_set2(handle_t *handle, struct inode *inode,
+		struct buffer_head *old_bh, struct ext3_xattr_header *header)
+{
+	struct super_block *sb = inode->i_sb;
+	struct buffer_head *new_bh = NULL;
+	int error;
+
+	if (header) {
+		new_bh = ext3_xattr_cache_find(inode, header);
+		if (new_bh) {
+			/*
+			 * We found an identical block in the cache.
+			 * The old block will be released after updating
+			 * the inode.
+			 */
+			ea_bdebug(old_bh, "reusing block %ld",
+				new_bh->b_blocknr);
+			
+			error = -EDQUOT;
+			if (ext3_xattr_quota_alloc(inode, 1))
+				goto cleanup;
+			
+			error = ext3_journal_get_write_access(handle, new_bh);
+			if (error)
+				goto cleanup;
+			HDR(new_bh)->h_refcount = cpu_to_le32(
+				le32_to_cpu(HDR(new_bh)->h_refcount) + 1);
+			ea_bdebug(new_bh, "refcount now=%d",
+				le32_to_cpu(HDR(new_bh)->h_refcount));
+		} else if (old_bh && header == HDR(old_bh)) {
+			/* Keep this block. */
+			new_bh = old_bh;
+			(void)ext3_xattr_cache_insert(new_bh);
+		} else {
+			/* We need to allocate a new block */
+			int force = EXT3_I(inode)->i_file_acl != 0;
+			int block = ext3_xattr_new_block(handle, inode,
+							 &error, force);
+			if (error)
+				goto cleanup;
+			ea_idebug(inode, "creating block %d", block);
+
+			new_bh = sb_getblk(sb, block);
+			if (!new_bh) {
+getblk_failed:			ext3_xattr_free_block(handle, inode, block);
+				error = -EIO;
+				goto cleanup;
+			}
+			lock_buffer(new_bh);
+			error = ext3_journal_get_create_access(handle, new_bh);
+			if (error) {
+				unlock_buffer(new_bh);
+				goto getblk_failed;
+			}
+			memcpy(new_bh->b_data, header, new_bh->b_size);
+			mark_buffer_uptodate(new_bh, 1);
+			unlock_buffer(new_bh);
+			(void)ext3_xattr_cache_insert(new_bh);
+			ext3_xattr_update_super_block(handle, sb);
+		}
+		error = ext3_journal_dirty_metadata(handle, new_bh);
+		if (error)
+			goto cleanup;
+	}
+
+	/* Update the inode. */
+	EXT3_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;
+	inode->i_ctime = CURRENT_TIME;
+	ext3_mark_inode_dirty(handle, inode);
+	if (IS_SYNC(inode))
+		handle->h_sync = 1;
+
+	error = 0;
+	if (old_bh && old_bh != new_bh) {
+		/*
+		 * If there was an old block, and we are not still using it,
+		 * we now release the old block.
+		*/
+		unsigned int refcount = le32_to_cpu(HDR(old_bh)->h_refcount);
+
+		error = ext3_journal_get_write_access(handle, old_bh);
+		if (error)
+			goto cleanup;
+		if (refcount == 1) {
+			/* Free the old block. */
+			ea_bdebug(old_bh, "freeing");
+			ext3_xattr_free_block(handle, inode, old_bh->b_blocknr);
+
+			/* ext3_forget() calls bforget() for us, but we
+			   let our caller release old_bh, so we need to
+			   duplicate the handle before. */
+			get_bh(old_bh);
+			ext3_forget(handle, 1, inode, old_bh,old_bh->b_blocknr);
+		} else {
+			/* Decrement the refcount only. */
+			refcount--;
+			HDR(old_bh)->h_refcount = cpu_to_le32(refcount);
+			ext3_xattr_quota_free(inode);
+			ext3_journal_dirty_metadata(handle, old_bh);
+			ea_bdebug(old_bh, "refcount now=%d", refcount);
+		}
+	}
+
+cleanup:
+	if (old_bh != new_bh)
+		brelse(new_bh);
+
+	return error;
+}
+
+/*
+ * ext3_xattr_drop_inode()
+ *
+ * Free extended attribute resources associated with this inode. This
+ * is called immediately before an inode is freed.
+ */
+void
+ext3_xattr_drop_inode(handle_t *handle, struct inode *inode)
+{
+	struct buffer_head *bh;
+	unsigned int block = EXT3_I(inode)->i_file_acl;
+
+	if (!block)
+		return;
+	ext3_xattr_lock();
+
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh) {
+		ext3_error(inode->i_sb, "ext3_xattr_drop_inode",
+			"inode %ld: block %d read error", inode->i_ino, block);
+		goto cleanup;
+	}
+	ea_bdebug(bh, "b_count=%d", atomic_read(&(bh->b_count)));
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+		ext3_error(inode->i_sb, "ext3_xattr_drop_inode",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		goto cleanup;
+	}
+	ext3_journal_get_write_access(handle, bh);
+	ea_bdebug(bh, "refcount now=%d", le32_to_cpu(HDR(bh)->h_refcount) - 1);
+	if (HDR(bh)->h_refcount == cpu_to_le32(1)) {
+		ext3_xattr_cache_remove(bh);
+		ext3_xattr_free_block(handle, inode, block);
+		ext3_forget(handle, 1, inode, bh, block);
+		bh = NULL;
+	} else {
+		HDR(bh)->h_refcount = cpu_to_le32(
+			le32_to_cpu(HDR(bh)->h_refcount) - 1);
+		ext3_journal_dirty_metadata(handle, bh);
+		if (IS_SYNC(inode))
+			handle->h_sync = 1;
+		ext3_xattr_quota_free(inode);
+	}
+	EXT3_I(inode)->i_file_acl = 0;
+
+cleanup:
+	brelse(bh);
+	ext3_xattr_unlock();
+}
+
+/*
+ * ext3_xattr_put_super()
+ *
+ * This is called when a file system is unmounted.
+ */
+void
+ext3_xattr_put_super(struct super_block *sb)
+{
+#ifdef CONFIG_EXT3_FS_XATTR_SHARING
+	mb_cache_shrink(ext3_xattr_cache, sb->s_dev);
+#endif
+}
+
+#ifdef CONFIG_EXT3_FS_XATTR_SHARING
+
+/*
+ * ext3_xattr_cache_insert()
+ *
+ * Create a new entry in the extended attribute cache, and insert
+ * it unless such an entry is already in the cache.
+ *
+ * Returns 0, or a negative error number on failure.
+ */
+static int
+ext3_xattr_cache_insert(struct buffer_head *bh)
+{
+	__u32 hash = le32_to_cpu(HDR(bh)->h_hash);
+	struct mb_cache_entry *ce;
+	int error;
+
+	ce = mb_cache_entry_alloc(ext3_xattr_cache);
+	if (!ce)
+		return -ENOMEM;
+	error = mb_cache_entry_insert(ce, bh->b_dev, bh->b_blocknr, &hash);
+	if (error) {
+		mb_cache_entry_free(ce);
+		if (error == -EBUSY) {
+			ea_bdebug(bh, "already in cache (%d cache entries)",
+				atomic_read(&ext3_xattr_cache->c_entry_count));
+			error = 0;
+		}
+	} else {
+		ea_bdebug(bh, "inserting [%x] (%d cache entries)", (int)hash,
+			  atomic_read(&ext3_xattr_cache->c_entry_count));
+		mb_cache_entry_release(ce);
+	}
+	return error;
+}
+
+/*
+ * ext3_xattr_cmp()
+ *
+ * Compare two extended attribute blocks for equality.
+ *
+ * Returns 0 if the blocks are equal, 1 if they differ, and
+ * a negative error number on errors.
+ */
+static int
+ext3_xattr_cmp(struct ext3_xattr_header *header1,
+	       struct ext3_xattr_header *header2)
+{
+	struct ext3_xattr_entry *entry1, *entry2;
+
+	entry1 = ENTRY(header1+1);
+	entry2 = ENTRY(header2+1);
+	while (!IS_LAST_ENTRY(entry1)) {
+		if (IS_LAST_ENTRY(entry2))
+			return 1;
+		if (entry1->e_hash != entry2->e_hash ||
+		    entry1->e_name_len != entry2->e_name_len ||
+		    entry1->e_value_size != entry2->e_value_size ||
+		    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))
+			return 1;
+		if (entry1->e_value_block != 0 || entry2->e_value_block != 0)
+			return -EIO;
+		if (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),
+			   (char *)header2 + le16_to_cpu(entry2->e_value_offs),
+			   le32_to_cpu(entry1->e_value_size)))
+			return 1;
+
+		entry1 = EXT3_XATTR_NEXT(entry1);
+		entry2 = EXT3_XATTR_NEXT(entry2);
+	}
+	if (!IS_LAST_ENTRY(entry2))
+		return 1;
+	return 0;
+}
+
+/*
+ * ext3_xattr_cache_find()
+ *
+ * Find an identical extended attribute block.
+ *
+ * Returns a pointer to the block found, or NULL if such a block was
+ * not found or an error occurred.
+ */
+static struct buffer_head *
+ext3_xattr_cache_find(struct inode *inode, struct ext3_xattr_header *header)
+{
+	__u32 hash = le32_to_cpu(header->h_hash);
+	struct mb_cache_entry *ce;
+
+	if (!header->h_hash)
+		return NULL;  /* never share */
+	ea_idebug(inode, "looking for cached blocks [%x]", (int)hash);
+	ce = mb_cache_entry_find_first(ext3_xattr_cache, 0, inode->i_dev, hash);
+	while (ce) {
+		struct buffer_head *bh = sb_bread(inode->i_sb, ce->e_block);
+
+		if (!bh) {
+			ext3_error(inode->i_sb, "ext3_xattr_cache_find",
+				"inode %ld: block %ld read error",
+				inode->i_ino, ce->e_block);
+		} else if (le32_to_cpu(HDR(bh)->h_refcount) >
+			   EXT3_XATTR_REFCOUNT_MAX) {
+			ea_idebug(inode, "block %ld refcount %d>%d",ce->e_block,
+				le32_to_cpu(HDR(bh)->h_refcount),
+				EXT3_XATTR_REFCOUNT_MAX);
+		} else if (!ext3_xattr_cmp(header, HDR(bh))) {
+			ea_bdebug(bh, "b_count=%d",atomic_read(&(bh->b_count)));
+			mb_cache_entry_release(ce);
+			return bh;
+		}
+		brelse(bh);
+		ce = mb_cache_entry_find_next(ce, 0, inode->i_dev, hash);
+	}
+	return NULL;
+}
+
+/*
+ * ext3_xattr_cache_remove()
+ *
+ * Remove the cache entry of a block from the cache. Called when a
+ * block becomes invalid.
+ */
+static void
+ext3_xattr_cache_remove(struct buffer_head *bh)
+{
+	struct mb_cache_entry *ce;
+
+	ce = mb_cache_entry_get(ext3_xattr_cache, bh->b_dev, bh->b_blocknr);
+	if (ce) {
+		ea_bdebug(bh, "removing (%d cache entries remaining)",
+			  atomic_read(&ext3_xattr_cache->c_entry_count)-1);
+		mb_cache_entry_free(ce);
+	} else 
+		ea_bdebug(bh, "no cache entry");
+}
+
+#define NAME_HASH_SHIFT 5
+#define VALUE_HASH_SHIFT 16
+
+/*
+ * ext3_xattr_hash_entry()
+ *
+ * Compute the hash of an extended attribute.
+ */
+static inline void ext3_xattr_hash_entry(struct ext3_xattr_header *header,
+					 struct ext3_xattr_entry *entry)
+{
+	__u32 hash = 0;
+	char *name = entry->e_name;
+	int n;
+
+	for (n=0; n < entry->e_name_len; n++) {
+		hash = (hash << NAME_HASH_SHIFT) ^
+		       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^
+		       *name++;
+	}
+
+	if (entry->e_value_block == 0 && entry->e_value_size != 0) {
+		__u32 *value = (__u32 *)((char *)header +
+			le16_to_cpu(entry->e_value_offs));
+		for (n = (le32_to_cpu(entry->e_value_size) +
+		     EXT3_XATTR_ROUND) >> EXT3_XATTR_PAD_BITS; n; n--) {
+			hash = (hash << VALUE_HASH_SHIFT) ^
+			       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^
+			       le32_to_cpu(*value++);
+		}
+	}
+	entry->e_hash = cpu_to_le32(hash);
+}
+
+#undef NAME_HASH_SHIFT
+#undef VALUE_HASH_SHIFT
+
+#define BLOCK_HASH_SHIFT 16
+
+/*
+ * ext3_xattr_rehash()
+ *
+ * Re-compute the extended attribute hash value after an entry has changed.
+ */
+static void ext3_xattr_rehash(struct ext3_xattr_header *header,
+			      struct ext3_xattr_entry *entry)
+{
+	struct ext3_xattr_entry *here;
+	__u32 hash = 0;
+	
+	ext3_xattr_hash_entry(header, entry);
+	here = ENTRY(header+1);
+	while (!IS_LAST_ENTRY(here)) {
+		if (!here->e_hash) {
+			/* Block is not shared if an entry's hash value == 0 */
+			hash = 0;
+			break;
+		}
+		hash = (hash << BLOCK_HASH_SHIFT) ^
+		       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^
+		       le32_to_cpu(here->e_hash);
+		here = EXT3_XATTR_NEXT(here);
+	}
+	header->h_hash = cpu_to_le32(hash);
+}
+
+#undef BLOCK_HASH_SHIFT
+
+int __init
+init_ext3_xattr(void)
+{
+	ext3_xattr_cache = mb_cache_create("ext3_xattr", NULL,
+		sizeof(struct mb_cache_entry) +
+		sizeof(struct mb_cache_entry_index), 1, 61);
+	if (!ext3_xattr_cache)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void
+exit_ext3_xattr(void)
+{
+	if (ext3_xattr_cache)
+		mb_cache_destroy(ext3_xattr_cache);
+	ext3_xattr_cache = NULL;
+}
+
+#else  /* CONFIG_EXT3_FS_XATTR_SHARING */
+
+int __init
+init_ext3_xattr(void)
+{
+	return 0;
+}
+
+void
+exit_ext3_xattr(void)
+{
+}
+
+#endif  /* CONFIG_EXT3_FS_XATTR_SHARING */
--- linux-2.4.18-18/include/linux/ext3_fs.h~linux-2.4.18ea-0.8.26	Sat Apr  5 02:54:56 2003
+++ linux-2.4.18-18-braam/include/linux/ext3_fs.h	Sat Apr  5 03:03:06 2003
@@ -58,8 +58,6 @@
  */
 #define	EXT3_BAD_INO		 1	/* Bad blocks inode */
 #define EXT3_ROOT_INO		 2	/* Root inode */
-#define EXT3_ACL_IDX_INO	 3	/* ACL inode */
-#define EXT3_ACL_DATA_INO	 4	/* ACL inode */
 #define EXT3_BOOT_LOADER_INO	 5	/* Boot loader inode */
 #define EXT3_UNDEL_DIR_INO	 6	/* Undelete directory inode */
 #define EXT3_RESIZE_INO		 7	/* Reserved group descriptors inode */
@@ -89,7 +87,6 @@
 #else
 # define EXT3_BLOCK_SIZE(s)		(EXT3_MIN_BLOCK_SIZE << (s)->s_log_block_size)
 #endif
-#define EXT3_ACLE_PER_BLOCK(s)		(EXT3_BLOCK_SIZE(s) / sizeof (struct ext3_acl_entry))
 #define	EXT3_ADDR_PER_BLOCK(s)		(EXT3_BLOCK_SIZE(s) / sizeof (__u32))
 #ifdef __KERNEL__
 # define EXT3_BLOCK_SIZE_BITS(s)	((s)->s_blocksize_bits)
@@ -124,28 +121,6 @@
 #endif
 
 /*
- * ACL structures
- */
-struct ext3_acl_header	/* Header of Access Control Lists */
-{
-	__u32	aclh_size;
-	__u32	aclh_file_count;
-	__u32	aclh_acle_count;
-	__u32	aclh_first_acle;
-};
-
-struct ext3_acl_entry	/* Access Control List Entry */
-{
-	__u32	acle_size;
-	__u16	acle_perms;	/* Access permissions */
-	__u16	acle_type;	/* Type of entry */
-	__u16	acle_tag;	/* User or group identity */
-	__u16	acle_pad1;
-	__u32	acle_next;	/* Pointer on next entry for the */
-					/* same inode or on next free entry */
-};
-
-/*
  * Structure of a blocks group descriptor
  */
 struct ext3_group_desc
@@ -513,7 +488,7 @@ struct ext3_super_block {
 #define EXT3_FEATURE_INCOMPAT_RECOVER		0x0004 /* Needs recovery */
 #define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV	0x0008 /* Journal device */
 
-#define EXT3_FEATURE_COMPAT_SUPP	0
+#define EXT3_FEATURE_COMPAT_SUPP	EXT3_FEATURE_COMPAT_EXT_ATTR
 #define EXT3_FEATURE_INCOMPAT_SUPP	(EXT3_FEATURE_INCOMPAT_FILETYPE| \
 					 EXT3_FEATURE_INCOMPAT_RECOVER)
 #define EXT3_FEATURE_RO_COMPAT_SUPP	(EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER| \
@@ -606,6 +581,24 @@ struct ext3_iloc
 	unsigned long block_group;
 };
 
+/* Defined for extended attributes */
+#define CONFIG_EXT3_FS_XATTR y
+#ifndef ENOATTR
+#define ENOATTR ENODATA		/* No such attribute */
+#endif
+#ifndef ENOTSUP
+#define ENOTSUP EOPNOTSUPP	/* Operation not supported */
+#endif
+#ifndef XATTR_NAME_MAX
+#define XATTR_NAME_MAX   255	/* # chars in an extended attribute name */
+#define XATTR_SIZE_MAX 65536	/* size of an extended attribute value (64k) */
+#define XATTR_LIST_MAX 65536	/* size of extended attribute namelist (64k) */
+#endif
+#ifndef XATTR_CREATE
+#define XATTR_CREATE	1	/* set value, fail if attr already exists */
+#define XATTR_REPLACE	2	/* set value, fail if attr does not exist */
+#endif
+
 /*
  * Function prototypes
  */
@@ -647,6 +640,7 @@ extern void ext3_check_inodes_bitmap (st
 extern unsigned long ext3_count_free (struct buffer_head *, unsigned);
 
 /* inode.c */
+extern int ext3_forget(handle_t *, int, struct inode *, struct buffer_head *, int);
 extern struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);
 extern struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);
 
--- linux-2.4.18-18/include/linux/ext3_jbd.h~linux-2.4.18ea-0.8.26	Sat Apr  5 02:54:56 2003
+++ linux-2.4.18-18-braam/include/linux/ext3_jbd.h	Sat Apr  5 03:03:06 2003
@@ -30,13 +30,19 @@
 
 #define EXT3_SINGLEDATA_TRANS_BLOCKS	8
 
+/* Extended attributes may touch two data buffers, two bitmap buffers,
+ * and two group and summaries. */
+
+#define EXT3_XATTR_TRANS_BLOCKS		8
+
 /* Define the minimum size for a transaction which modifies data.  This
  * needs to take into account the fact that we may end up modifying two
  * quota files too (one for the group, one for the user quota).  The
  * superblock only gets updated once, of course, so don't bother
  * counting that again for the quota updates. */
 
-#define EXT3_DATA_TRANS_BLOCKS		(3 * EXT3_SINGLEDATA_TRANS_BLOCKS - 2)
+#define EXT3_DATA_TRANS_BLOCKS		(3 * EXT3_SINGLEDATA_TRANS_BLOCKS + \
+					 EXT3_XATTR_TRANS_BLOCKS - 2)
 
 extern int ext3_writepage_trans_blocks(struct inode *inode);
 
--- /dev/null	Fri Aug 30 17:31:37 2002
+++ linux-2.4.18-18-braam/include/linux/ext3_xattr.h	Sat Apr  5 02:54:56 2003
@@ -0,0 +1,155 @@
+/*
+  File: linux/ext3_xattr.h
+
+  On-disk format of extended attributes for the ext3 filesystem.
+
+  (C) 2001 Andreas Gruenbacher, <a.gruenbacher@computer.org>
+*/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/xattr.h>
+
+/* Magic value in attribute blocks */
+#define EXT3_XATTR_MAGIC		0xEA020000
+
+/* Maximum number of references to one attribute block */
+#define EXT3_XATTR_REFCOUNT_MAX		1024
+
+/* Name indexes */
+#define EXT3_XATTR_INDEX_MAX			10
+#define EXT3_XATTR_INDEX_USER			1
+
+struct ext3_xattr_header {
+	__u32	h_magic;	/* magic number for identification */
+	__u32	h_refcount;	/* reference count */
+	__u32	h_blocks;	/* number of disk blocks used */
+	__u32	h_hash;		/* hash value of all attributes */
+	__u32	h_reserved[4];	/* zero right now */
+};
+
+struct ext3_xattr_entry {
+	__u8	e_name_len;	/* length of name */
+	__u8	e_name_index;	/* attribute name index */
+	__u16	e_value_offs;	/* offset in disk block of value */
+	__u32	e_value_block;	/* disk block attribute is stored on (n/i) */
+	__u32	e_value_size;	/* size of attribute value */
+	__u32	e_hash;		/* hash value of name and value */
+	char	e_name[0];	/* attribute name */
+};
+
+#define EXT3_XATTR_PAD_BITS		2
+#define EXT3_XATTR_PAD		(1<<EXT3_XATTR_PAD_BITS)
+#define EXT3_XATTR_ROUND		(EXT3_XATTR_PAD-1)
+#define EXT3_XATTR_LEN(name_len) \
+	(((name_len) + EXT3_XATTR_ROUND + \
+	sizeof(struct ext3_xattr_entry)) & ~EXT3_XATTR_ROUND)
+#define EXT3_XATTR_NEXT(entry) \
+	( (struct ext3_xattr_entry *)( \
+	  (char *)(entry) + EXT3_XATTR_LEN((entry)->e_name_len)) )
+#define EXT3_XATTR_SIZE(size) \
+	(((size) + EXT3_XATTR_ROUND) & ~EXT3_XATTR_ROUND)
+
+#ifdef __KERNEL__
+
+# ifdef CONFIG_EXT3_FS_XATTR
+
+struct ext3_xattr_handler {
+	char *prefix;
+	size_t (*list)(char *list, struct inode *inode, const char *name,
+		       int name_len);
+	int (*get)(struct inode *inode, const char *name, void *buffer,
+		   size_t size);
+	int (*set)(struct inode *inode, const char *name, void *buffer,
+		   size_t size, int flags);
+};
+
+extern int ext3_xattr_register(int, struct ext3_xattr_handler *);
+extern void ext3_xattr_unregister(int, struct ext3_xattr_handler *);
+
+extern int ext3_setxattr(struct dentry *, const char *, void *, size_t, int);
+extern ssize_t ext3_getxattr(struct dentry *, const char *, void *, size_t);
+extern ssize_t ext3_listxattr(struct dentry *, char *, size_t);
+extern int ext3_removexattr(struct dentry *, const char *);
+
+extern int ext3_xattr_get(struct inode *, int, const char *, void *, size_t);
+extern int ext3_xattr_list(struct inode *, char *, size_t);
+extern int ext3_xattr_set(handle_t *handle, struct inode *, int, const char *, void *, size_t, int);
+
+extern void ext3_xattr_drop_inode(handle_t *, struct inode *);
+extern void ext3_xattr_put_super(struct super_block *);
+
+extern int init_ext3_xattr(void) __init;
+extern void exit_ext3_xattr(void);
+
+# else  /* CONFIG_EXT3_FS_XATTR */
+#  define ext3_setxattr		NULL
+#  define ext3_getxattr		NULL
+#  define ext3_listxattr	NULL
+#  define ext3_removexattr	NULL
+
+static inline int
+ext3_xattr_get(struct inode *inode, int name_index, const char *name,
+	       void *buffer, size_t size, int flags)
+{
+	return -ENOTSUP;
+}
+
+static inline int
+ext3_xattr_list(struct inode *inode, void *buffer, size_t size, int flags)
+{
+	return -ENOTSUP;
+}
+
+static inline int
+ext3_xattr_set(handle_t *handle, struct inode *inode, int name_index,
+	       const char *name, void *value, size_t size, int flags)
+{
+	return -ENOTSUP;
+}
+
+static inline void
+ext3_xattr_drop_inode(handle_t *handle, struct inode *inode)
+{
+}
+
+static inline void
+ext3_xattr_put_super(struct super_block *sb)
+{
+}
+
+static inline int
+init_ext3_xattr(void)
+{
+	return 0;
+}
+
+static inline void
+exit_ext3_xattr(void)
+{
+}
+
+# endif  /* CONFIG_EXT3_FS_XATTR */
+
+# ifdef CONFIG_EXT3_FS_XATTR_USER
+
+extern int init_ext3_xattr_user(void) __init;
+extern void exit_ext3_xattr_user(void);
+
+# else  /* CONFIG_EXT3_FS_XATTR_USER */
+
+static inline int
+init_ext3_xattr_user(void)
+{
+	return 0;
+}
+
+static inline void
+exit_ext3_xattr_user(void)
+{
+}
+
+#endif  /* CONFIG_EXT3_FS_XATTR_USER */
+
+#endif  /* __KERNEL__ */
+
--- /dev/null	Fri Aug 30 17:31:37 2002
+++ linux-2.4.18-18-braam/include/linux/xattr.h	Sat Apr  5 02:54:56 2003
@@ -0,0 +1,15 @@
+/*
+  File: linux/xattr.h
+
+  Extended attributes handling.
+
+  Copyright (C) 2001 by Andreas Gruenbacher <a.gruenbacher@computer.org>
+  Copyright (C) 2001 SGI - Silicon Graphics, Inc <linux-xfs@oss.sgi.com>
+*/
+#ifndef _LINUX_XATTR_H
+#define _LINUX_XATTR_H
+
+#define XATTR_CREATE	1	/* set value, fail if attr already exists */
+#define XATTR_REPLACE	2	/* set value, fail if attr does not exist */
+
+#endif	/* _LINUX_XATTR_H */

_
 fs/ext3/ialloc.c        |   20 ++++++++++----------
 fs/ext3/namei.c         |   16 ++++++++--------
 include/linux/ext3_fs.h |    2 +-
 3 files changed, 19 insertions(+), 19 deletions(-)

--- linux-2.4.20/fs/ext3/ialloc.c~ext3-2.4-ino_t	2003-04-08 23:35:24.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/ialloc.c	2003-04-08 23:35:24.000000000 -0600
@@ -65,8 +65,8 @@ static int read_inode_bitmap (struct sup
 	if (!bh) {
 		ext3_error (sb, "read_inode_bitmap",
 			    "Cannot read inode bitmap - "
-			    "block_group = %lu, inode_bitmap = %lu",
-			    block_group, (unsigned long) gdp->bg_inode_bitmap);
+			    "block_group = %lu, inode_bitmap = %u",
+			    block_group, gdp->bg_inode_bitmap);
 		retval = -EIO;
 	}
 	/*
@@ -533,19 +533,19 @@ out:
 }
 
 /* Verify that we are loading a valid orphan from disk */
-struct inode *ext3_orphan_get (struct super_block * sb, ino_t ino)
+struct inode *ext3_orphan_get(struct super_block *sb, unsigned long ino)
 {
-	ino_t max_ino = le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count);
+	unsigned long max_ino = le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count);
 	unsigned long block_group;
 	int bit;
 	int bitmap_nr;
 	struct buffer_head *bh;
 	struct inode *inode = NULL;
-	
+
 	/* Error cases - e2fsck has already cleaned up for us */
 	if (ino > max_ino) {
 		ext3_warning(sb, __FUNCTION__,
-			     "bad orphan ino %ld!  e2fsck was run?\n", ino);
+			     "bad orphan ino %lu!  e2fsck was run?\n", ino);
 		return NULL;
 	}
 
@@ -554,7 +554,7 @@ struct inode *ext3_orphan_get (struct su
 	if ((bitmap_nr = load_inode_bitmap(sb, block_group)) < 0 ||
 	    !(bh = EXT3_SB(sb)->s_inode_bitmap[bitmap_nr])) {
 		ext3_warning(sb, __FUNCTION__,
-			     "inode bitmap error for orphan %ld\n", ino);
+			     "inode bitmap error for orphan %lu\n", ino);
 		return NULL;
 	}
 
@@ -565,16 +565,16 @@ struct inode *ext3_orphan_get (struct su
 	if (!ext3_test_bit(bit, bh->b_data) || !(inode = iget(sb, ino)) ||
 	    is_bad_inode(inode) || NEXT_ORPHAN(inode) > max_ino) {
 		ext3_warning(sb, __FUNCTION__,
-			     "bad orphan inode %ld!  e2fsck was run?\n", ino);
+			     "bad orphan inode %lu!  e2fsck was run?\n", ino);
 		printk(KERN_NOTICE "ext3_test_bit(bit=%d, block=%ld) = %d\n",
 		       bit, bh->b_blocknr, ext3_test_bit(bit, bh->b_data));
 		printk(KERN_NOTICE "inode=%p\n", inode);
 		if (inode) {
 			printk(KERN_NOTICE "is_bad_inode(inode)=%d\n",
 			       is_bad_inode(inode));
-			printk(KERN_NOTICE "NEXT_ORPHAN(inode)=%d\n",
+			printk(KERN_NOTICE "NEXT_ORPHAN(inode)=%u\n",
 			       NEXT_ORPHAN(inode));
-			printk(KERN_NOTICE "max_ino=%ld\n", max_ino);
+			printk(KERN_NOTICE "max_ino=%lu\n", max_ino);
 		}
 		/* Avoid freeing blocks if we got a bad deleted inode */
 		if (inode && inode->i_nlink == 0)
--- linux-2.4.20/fs/ext3/namei.c~ext3-2.4-ino_t	2003-04-08 23:35:24.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/namei.c	2003-04-08 23:35:24.000000000 -0600
@@ -1808,10 +1808,10 @@ int ext3_orphan_del(handle_t *handle, st
 	struct list_head *prev;
 	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct ext3_sb_info *sbi;
-	ino_t ino_next; 
+	unsigned long ino_next;
 	struct ext3_iloc iloc;
 	int err = 0;
-	
+
 	lock_super(inode->i_sb);
 	if (list_empty(&ei->i_orphan)) {
 		unlock_super(inode->i_sb);
@@ -1822,7 +1822,7 @@ int ext3_orphan_del(handle_t *handle, st
 	prev = ei->i_orphan.prev;
 	sbi = EXT3_SB(inode->i_sb);
 
-	jbd_debug(4, "remove inode %ld from orphan list\n", inode->i_ino);
+	jbd_debug(4, "remove inode %lu from orphan list\n", inode->i_ino);
 
 	list_del(&ei->i_orphan);
 	INIT_LIST_HEAD(&ei->i_orphan);
@@ -1833,13 +1833,13 @@ int ext3_orphan_del(handle_t *handle, st
 	 * list in memory. */
 	if (!handle)
 		goto out;
-	
+
 	err = ext3_reserve_inode_write(handle, inode, &iloc);
 	if (err)
 		goto out_err;
 
 	if (prev == &sbi->s_orphan) {
-		jbd_debug(4, "superblock will point to %ld\n", ino_next);
+		jbd_debug(4, "superblock will point to %lu\n", ino_next);
 		BUFFER_TRACE(sbi->s_sbh, "get_write_access");
 		err = ext3_journal_get_write_access(handle, sbi->s_sbh);
 		if (err)
@@ -1850,8 +1850,8 @@ int ext3_orphan_del(handle_t *handle, st
 		struct ext3_iloc iloc2;
 		struct inode *i_prev =
 			list_entry(prev, struct inode, u.ext3_i.i_orphan);
-		
-		jbd_debug(4, "orphan inode %ld will point to %ld\n",
+
+		jbd_debug(4, "orphan inode %lu will point to %lu\n",
 			  i_prev->i_ino, ino_next);
 		err = ext3_reserve_inode_write(handle, i_prev, &iloc2);
 		if (err)
@@ -1866,7 +1866,7 @@ int ext3_orphan_del(handle_t *handle, st
 	if (err)
 		goto out_brelse;
 
-out_err: 	
+out_err: 
 	ext3_std_error(inode->i_sb, err);
 out:
 	unlock_super(inode->i_sb);
--- linux-2.4.20/include/linux/ext3_fs.h~ext3-2.4-ino_t	2003-04-08 23:35:24.000000000 -0600
+++ linux-2.4.20-braam/include/linux/ext3_fs.h	2003-04-08 23:35:24.000000000 -0600
@@ -673,7 +673,7 @@ extern int ext3fs_dirhash(const char *na
 /* ialloc.c */
 extern struct inode * ext3_new_inode (handle_t *, const struct inode *, int);
 extern void ext3_free_inode (handle_t *, struct inode *);
-extern struct inode * ext3_orphan_get (struct super_block *, ino_t);
+extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);
 extern unsigned long ext3_count_free_inodes (struct super_block *);
 extern void ext3_check_inodes_bitmap (struct super_block *);
 extern unsigned long ext3_count_free (struct buffer_head *, unsigned);

_
--- ./fs/ext3/balloc.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/balloc.c	Tue May  7 15:35:59 2002
@@ -46,18 +46,18 @@ struct ext3_group_desc * ext3_get_group_
 	unsigned long desc;
 	struct ext3_group_desc * gdp;
 
-	if (block_group >= sb->u.ext3_sb.s_groups_count) {
+	if (block_group >= EXT3_SB(sb)->s_groups_count) {
 		ext3_error (sb, "ext3_get_group_desc",
 			    "block_group >= groups_count - "
 			    "block_group = %d, groups_count = %lu",
-			    block_group, sb->u.ext3_sb.s_groups_count);
+			    block_group, EXT3_SB(sb)->s_groups_count);
 
 		return NULL;
 	}
 	
 	group_desc = block_group / EXT3_DESC_PER_BLOCK(sb);
 	desc = block_group % EXT3_DESC_PER_BLOCK(sb);
-	if (!sb->u.ext3_sb.s_group_desc[group_desc]) {
+	if (!EXT3_SB(sb)->s_group_desc[group_desc]) {
 		ext3_error (sb, "ext3_get_group_desc",
 			    "Group descriptor not loaded - "
 			    "block_group = %d, group_desc = %lu, desc = %lu",
@@ -66,9 +66,9 @@ struct ext3_group_desc * ext3_get_group_
 	}
 	
 	gdp = (struct ext3_group_desc *) 
-	      sb->u.ext3_sb.s_group_desc[group_desc]->b_data;
+	      EXT3_SB(sb)->s_group_desc[group_desc]->b_data;
 	if (bh)
-		*bh = sb->u.ext3_sb.s_group_desc[group_desc];
+		*bh = EXT3_SB(sb)->s_group_desc[group_desc];
 	return gdp + desc;
 }
 
@@ -104,8 +104,8 @@ static int read_block_bitmap (struct sup
 	 * this group.  The IO will be retried next time.
 	 */
 error_out:
-	sb->u.ext3_sb.s_block_bitmap_number[bitmap_nr] = block_group;
-	sb->u.ext3_sb.s_block_bitmap[bitmap_nr] = bh;
+	EXT3_SB(sb)->s_block_bitmap_number[bitmap_nr] = block_group;
+	EXT3_SB(sb)->s_block_bitmap[bitmap_nr] = bh;
 	return retval;
 }
 
@@ -128,16 +128,17 @@ static int __load_block_bitmap (struct s
 	int i, j, retval = 0;
 	unsigned long block_bitmap_number;
 	struct buffer_head * block_bitmap;
+	struct ext3_sb_info *sbi = EXT3_SB(sb);
 
-	if (block_group >= sb->u.ext3_sb.s_groups_count)
+	if (block_group >= sbi->s_groups_count)
 		ext3_panic (sb, "load_block_bitmap",
 			    "block_group >= groups_count - "
 			    "block_group = %d, groups_count = %lu",
-			    block_group, sb->u.ext3_sb.s_groups_count);
+			    block_group, EXT3_SB(sb)->s_groups_count);
 
-	if (sb->u.ext3_sb.s_groups_count <= EXT3_MAX_GROUP_LOADED) {
-		if (sb->u.ext3_sb.s_block_bitmap[block_group]) {
-			if (sb->u.ext3_sb.s_block_bitmap_number[block_group] ==
+	if (sbi->s_groups_count <= EXT3_MAX_GROUP_LOADED) {
+		if (sbi->s_block_bitmap[block_group]) {
+			if (sbi->s_block_bitmap_number[block_group] ==
 			    block_group)
 				return block_group;
 			ext3_error (sb, "__load_block_bitmap",
@@ -149,21 +150,20 @@ static int __load_block_bitmap (struct s
 		return block_group;
 	}
 
-	for (i = 0; i < sb->u.ext3_sb.s_loaded_block_bitmaps &&
-		    sb->u.ext3_sb.s_block_bitmap_number[i] != block_group; i++)
+	for (i = 0; i < sbi->s_loaded_block_bitmaps &&
+		    sbi->s_block_bitmap_number[i] != block_group; i++)
 		;
-	if (i < sb->u.ext3_sb.s_loaded_block_bitmaps &&
-  	    sb->u.ext3_sb.s_block_bitmap_number[i] == block_group) {
-		block_bitmap_number = sb->u.ext3_sb.s_block_bitmap_number[i];
-		block_bitmap = sb->u.ext3_sb.s_block_bitmap[i];
+	if (i < sbi->s_loaded_block_bitmaps &&
+  	    sbi->s_block_bitmap_number[i] == block_group) {
+		block_bitmap_number = sbi->s_block_bitmap_number[i];
+		block_bitmap = sbi->s_block_bitmap[i];
 		for (j = i; j > 0; j--) {
-			sb->u.ext3_sb.s_block_bitmap_number[j] =
-				sb->u.ext3_sb.s_block_bitmap_number[j - 1];
-			sb->u.ext3_sb.s_block_bitmap[j] =
-				sb->u.ext3_sb.s_block_bitmap[j - 1];
+			sbi->s_block_bitmap_number[j] =
+				sbi->s_block_bitmap_number[j - 1];
+			sbi->s_block_bitmap[j] = sbi->s_block_bitmap[j - 1];
 		}
-		sb->u.ext3_sb.s_block_bitmap_number[0] = block_bitmap_number;
-		sb->u.ext3_sb.s_block_bitmap[0] = block_bitmap;
+		sbi->s_block_bitmap_number[0] = block_bitmap_number;
+		sbi->s_block_bitmap[0] = block_bitmap;
 
 		/*
 		 * There's still one special case here --- if block_bitmap == 0
@@ -173,17 +173,14 @@ static int __load_block_bitmap (struct s
 		if (!block_bitmap)
 			retval = read_block_bitmap (sb, block_group, 0);
 	} else {
-		if (sb->u.ext3_sb.s_loaded_block_bitmaps<EXT3_MAX_GROUP_LOADED)
-			sb->u.ext3_sb.s_loaded_block_bitmaps++;
+		if (sbi->s_loaded_block_bitmaps<EXT3_MAX_GROUP_LOADED)
+			sbi->s_loaded_block_bitmaps++;
 		else
-			brelse (sb->u.ext3_sb.s_block_bitmap
-					[EXT3_MAX_GROUP_LOADED - 1]);
-		for (j = sb->u.ext3_sb.s_loaded_block_bitmaps - 1;
-					j > 0;  j--) {
-			sb->u.ext3_sb.s_block_bitmap_number[j] =
-				sb->u.ext3_sb.s_block_bitmap_number[j - 1];
-			sb->u.ext3_sb.s_block_bitmap[j] =
-				sb->u.ext3_sb.s_block_bitmap[j - 1];
+			brelse(sbi->s_block_bitmap[EXT3_MAX_GROUP_LOADED - 1]);
+		for (j = sbi->s_loaded_block_bitmaps - 1; j > 0;  j--) {
+			sbi->s_block_bitmap_number[j] =
+				sbi->s_block_bitmap_number[j - 1];
+			sbi->s_block_bitmap[j] = sbi->s_block_bitmap[j - 1];
 		}
 		retval = read_block_bitmap (sb, block_group, 0);
 	}
@@ -206,24 +203,25 @@ static int __load_block_bitmap (struct s
 static inline int load_block_bitmap (struct super_block * sb,
 				     unsigned int block_group)
 {
+	struct ext3_sb_info *sbi = EXT3_SB(sb);
 	int slot;
-	
+
 	/*
 	 * Do the lookup for the slot.  First of all, check if we're asking
 	 * for the same slot as last time, and did we succeed that last time?
 	 */
-	if (sb->u.ext3_sb.s_loaded_block_bitmaps > 0 &&
-	    sb->u.ext3_sb.s_block_bitmap_number[0] == block_group &&
-	    sb->u.ext3_sb.s_block_bitmap[0]) {
+	if (sbi->s_loaded_block_bitmaps > 0 &&
+	    sbi->s_block_bitmap_number[0] == block_group &&
+	    sbi->s_block_bitmap[0]) {
 		return 0;
 	}
 	/*
 	 * Or can we do a fast lookup based on a loaded group on a filesystem
 	 * small enough to be mapped directly into the superblock?
 	 */
-	else if (sb->u.ext3_sb.s_groups_count <= EXT3_MAX_GROUP_LOADED && 
-		 sb->u.ext3_sb.s_block_bitmap_number[block_group]==block_group
-			&& sb->u.ext3_sb.s_block_bitmap[block_group]) {
+	else if (sbi->s_groups_count <= EXT3_MAX_GROUP_LOADED &&
+		 sbi->s_block_bitmap_number[block_group] == block_group
+			&& sbi->s_block_bitmap[block_group]) {
 		slot = block_group;
 	}
 	/*
@@ -243,7 +241,7 @@ static inline int load_block_bitmap (str
 	 * If it's a valid slot, we may still have cached a previous IO error,
 	 * in which case the bh in the superblock cache will be zero.
 	 */
-	if (!sb->u.ext3_sb.s_block_bitmap[slot])
+	if (!sbi->s_block_bitmap[slot])
 		return -EIO;
 	
 	/*
@@ -275,7 +273,7 @@ void ext3_free_blocks (handle_t *handle,
 		return;
 	}
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
 	if (block < le32_to_cpu(es->s_first_data_block) ||
 	    block + count < block ||
 	    (block + count) > le32_to_cpu(es->s_blocks_count)) {
@@ -304,7 +302,7 @@ do_more:
 	if (bitmap_nr < 0)
 		goto error_return;
 	
-	bitmap_bh = sb->u.ext3_sb.s_block_bitmap[bitmap_nr];
+	bitmap_bh = EXT3_SB(sb)->s_block_bitmap[bitmap_nr];
 	gdp = ext3_get_group_desc (sb, block_group, &gd_bh);
 	if (!gdp)
 		goto error_return;
@@ -330,8 +328,8 @@ do_more:
 	if (err)
 		goto error_return;
 
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "get_write_access");
-	err = ext3_journal_get_write_access(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(EXT3_SB(sb)->s_sbh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);
 	if (err)
 		goto error_return;
 
@@ -341,7 +339,7 @@
 		if (block == le32_to_cpu(gdp->bg_block_bitmap) ||
 		    block == le32_to_cpu(gdp->bg_inode_bitmap) ||
 		    in_range(block, le32_to_cpu(gdp->bg_inode_table),
-			     sb->u.ext2_sb.s_itb_per_group)) {
+			     EXT3_SB(sb)->s_itb_per_group)) {
 			ext3_error(sb, __FUNCTION__,
 				   "Freeing block in system zone - block = %lu",
 				   block);
@@ -410,8 +407,8 @@ do_more:
 	if (!err) err = ret;
 
 	/* And the superblock */
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "dirtied superblock");
-	ret = ext3_journal_dirty_metadata(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(EXT3_SB(sb)->s_sbh, "dirtied superblock");
+	ret = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
 	if (!err) err = ret;
 
 	if (overflow && !err) {
@@ -564,12 +560,12 @@ int ext3_new_block (handle_t *handle, st
 	}
 
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
 	if (le32_to_cpu(es->s_free_blocks_count) <=
 			le32_to_cpu(es->s_r_blocks_count) &&
-	    ((sb->u.ext3_sb.s_resuid != current->fsuid) &&
-	     (sb->u.ext3_sb.s_resgid == 0 ||
-	      !in_group_p (sb->u.ext3_sb.s_resgid)) && 
+	    ((EXT3_SB(sb)->s_resuid != current->fsuid) &&
+	     (EXT3_SB(sb)->s_resgid == 0 ||
+	      !in_group_p (EXT3_SB(sb)->s_resgid)) &&
 	     !capable(CAP_SYS_RESOURCE)))
 		goto out;
 
@@ -598,7 +595,7 @@ int ext3_new_block (handle_t *handle, st
 		if (bitmap_nr < 0)
 			goto io_error;
 		
-		bh = sb->u.ext3_sb.s_block_bitmap[bitmap_nr];
+		bh = EXT3_SB(sb)->s_block_bitmap[bitmap_nr];
 
 		ext3_debug ("goal is at %d:%d.\n", i, j);
 
@@ -621,9 +618,9 @@ int ext3_new_block (handle_t *handle, st
 	 * Now search the rest of the groups.  We assume that 
 	 * i and gdp correctly point to the last group visited.
 	 */
-	for (k = 0; k < sb->u.ext3_sb.s_groups_count; k++) {
+	for (k = 0; k < EXT3_SB(sb)->s_groups_count; k++) {
 		i++;
-		if (i >= sb->u.ext3_sb.s_groups_count)
+		if (i >= EXT3_SB(sb)->s_groups_count)
 			i = 0;
 		gdp = ext3_get_group_desc (sb, i, &bh2);
 		if (!gdp) {
@@ -635,7 +632,7 @@ int ext3_new_block (handle_t *handle, st
 			if (bitmap_nr < 0)
 				goto io_error;
 	
-			bh = sb->u.ext3_sb.s_block_bitmap[bitmap_nr];
+			bh = EXT3_SB(sb)->s_block_bitmap[bitmap_nr];
 			j = find_next_usable_block(-1, bh, 
 						   EXT3_BLOCKS_PER_GROUP(sb));
 			if (j >= 0) 
@@ -674,8 +671,8 @@ got_block:
 	fatal = ext3_journal_get_write_access(handle, bh2);
 	if (fatal) goto out;
 
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "get_write_access");
-	fatal = ext3_journal_get_write_access(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(EXT3_SB(sb)->s_sbh, "get_write_access");
+	fatal = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);
 	if (fatal) goto out;
 
 	tmp = j + i * EXT3_BLOCKS_PER_GROUP(sb)
@@ -796,7 +804,7 @@ got_block:
 	if (!fatal) fatal = err;
 	
 	BUFFER_TRACE(bh, "journal_dirty_metadata for superblock");
-	err = ext3_journal_dirty_metadata(handle, sb->u.ext3_sb.s_sbh);
+	err = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
 	if (!fatal) fatal = err;
 
 	sb->s_dirt = 1;
@@ -829,11 +837,11 @@ unsigned long ext3_count_free_blocks (st
 	int i;
 	
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
 	desc_count = 0;
 	bitmap_count = 0;
 	gdp = NULL;
-	for (i = 0; i < sb->u.ext3_sb.s_groups_count; i++) {
+	for (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {
 		gdp = ext3_get_group_desc (sb, i, NULL);
 		if (!gdp)
 			continue;
@@ -842,7 +850,7 @@ unsigned long ext3_count_free_blocks (st
 		if (bitmap_nr < 0)
 			continue;
 		
-		x = ext3_count_free (sb->u.ext3_sb.s_block_bitmap[bitmap_nr],
+		x = ext3_count_free (EXT3_SB(sb)->s_block_bitmap[bitmap_nr],
 				     sb->s_blocksize);
 		printk ("group %d: stored = %d, counted = %lu\n",
 			i, le16_to_cpu(gdp->bg_free_blocks_count), x);
@@ -853,7 +861,7 @@ unsigned long ext3_count_free_blocks (st
 	unlock_super (sb);
 	return bitmap_count;
 #else
-	return le32_to_cpu(sb->u.ext3_sb.s_es->s_free_blocks_count);
+	return le32_to_cpu(EXT3_SB(sb)->s_es->s_free_blocks_count);
 #endif
 }
 
@@ -862,7 +870,7 @@ static inline int block_in_use (unsigned
 				unsigned char * map)
 {
 	return ext3_test_bit ((block -
-		le32_to_cpu(sb->u.ext3_sb.s_es->s_first_data_block)) %
+		le32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block)) %
 			 EXT3_BLOCKS_PER_GROUP(sb), map);
 }
 
@@ -930,11 +938,11 @@ void ext3_check_blocks_bitmap (struct su
 	struct ext3_group_desc * gdp;
 	int i;
 
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
 	desc_count = 0;
 	bitmap_count = 0;
 	gdp = NULL;
-	for (i = 0; i < sb->u.ext3_sb.s_groups_count; i++) {
+	for (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {
 		gdp = ext3_get_group_desc (sb, i, NULL);
 		if (!gdp)
 			continue;
@@ -968,7 +976,7 @@ void ext3_check_blocks_bitmap (struct su
 				    "Inode bitmap for group %d is marked free",
 				    i);
 
-		for (j = 0; j < sb->u.ext3_sb.s_itb_per_group; j++)
+		for (j = 0; j < EXT3_SB(sb)->s_itb_per_group; j++)
 			if (!block_in_use (le32_to_cpu(gdp->bg_inode_table) + j,
 							sb, bh->b_data))
 				ext3_error (sb, "ext3_check_blocks_bitmap",
--- ./fs/ext3/dir.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/dir.c	Tue May  7 14:54:13 2002
@@ -52,7 +52,7 @@ int ext3_check_dir_entry (const char * f
 	else if (((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)
 		error_msg = "directory entry across blocks";
 	else if (le32_to_cpu(de->inode) >
-			le32_to_cpu(dir->i_sb->u.ext3_sb.s_es->s_inodes_count))
+			le32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count))
 		error_msg = "inode out of bounds";
 
 	if (error_msg != NULL)
--- ./fs/ext3/ialloc.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/ialloc.c	Tue May  7 15:39:26 2002
@@ -73,8 +73,8 @@ static int read_inode_bitmap (struct sup
 	 * this group.  The IO will be retried next time.
 	 */
 error_out:
-	sb->u.ext3_sb.s_inode_bitmap_number[bitmap_nr] = block_group;
-	sb->u.ext3_sb.s_inode_bitmap[bitmap_nr] = bh;
+	EXT3_SB(sb)->s_inode_bitmap_number[bitmap_nr] = block_group;
+	EXT3_SB(sb)->s_inode_bitmap[bitmap_nr] = bh;
 	return retval;
 }
 
@@ -225,7 +225,7 @@ void ext3_free_inode (handle_t *handle, 
 	clear_inode (inode);
 
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
 	if (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {
 		ext3_error (sb, "ext3_free_inode",
 			    "reserved or nonexistent inode %lu", ino);
@@ -237,7 +237,7 @@ void ext3_free_inode (handle_t *handle, 
 	if (bitmap_nr < 0)
 		goto error_return;
 
-	bh = sb->u.ext3_sb.s_inode_bitmap[bitmap_nr];
+	bh = EXT3_SB(sb)->s_inode_bitmap[bitmap_nr];
 
 	BUFFER_TRACE(bh, "get_write_access");
 	fatal = ext3_journal_get_write_access(handle, bh);
@@ -255,8 +255,8 @@ void ext3_free_inode (handle_t *handle, 
 		fatal = ext3_journal_get_write_access(handle, bh2);
 		if (fatal) goto error_return;
 
-		BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "get write access");
-		fatal = ext3_journal_get_write_access(handle, sb->u.ext3_sb.s_sbh);
+		BUFFER_TRACE(EXT3_SB(sb)->s_sbh, "get write access");
+		fatal = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);
 		if (fatal) goto error_return;
 
 		if (gdp) {
@@ -271,9 +271,9 @@ void ext3_free_inode (handle_t *handle, 
 		if (!fatal) fatal = err;
 		es->s_free_inodes_count =
 			cpu_to_le32(le32_to_cpu(es->s_free_inodes_count) + 1);
-		BUFFER_TRACE(sb->u.ext3_sb.s_sbh,
+		BUFFER_TRACE(EXT3_SB(sb)->s_sbh,
 					"call ext3_journal_dirty_metadata");
-		err = ext3_journal_dirty_metadata(handle, sb->u.ext3_sb.s_sbh);
+		err = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
 		if (!fatal) fatal = err;
 	}
 	BUFFER_TRACE(bh, "call ext3_journal_dirty_metadata");
@@ -305,6 +305,8 @@ struct inode * ext3_new_inode (handle_t 
 	int i, j, avefreei;
 	struct inode * inode;
 	int bitmap_nr;
+	struct ext3_inode_info *ei;
+	struct ext3_sb_info *sbi;
 	struct ext3_group_desc * gdp;
 	struct ext3_group_desc * tmp;
 	struct ext3_super_block * es;
@@ -318,7 +320,9 @@ struct inode * ext3_new_inode (handle_t 
 	inode = new_inode(sb);
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
-	init_rwsem(&inode->u.ext3_i.truncate_sem);
+	sbi = EXT3_SB(sb);
+	ei = EXT3_I(inode);
+	init_rwsem(&ei->truncate_sem);
 
 	lock_super (sb);
 	es = sb->u.ext3_sb.s_es;
@@ -328,9 +332,9 @@ struct inode * ext3_new_inode (handle_t 
 
 	if (S_ISDIR(mode)) {
 		avefreei = le32_to_cpu(es->s_free_inodes_count) /
-			sb->u.ext3_sb.s_groups_count;
+			sbi->s_groups_count;
 		if (!gdp) {
-			for (j = 0; j < sb->u.ext3_sb.s_groups_count; j++) {
+			for (j = 0; j < sbi->s_groups_count; j++) {
 				struct buffer_head *temp_buffer;
 				tmp = ext3_get_group_desc (sb, j, &temp_buffer);
 				if (tmp &&
@@ -350,7 +354,7 @@ repeat:
 		/*
 		 * Try to place the inode in its parent directory
 		 */
-		i = dir->u.ext3_i.i_block_group;
+		i = EXT3_I(dir)->i_block_group;
 		tmp = ext3_get_group_desc (sb, i, &bh2);
 		if (tmp && le16_to_cpu(tmp->bg_free_inodes_count))
 			gdp = tmp;
@@ -360,10 +364,10 @@ repeat:
 			 * Use a quadratic hash to find a group with a
 			 * free inode
 			 */
-			for (j = 1; j < sb->u.ext3_sb.s_groups_count; j <<= 1) {
+			for (j = 1; j < sbi->s_groups_count; j <<= 1) {
 				i += j;
-				if (i >= sb->u.ext3_sb.s_groups_count)
-					i -= sb->u.ext3_sb.s_groups_count;
+				if (i >= sbi->s_groups_count)
+					i -= sbi->s_groups_count;
 				tmp = ext3_get_group_desc (sb, i, &bh2);
 				if (tmp &&
 				    le16_to_cpu(tmp->bg_free_inodes_count)) {
@@ -376,9 +380,9 @@ repeat:
 			/*
 			 * That failed: try linear search for a free inode
 			 */
-			i = dir->u.ext3_i.i_block_group + 1;
-			for (j = 2; j < sb->u.ext3_sb.s_groups_count; j++) {
-				if (++i >= sb->u.ext3_sb.s_groups_count)
+			i = EXT3_I(dir)->i_block_group + 1;
+			for (j = 2; j < sbi->s_groups_count; j++) {
+				if (++i >= sbi->s_groups_count)
 					i = 0;
 				tmp = ext3_get_group_desc (sb, i, &bh2);
 				if (tmp &&
@@ -399,11 +403,11 @@ repeat:
 	if (bitmap_nr < 0)
 		goto fail;
 
-	bh = sb->u.ext3_sb.s_inode_bitmap[bitmap_nr];
+	bh = sbi->s_inode_bitmap[bitmap_nr];
 
 	if ((j = ext3_find_first_zero_bit ((unsigned long *) bh->b_data,
-				      EXT3_INODES_PER_GROUP(sb))) <
-	    EXT3_INODES_PER_GROUP(sb)) {
+				      sbi->s_inodes_per_group)) <
+	    sbi->s_inodes_per_group) {
 		BUFFER_TRACE(bh, "get_write_access");
 		err = ext3_journal_get_write_access(handle, bh);
 		if (err) goto fail;
@@ -457,13 +461,13 @@ repeat:
 	err = ext3_journal_dirty_metadata(handle, bh2);
 	if (err) goto fail;
 	
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "get_write_access");
-	err = ext3_journal_get_write_access(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(sbi->s_sbh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, sbi->s_sbh);
 	if (err) goto fail;
 	es->s_free_inodes_count =
 		cpu_to_le32(le32_to_cpu(es->s_free_inodes_count) - 1);
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "call ext3_journal_dirty_metadata");
-	err = ext3_journal_dirty_metadata(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(sbi->s_sbh, "call ext3_journal_dirty_metadata");
+	err = ext3_journal_dirty_metadata(handle, sbi->s_sbh);
 	sb->s_dirt = 1;
 	if (err) goto fail;
 
@@ -483,31 +487,31 @@ repeat:
 	inode->i_blksize = PAGE_SIZE;
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
-	inode->u.ext3_i.i_flags = dir->u.ext3_i.i_flags & ~EXT3_INDEX_FL;
+	ei->i_flags = EXT3_I(dir)->i_flags & ~EXT3_INDEX_FL;
 	if (S_ISLNK(mode))
-		inode->u.ext3_i.i_flags &= ~(EXT3_IMMUTABLE_FL|EXT3_APPEND_FL);
+		ei->i_flags &= ~(EXT3_IMMUTABLE_FL|EXT3_APPEND_FL);
 #ifdef EXT3_FRAGMENTS
-	inode->u.ext3_i.i_faddr = 0;
-	inode->u.ext3_i.i_frag_no = 0;
-	inode->u.ext3_i.i_frag_size = 0;
+	ei->i_faddr = 0;
+	ei->i_frag_no = 0;
+	ei->i_frag_size = 0;
 #endif
-	inode->u.ext3_i.i_file_acl = 0;
-	inode->u.ext3_i.i_dir_acl = 0;
-	inode->u.ext3_i.i_dtime = 0;
-	INIT_LIST_HEAD(&inode->u.ext3_i.i_orphan);
+	ei->i_file_acl = 0;
+	ei->i_dir_acl = 0;
+	ei->i_dtime = 0;
+	INIT_LIST_HEAD(&ei->i_orphan);
 #ifdef EXT3_PREALLOCATE
-	inode->u.ext3_i.i_prealloc_count = 0;
+	ei->i_prealloc_count = 0;
 #endif
-	inode->u.ext3_i.i_block_group = i;
+	ei->i_block_group = i;
 	
-	if (inode->u.ext3_i.i_flags & EXT3_SYNC_FL)
+	if (ei->i_flags & EXT3_SYNC_FL)
 		inode->i_flags |= S_SYNC;
 	if (IS_SYNC(inode))
 		handle->h_sync = 1;
 	insert_inode_hash(inode);
-	inode->i_generation = sb->u.ext3_sb.s_next_generation++;
+	inode->i_generation = sbi->s_next_generation++;
 
-	inode->u.ext3_i.i_state = EXT3_STATE_NEW;
+	ei->i_state = EXT3_STATE_NEW;
 	err = ext3_mark_inode_dirty(handle, inode);
 	if (err) goto fail;
 	
@@ -585,19 +589,19 @@ struct inode *ext3_orphan_get (struct su
 
 unsigned long ext3_count_free_inodes (struct super_block * sb)
 {
+	struct ext3_sb_info *sbi = EXT3_SB(sb);
+	struct ext3_super_block *es = sbi->s_es;
 #ifdef EXT3FS_DEBUG
-	struct ext3_super_block * es;
 	unsigned long desc_count, bitmap_count, x;
 	int bitmap_nr;
 	struct ext3_group_desc * gdp;
 	int i;
 
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
 	desc_count = 0;
 	bitmap_count = 0;
 	gdp = NULL;
-	for (i = 0; i < sb->u.ext3_sb.s_groups_count; i++) {
+	for (i = 0; i < sbi->s_groups_count; i++) {
 		gdp = ext3_get_group_desc (sb, i, NULL);
 		if (!gdp)
 			continue;
@@ -606,8 +610,8 @@ unsigned long ext3_count_free_inodes (st
 		if (bitmap_nr < 0)
 			continue;
 
-		x = ext3_count_free (sb->u.ext3_sb.s_inode_bitmap[bitmap_nr],
-				     EXT3_INODES_PER_GROUP(sb) / 8);
+		x = ext3_count_free(sbi->s_inode_bitmap[bitmap_nr],
+				    sbi->s_inodes_per_group / 8);
 		printk ("group %d: stored = %d, counted = %lu\n",
 			i, le16_to_cpu(gdp->bg_free_inodes_count), x);
 		bitmap_count += x;
@@ -617,7 +621,7 @@ unsigned long ext3_count_free_inodes (st
 	unlock_super (sb);
 	return desc_count;
 #else
-	return le32_to_cpu(sb->u.ext3_sb.s_es->s_free_inodes_count);
+	return le32_to_cpu(es->s_free_inodes_count);
 #endif
 }
 
@@ -626,16 +630,18 @@ unsigned long ext3_count_free_inodes (st
 void ext3_check_inodes_bitmap (struct super_block * sb)
 {
 	struct ext3_super_block * es;
+	struct ext3_sb_info *sbi;
 	unsigned long desc_count, bitmap_count, x;
 	int bitmap_nr;
 	struct ext3_group_desc * gdp;
 	int i;
 
-	es = sb->u.ext3_sb.s_es;
+	sbi = EXT3_SB(sb);
+	es = sbi->s_es;
 	desc_count = 0;
 	bitmap_count = 0;
 	gdp = NULL;
-	for (i = 0; i < sb->u.ext3_sb.s_groups_count; i++) {
+	for (i = 0; i < sbi->s_groups_count; i++) {
 		gdp = ext3_get_group_desc (sb, i, NULL);
 		if (!gdp)
 			continue;
@@ -644,7 +650,7 @@ void ext3_check_inodes_bitmap (struct su
 		if (bitmap_nr < 0)
 			continue;
 
-		x = ext3_count_free (sb->u.ext3_sb.s_inode_bitmap[bitmap_nr],
+		x = ext3_count_free (sbi->s_inode_bitmap[bitmap_nr],
 				     EXT3_INODES_PER_GROUP(sb) / 8);
 		if (le16_to_cpu(gdp->bg_free_inodes_count) != x)
 			ext3_error (sb, "ext3_check_inodes_bitmap",
--- ./fs/ext3/inode.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/inode.c	Tue May  7 15:41:23 2002
@@ -196,7 +196,7 @@ void ext3_delete_inode (struct inode * i
 	 * (Well, we could do this if we need to, but heck - it works)
 	 */
 	ext3_orphan_del(handle, inode);
-	inode->u.ext3_i.i_dtime	= CURRENT_TIME;
+	EXT3_I(inode)->i_dtime = CURRENT_TIME;
 
 	/* 
 	 * One subtle ordering requirement: if anything has gone wrong
@@ -220,13 +220,14 @@ no_delete:
 void ext3_discard_prealloc (struct inode * inode)
 {
 #ifdef EXT3_PREALLOCATE
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	lock_kernel();
 	/* Writer: ->i_prealloc* */
-	if (inode->u.ext3_i.i_prealloc_count) {
-		unsigned short total = inode->u.ext3_i.i_prealloc_count;
-		unsigned long block = inode->u.ext3_i.i_prealloc_block;
-		inode->u.ext3_i.i_prealloc_count = 0;
-		inode->u.ext3_i.i_prealloc_block = 0;
+	if (ei->i_prealloc_count) {
+		unsigned short total = ei->i_prealloc_count;
+		unsigned long block = ei->i_prealloc_block;
+		ei->i_prealloc_count = 0;
+		ei->i_prealloc_block = 0;
 		/* Writer: end */
 		ext3_free_blocks (inode, block, total);
 	}
@@ -243,13 +244,15 @@ static int ext3_alloc_block (handle_t *h
 	unsigned long result;
 
 #ifdef EXT3_PREALLOCATE
+	struct ext3_inode_info *ei = EXT3_I(inode);
+
 	/* Writer: ->i_prealloc* */
-	if (inode->u.ext3_i.i_prealloc_count &&
-	    (goal == inode->u.ext3_i.i_prealloc_block ||
-	     goal + 1 == inode->u.ext3_i.i_prealloc_block))
+	if (ei->i_prealloc_count &&
+	    (goal == ei->i_prealloc_block ||
+	     goal + 1 == ei->i_prealloc_block))
 	{
-		result = inode->u.ext3_i.i_prealloc_block++;
-		inode->u.ext3_i.i_prealloc_count--;
+		result = ei->i_prealloc_block++;
+		ei->i_prealloc_count--;
 		/* Writer: end */
 		ext3_debug ("preallocation hit (%lu/%lu).\n",
 			    ++alloc_hits, ++alloc_attempts);
@@ -259,8 +262,8 @@ static int ext3_alloc_block (handle_t *h
 			    alloc_hits, ++alloc_attempts);
 		if (S_ISREG(inode->i_mode))
 			result = ext3_new_block (inode, goal, 
-				 &inode->u.ext3_i.i_prealloc_count,
-				 &inode->u.ext3_i.i_prealloc_block, err);
+				 &ei->i_prealloc_count,
+				 &ei->i_prealloc_block, err);
 		else
 			result = ext3_new_block (inode, goal, 0, 0, err);
 		/*
@@ -394,7 +397,7 @@ static Indirect *ext3_get_branch(struct 
 
 	*err = 0;
 	/* i_data is not going away, no lock needed */
-	add_chain (chain, NULL, inode->u.ext3_i.i_data + *offsets);
+	add_chain (chain, NULL, EXT3_I(inode)->i_data + *offsets);
 	if (!p->key)
 		goto no_block;
 	while (--depth) {
@@ -437,7 +440,8 @@ no_block:
 
 static inline unsigned long ext3_find_near(struct inode *inode, Indirect *ind)
 {
-	u32 *start = ind->bh ? (u32*) ind->bh->b_data : inode->u.ext3_i.i_data;
+	struct ext3_inode_info *ei = EXT3_I(inode);
+	u32 *start = ind->bh ? (u32*) ind->bh->b_data : ei->i_data;
 	u32 *p;
 
 	/* Try to find previous block */
@@ -453,9 +456,8 @@ static inline unsigned long ext3_find_ne
 	 * It is going to be refered from inode itself? OK, just put it into
 	 * the same cylinder group then.
 	 */
-	return (inode->u.ext3_i.i_block_group * 
-		EXT3_BLOCKS_PER_GROUP(inode->i_sb)) +
-	       le32_to_cpu(inode->i_sb->u.ext3_sb.s_es->s_first_data_block);
+	return (ei->i_block_group * EXT3_BLOCKS_PER_GROUP(inode->i_sb)) +
+	       le32_to_cpu(EXT3_SB(inode->i_sb)->s_es->s_first_data_block);
 }
 
 /**
@@ -474,14 +477,15 @@
 static int ext3_find_goal(struct inode *inode, long block, Indirect chain[4],
 			  Indirect *partial, unsigned long *goal)
 {
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	/* Writer: ->i_next_alloc* */
-	if (block == inode->u.ext3_i.i_next_alloc_block + 1) {
-		inode->u.ext3_i.i_next_alloc_block++;
-		inode->u.ext3_i.i_next_alloc_goal++;
+	if (block == ei->i_next_alloc_block + 1) {
+		ei->i_next_alloc_block++;
+		ei->i_next_alloc_goal++;
 	}
 #ifdef SEARCH_FROM_ZERO
-	inode->u.ext3_i.i_next_alloc_block = 0;
-	inode->u.ext3_i.i_next_alloc_goal = 0;
+	ei->i_next_alloc_block = 0;
+	ei->i_next_alloc_goal = 0;
 #endif
 	/* Writer: end */
 	/* Reader: pointers, ->i_next_alloc* */
@@ -490,8 +493,8 @@ static int ext3_find_goal(struct inode *
 		 * try the heuristic for sequential allocation,
 		 * failing that at least try to get decent locality.
 		 */
-		if (block == inode->u.ext3_i.i_next_alloc_block)
-			*goal = inode->u.ext3_i.i_next_alloc_goal;
+		if (block == ei->i_next_alloc_block)
+			*goal = ei->i_next_alloc_goal;
 		if (!*goal)
 			*goal = ext3_find_near(inode, partial);
 #ifdef SEARCH_FROM_ZERO
@@ -619,6 +621,7 @@
 {
 	int i;
 	int err = 0;
+	struct ext3_inode_info *ei = EXT3_I(inode);
 
 	/*
 	 * If we're splicing into a [td]indirect block (as opposed to the
@@ -641,11 +644,11 @@ static int ext3_splice_branch(handle_t *
 	/* That's it */
 
 	*where->p = where->key;
-	inode->u.ext3_i.i_next_alloc_block = block;
-	inode->u.ext3_i.i_next_alloc_goal = le32_to_cpu(where[num-1].key);
+	ei->i_next_alloc_block = block;
+	ei->i_next_alloc_goal = le32_to_cpu(where[num-1].key);
 #ifdef SEARCH_FROM_ZERO
-	inode->u.ext3_i.i_next_alloc_block = 0;
-	inode->u.ext3_i.i_next_alloc_goal = 0;
+	ei->i_next_alloc_block = 0;
+	ei->i_next_alloc_goal = 0;
 #endif
 	/* Writer: end */
 
@@ -729,6 +732,7 @@
 	unsigned long goal;
 	int left;
 	int depth = ext3_block_to_path(inode, iblock, offsets);
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	loff_t new_size;
 
 	J_ASSERT(handle != NULL || create == 0);
@@ -782,7 +785,7 @@ out:
 	/*
 	 * Block out ext3_truncate while we alter the tree
 	 */
-	down_read(&inode->u.ext3_i.truncate_sem);
+	down_read(&ei->truncate_sem);
 	err = ext3_alloc_branch(handle, inode, left, goal,
 					offsets+(partial-chain), partial);
 
@@ -794,7 +797,7 @@ out:
 	if (!err)
 		err = ext3_splice_branch(handle, inode, iblock, chain,
 					 partial, left);
-	up_read(&inode->u.ext3_i.truncate_sem);
+	up_read(&ei->truncate_sem);
 	if (err == -EAGAIN)
 		goto changed;
 	if (err)
@@ -807,8 +810,8 @@ out:
 	 * truncate is in progress.  It is racy between multiple parallel
 	 * instances of get_block, but we have the BKL.
 	 */
-	if (new_size > inode->u.ext3_i.i_disksize)
-		inode->u.ext3_i.i_disksize = new_size;
+	if (new_size > ei->i_disksize)
+		ei->i_disksize = new_size;
 
 	bh_result->b_state |= (1UL << BH_New);
 	goto got_it;
@@ -921,7 +924,7 @@ struct buffer_head *ext3_bread(handle_t 
 		struct buffer_head *tmp_bh;
 
 		for (i = 1;
-		     inode->u.ext3_i.i_prealloc_count &&
+		     EXT3_I(inode)->i_prealloc_count &&
 		     i < EXT3_SB(inode->i_sb)->s_es->s_prealloc_dir_blocks;
 		     i++) {
 			/*
@@ -1131,8 +1134,8 @@ static int ext3_commit_write(struct file
 			kunmap(page);
 		}
 	}
-	if (inode->i_size > inode->u.ext3_i.i_disksize) {
-		inode->u.ext3_i.i_disksize = inode->i_size;
+	if (inode->i_size > EXT3_I(inode)->i_disksize) {
+		EXT3_I(inode)->i_disksize = inode->i_size;
 		ret2 = ext3_mark_inode_dirty(handle, inode);
 		if (!ret) 
 			ret = ret2;
@@ -1832,7 +1835,8 @@ static void ext3_free_branches(handle_t 
 void ext3_truncate(struct inode * inode)
 {
 	handle_t *handle;
-	u32 *i_data = inode->u.ext3_i.i_data;
+	struct ext3_inode_info *ei = EXT3_I(inode);
+	u32 *i_data = EXT3_I(inode)->i_data;
 	int addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);
 	int offsets[4];
 	Indirect chain[4];
@@ -1884,13 +1887,13 @@ void ext3_truncate(struct inode * inode)
 	 * on-disk inode. We do this via i_disksize, which is the value which
 	 * ext3 *really* writes onto the disk inode.
 	 */
-	inode->u.ext3_i.i_disksize = inode->i_size;
+	ei->i_disksize = inode->i_size;
 
 	/*
 	 * From here we block out all ext3_get_block() callers who want to
 	 * modify the block allocation tree.
 	 */
-	down_write(&inode->u.ext3_i.truncate_sem);
+	down_write(&ei->truncate_sem);
 
 	if (n == 1) {		/* direct blocks */
 		ext3_free_data(handle, inode, NULL, i_data+offsets[0],
@@ -1954,7 +1957,7 @@ do_indirects:
 		case EXT3_TIND_BLOCK:
 			;
 	}
-	up_write(&inode->u.ext3_i.truncate_sem);
+	up_write(&ei->truncate_sem);
 	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 	ext3_mark_inode_dirty(handle, inode);
 
@@ -1983,6 +1986,8 @@ out_stop:
 
 int ext3_get_inode_loc (struct inode *inode, struct ext3_iloc *iloc)
 {
+	struct super_block *sb = inode->i_sb;
+	struct ext3_sb_info *sbi = EXT3_SB(sb);
 	struct buffer_head *bh = 0;
 	unsigned long block;
 	unsigned long block_group;
@@ -1997,23 +2010,19 @@ int ext3_get_inode_loc (struct inode *in
 		inode->i_ino != EXT3_JOURNAL_INO &&
-		inode->i_ino < EXT3_FIRST_INO(inode->i_sb)) ||
-		inode->i_ino > le32_to_cpu(
-			inode->i_sb->u.ext3_sb.s_es->s_inodes_count)) {
-		ext3_error (inode->i_sb, "ext3_get_inode_loc",
-			    "bad inode number: %lu", inode->i_ino);
+		inode->i_ino < EXT3_FIRST_INO(sb)) ||
+		inode->i_ino > le32_to_cpu(sbi->s_es->s_inodes_count)) {
+		ext3_error (sb, __FUNCTION__, "bad inode #%lu", inode->i_ino);
 		goto bad_inode;
 	}
-	block_group = (inode->i_ino - 1) / EXT3_INODES_PER_GROUP(inode->i_sb);
-	if (block_group >= inode->i_sb->u.ext3_sb.s_groups_count) {
-		ext3_error (inode->i_sb, "ext3_get_inode_loc",
-			    "group >= groups count");
+	block_group = (inode->i_ino - 1) / sbi->s_inodes_per_group;
+	if (block_group >= sbi->s_groups_count) {
+		ext3_error(sb, __FUNCTION__, "group >= groups count");
 		goto bad_inode;
 	}
-	group_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(inode->i_sb);
-	desc = block_group & (EXT3_DESC_PER_BLOCK(inode->i_sb) - 1);
-	bh = inode->i_sb->u.ext3_sb.s_group_desc[group_desc];
+	group_desc = block_group >> sbi->s_desc_per_block_bits;
+	desc = block_group & (sbi->s_desc_per_block - 1);
+	bh = sbi->s_group_desc[group_desc];
 	if (!bh) {
-		ext3_error (inode->i_sb, "ext3_get_inode_loc",
-			    "Descriptor not loaded");
+		ext3_error(sb, __FUNCTION__, "Descriptor not loaded");
 		goto bad_inode;
 	}
 
@@ -2021,17 +2022,17 @@ int ext3_get_inode_loc (struct inode *in
 	/*
 	 * Figure out the offset within the block group inode table
 	 */
-	offset = ((inode->i_ino - 1) % EXT3_INODES_PER_GROUP(inode->i_sb)) *
-		EXT3_INODE_SIZE(inode->i_sb);
+	offset = ((inode->i_ino - 1) % sbi->s_inodes_per_group) *
+		sbi->s_inode_size;
 	block = le32_to_cpu(gdp[desc].bg_inode_table) +
-		(offset >> EXT3_BLOCK_SIZE_BITS(inode->i_sb));
-	if (!(bh = sb_bread(inode->i_sb, block))) {
-		ext3_error (inode->i_sb, "ext3_get_inode_loc",
+		(offset >> EXT3_BLOCK_SIZE_BITS(sb));
+	if (!(bh = sb_bread(sb, block))) {
+		ext3_error (sb, __FUNCTION__,
 			    "unable to read inode block - "
 			    "inode=%lu, block=%lu", inode->i_ino, block);
 		goto bad_inode;
 	}
-	offset &= (EXT3_BLOCK_SIZE(inode->i_sb) - 1);
+	offset &= (EXT3_BLOCK_SIZE(sb) - 1);
 
 	iloc->bh = bh;
 	iloc->raw_inode = (struct ext3_inode *) (bh->b_data + offset);
@@ -2047,6 +2048,7 @@ void ext3_read_inode(struct inode * inod
 {
 	struct ext3_iloc iloc;
 	struct ext3_inode *raw_inode;
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct buffer_head *bh;
 	int block;
 	
@@ -2054,7 +2056,7 @@ void ext3_read_inode(struct inode * inod
 		goto bad_inode;
 	bh = iloc.bh;
 	raw_inode = iloc.raw_inode;
-	init_rwsem(&inode->u.ext3_i.truncate_sem);
+	init_rwsem(&ei->truncate_sem);
 	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
 	inode->i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
 	inode->i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
@@ -2067,7 +2069,7 @@ void ext3_read_inode(struct inode * inod
 	inode->i_atime = le32_to_cpu(raw_inode->i_atime);
 	inode->i_ctime = le32_to_cpu(raw_inode->i_ctime);
 	inode->i_mtime = le32_to_cpu(raw_inode->i_mtime);
-	inode->u.ext3_i.i_dtime = le32_to_cpu(raw_inode->i_dtime);
+	ei->i_dtime = le32_to_cpu(raw_inode->i_dtime);
 	/* We now have enough fields to check if the inode was active or not.
 	 * This is needed because nfsd might try to access dead inodes
 	 * the test is that same one that e2fsck uses
@@ -2075,7 +2077,7 @@ void ext3_read_inode(struct inode * inod
 	 */
 	if (inode->i_nlink == 0) {
 		if (inode->i_mode == 0 ||
-		    !(inode->i_sb->u.ext3_sb.s_mount_state & EXT3_ORPHAN_FS)) {
+		    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {
 			/* this inode is deleted */
 			brelse (bh);
 			goto bad_inode;
@@ -2090,33 +2092,33 @@ void ext3_read_inode(struct inode * inod
 					 * size */  
 	inode->i_blocks = le32_to_cpu(raw_inode->i_blocks);
 	inode->i_version = ++event;
-	inode->u.ext3_i.i_flags = le32_to_cpu(raw_inode->i_flags);
+	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
 #ifdef EXT3_FRAGMENTS
-	inode->u.ext3_i.i_faddr = le32_to_cpu(raw_inode->i_faddr);
-	inode->u.ext3_i.i_frag_no = raw_inode->i_frag;
-	inode->u.ext3_i.i_frag_size = raw_inode->i_fsize;
+	ei->i_faddr = le32_to_cpu(raw_inode->i_faddr);
+	ei->i_frag_no = raw_inode->i_frag;
+	ei->i_frag_size = raw_inode->i_fsize;
 #endif
-	inode->u.ext3_i.i_file_acl = le32_to_cpu(raw_inode->i_file_acl);
+	ei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);
 	if (!S_ISREG(inode->i_mode)) {
-		inode->u.ext3_i.i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);
+		ei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);
 	} else {
 		inode->i_size |=
 			((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;
 	}
-	inode->u.ext3_i.i_disksize = inode->i_size;
+	ei->i_disksize = inode->i_size;
 	inode->i_generation = le32_to_cpu(raw_inode->i_generation);
 #ifdef EXT3_PREALLOCATE
-	inode->u.ext3_i.i_prealloc_count = 0;
+	ei->i_prealloc_count = 0;
 #endif
-	inode->u.ext3_i.i_block_group = iloc.block_group;
+	ei->i_block_group = iloc.block_group;
 
 	/*
 	 * NOTE! The in-memory inode i_data array is in little-endian order
 	 * even on big-endian machines: we do NOT byteswap the block numbers!
 	 */
 	for (block = 0; block < EXT3_N_BLOCKS; block++)
-		inode->u.ext3_i.i_data[block] = iloc.raw_inode->i_block[block];
-	INIT_LIST_HEAD(&inode->u.ext3_i.i_orphan);
+		ei->i_data[block] = iloc.raw_inode->i_block[block];
+	INIT_LIST_HEAD(&ei->i_orphan);
 
 	brelse (iloc.bh);
 
@@ -2143,17 +2145,17 @@ void ext3_read_inode(struct inode * inod
 	/* inode->i_attr_flags = 0;				unused */
-	if (inode->u.ext3_i.i_flags & EXT3_SYNC_FL) {
+	if (ei->i_flags & EXT3_SYNC_FL) {
 		/* inode->i_attr_flags |= ATTR_FLAG_SYNCRONOUS; unused */
 		inode->i_flags |= S_SYNC;
 	}
-	if (inode->u.ext3_i.i_flags & EXT3_APPEND_FL) {
+	if (ei->i_flags & EXT3_APPEND_FL) {
 		/* inode->i_attr_flags |= ATTR_FLAG_APPEND;	unused */
 		inode->i_flags |= S_APPEND;
 	}
-	if (inode->u.ext3_i.i_flags & EXT3_IMMUTABLE_FL) {
+	if (ei->i_flags & EXT3_IMMUTABLE_FL) {
 		/* inode->i_attr_flags |= ATTR_FLAG_IMMUTABLE;	unused */
 		inode->i_flags |= S_IMMUTABLE;
 	}
-	if (inode->u.ext3_i.i_flags & EXT3_NOATIME_FL) {
+	if (ei->i_flags & EXT3_NOATIME_FL) {
 		/* inode->i_attr_flags |= ATTR_FLAG_NOATIME;	unused */
 		inode->i_flags |= S_NOATIME;
 	}
@@ -2175,6 +2177,7 @@ static int ext3_do_update_inode(handle_t
 				struct ext3_iloc *iloc)
 {
 	struct ext3_inode *raw_inode = iloc->raw_inode;
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct buffer_head *bh = iloc->bh;
 	int err = 0, rc, block;
 
@@ -2192,7 +2195,7 @@ static int ext3_do_update_inode(handle_t
  * Fix up interoperability with old kernels. Otherwise, old inodes get
  * re-used with the upper 16 bits of the uid/gid intact
  */
-		if(!inode->u.ext3_i.i_dtime) {
+		if(!ei->i_dtime) {
 			raw_inode->i_uid_high =
 				cpu_to_le16(high_16_bits(inode->i_uid));
 			raw_inode->i_gid_high =
@@ -2210,34 +2213,33 @@ static int ext3_do_update_inode(handle_t
 		raw_inode->i_gid_high = 0;
 	}
 	raw_inode->i_links_count = cpu_to_le16(inode->i_nlink);
-	raw_inode->i_size = cpu_to_le32(inode->u.ext3_i.i_disksize);
+	raw_inode->i_size = cpu_to_le32(ei->i_disksize);
 	raw_inode->i_atime = cpu_to_le32(inode->i_atime);
 	raw_inode->i_ctime = cpu_to_le32(inode->i_ctime);
 	raw_inode->i_mtime = cpu_to_le32(inode->i_mtime);
 	raw_inode->i_blocks = cpu_to_le32(inode->i_blocks);
-	raw_inode->i_dtime = cpu_to_le32(inode->u.ext3_i.i_dtime);
-	raw_inode->i_flags = cpu_to_le32(inode->u.ext3_i.i_flags);
+	raw_inode->i_dtime = cpu_to_le32(ei->i_dtime);
+	raw_inode->i_flags = cpu_to_le32(ei->i_flags);
 #ifdef EXT3_FRAGMENTS
-	raw_inode->i_faddr = cpu_to_le32(inode->u.ext3_i.i_faddr);
-	raw_inode->i_frag = inode->u.ext3_i.i_frag_no;
-	raw_inode->i_fsize = inode->u.ext3_i.i_frag_size;
+	raw_inode->i_faddr = cpu_to_le32(ei->i_faddr);
+	raw_inode->i_frag = ei->i_frag_no;
+	raw_inode->i_fsize = ei->i_frag_size;
 #else
 	/* If we are not tracking these fields in the in-memory inode,
 	 * then preserve them on disk, but still initialise them to zero
 	 * for new inodes. */
-	if (EXT3_I(inode)->i_state & EXT3_STATE_NEW) {
+	if (ei->i_state & EXT3_STATE_NEW) {
 		raw_inode->i_faddr = 0;
 		raw_inode->i_frag = 0;
 		raw_inode->i_fsize = 0;
 	}
 #endif
-	raw_inode->i_file_acl = cpu_to_le32(inode->u.ext3_i.i_file_acl);
+	raw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);
 	if (!S_ISREG(inode->i_mode)) {
-		raw_inode->i_dir_acl = cpu_to_le32(inode->u.ext3_i.i_dir_acl);
+		raw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);
 	} else {
-		raw_inode->i_size_high =
-			cpu_to_le32(inode->u.ext3_i.i_disksize >> 32);
-		if (inode->u.ext3_i.i_disksize > 0x7fffffffULL) {
+		raw_inode->i_size_high = cpu_to_le32(ei->i_disksize >> 32);
+		if (ei->i_disksize > MAX_NON_LFS) {
 			struct super_block *sb = inode->i_sb;
 			if (!EXT3_HAS_RO_COMPAT_FEATURE(sb,
 					EXT3_FEATURE_RO_COMPAT_LARGE_FILE) ||
@@ -2247,7 +2249,7 @@ static int ext3_do_update_inode(handle_t
 				* created, add a flag to the superblock.
 				*/
 				err = ext3_journal_get_write_access(handle,
-						sb->u.ext3_sb.s_sbh);
+						EXT3_SB(sb)->s_sbh);
 				if (err)
 					goto out_brelse;
 				ext3_update_dynamic_rev(sb);
@@ -2256,7 +2258,7 @@ static int ext3_do_update_inode(handle_t
 				sb->s_dirt = 1;
 				handle->h_sync = 1;
 				err = ext3_journal_dirty_metadata(handle,
-						sb->u.ext3_sb.s_sbh);
+						EXT3_SB(sb)->s_sbh);
 			}
 		}
 	}
@@ -2265,13 +2267,13 @@ static int ext3_do_update_inode(handle_t
 		raw_inode->i_block[0] =
 			cpu_to_le32(kdev_t_to_nr(inode->i_rdev));
 	else for (block = 0; block < EXT3_N_BLOCKS; block++)
-		raw_inode->i_block[block] = inode->u.ext3_i.i_data[block];
+		raw_inode->i_block[block] = ei->i_data[block];
 
 	BUFFER_TRACE(bh, "call ext3_journal_dirty_metadata");
 	rc = ext3_journal_dirty_metadata(handle, bh);
 	if (!err)
 		err = rc;
-	EXT3_I(inode)->i_state &= ~EXT3_STATE_NEW;
+	ei->i_state &= ~EXT3_STATE_NEW;
 
 out_brelse:
 	brelse (bh);
@@ -2379,7 +2381,7 @@ int ext3_setattr(struct dentry *dentry, 
 		}
 		
 		error = ext3_orphan_add(handle, inode);
-		inode->u.ext3_i.i_disksize = attr->ia_size;
+		EXT3_I(inode)->i_disksize = attr->ia_size;
 		rc = ext3_mark_inode_dirty(handle, inode);
 		if (!error)
 			error = rc;
@@ -2622,9 +2624,9 @@ int ext3_change_inode_journal_flag(struc
 	 */
 
 	if (val)
-		inode->u.ext3_i.i_flags |= EXT3_JOURNAL_DATA_FL;
+		EXT3_I(inode)->i_flags |= EXT3_JOURNAL_DATA_FL;
 	else
-		inode->u.ext3_i.i_flags &= ~EXT3_JOURNAL_DATA_FL;
+		EXT3_I(inode)->i_flags &= ~EXT3_JOURNAL_DATA_FL;
 
 	journal_unlock_updates(journal);
 
--- ./fs/ext3/ioctl.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/ioctl.c	Tue May  7 15:20:52 2002
@@ -18,13 +18,14 @@
 int ext3_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
 		unsigned long arg)
 {
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	unsigned int flags;
 
 	ext3_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
 	case EXT3_IOC_GETFLAGS:
-		flags = inode->u.ext3_i.i_flags & EXT3_FL_USER_VISIBLE;
+		flags = ei->i_flags & EXT3_FL_USER_VISIBLE;
 		return put_user(flags, (int *) arg);
 	case EXT3_IOC_SETFLAGS: {
 		handle_t *handle = NULL;
@@ -42,7 +42,7 @@ int ext3_ioctl (struct inode * inode, st
 		if (get_user(flags, (int *) arg))
 			return -EFAULT;
 
-		oldflags = inode->u.ext3_i.i_flags;
+		oldflags = ei->i_flags;
 
 		/* The JOURNAL_DATA flag is modifiable only by root */
 		jflag = flags & EXT3_JOURNAL_DATA_FL;
@@ -79,7 +79,7 @@ int ext3_ioctl (struct inode * inode, st
 		
 		flags = flags & EXT3_FL_USER_MODIFIABLE;
 		flags |= oldflags & ~EXT3_FL_USER_MODIFIABLE;
-		inode->u.ext3_i.i_flags = flags;
+		ei->i_flags = flags;
 
 		if (flags & EXT3_SYNC_FL)
 			inode->i_flags |= S_SYNC;
@@ -155,12 +155,12 @@ flags_err:
 			int ret = 0;
 
 			set_current_state(TASK_INTERRUPTIBLE);
-			add_wait_queue(&sb->u.ext3_sb.ro_wait_queue, &wait);
-			if (timer_pending(&sb->u.ext3_sb.turn_ro_timer)) {
+			add_wait_queue(&EXT3_SB(sb)->ro_wait_queue, &wait);
+			if (timer_pending(&EXT3_SB(sb)->turn_ro_timer)) {
 				schedule();
 				ret = 1;
 			}
-			remove_wait_queue(&sb->u.ext3_sb.ro_wait_queue, &wait);
+			remove_wait_queue(&EXT3_SB(sb)->ro_wait_queue, &wait);
 			return ret;
 		}
 #endif
--- ./fs/ext3/namei.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/namei.c	Tue May  7 16:05:51 2002
@@ -636,7 +636,7 @@ static struct buffer_head * ext3_find_en
 	}
 	
 	nblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);
-	start = dir->u.ext3_i.i_dir_start_lookup;
+	start = EXT3_I(dir)->i_dir_start_lookup;
 	if (start >= nblocks)
 		start = 0;
 	block = start;
@@ -677,7 +677,7 @@ restart:
 		i = search_dirblock(bh, dir, dentry,
 			    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);
 		if (i == 1) {
-			dir->u.ext3_i.i_dir_start_lookup = block;
+			EXT3_I(dir)->i_dir_start_lookup = block;
 			ret = bh;
 			goto cleanup_and_exit;
 		} else {
@@ -1419,7 +1419,7 @@ int ext3_orphan_add(handle_t *handle, st
 	int err = 0, rc;
 	
 	lock_super(sb);
-	if (!list_empty(&inode->u.ext3_i.i_orphan))
+	if (!list_empty(&EXT3_I(inode)->i_orphan))
 		goto out_unlock;
 
 	/* Orphan handling is only valid for files with data blocks
@@ -1430,8 +1430,8 @@ int ext3_orphan_add(handle_t *handle, st
 	J_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 		S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);
 
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "get_write_access");
-	err = ext3_journal_get_write_access(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(EXT3_SB(sb)->s_sbh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);
 	if (err)
 		goto out_unlock;
 	
@@ -1442,7 +1442,7 @@ int ext3_orphan_add(handle_t *handle, st
 	/* Insert this inode at the head of the on-disk orphan list... */
 	NEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);
 	EXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);
-	err = ext3_journal_dirty_metadata(handle, sb->u.ext3_sb.s_sbh);
+	err = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
 	rc = ext3_mark_iloc_dirty(handle, inode, &iloc);
 	if (!err)
 		err = rc;
@@ -1456,7 +1456,7 @@ int ext3_orphan_add(handle_t *handle, st
 	 * This is safe: on error we're going to ignore the orphan list
 	 * anyway on the next recovery. */
 	if (!err)
-		list_add(&inode->u.ext3_i.i_orphan, &EXT3_SB(sb)->s_orphan);
+		list_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);
 
 	jbd_debug(4, "superblock will point to %ld\n", inode->i_ino);
 	jbd_debug(4, "orphan inode %ld will point to %d\n",
@@ -714,25 +770,25 @@
 int ext3_orphan_del(handle_t *handle, struct inode *inode)
 {
 	struct list_head *prev;
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct ext3_sb_info *sbi;
 	unsigned long ino_next;
 	struct ext3_iloc iloc;
 	int err = 0;
 
 	lock_super(inode->i_sb);
-	if (list_empty(&inode->u.ext3_i.i_orphan)) {
+	if (list_empty(&ei->i_orphan)) {
 		unlock_super(inode->i_sb);
 		return 0;
 	}
 
 	ino_next = NEXT_ORPHAN(inode);
-	prev = inode->u.ext3_i.i_orphan.prev;
+	prev = ei->i_orphan.prev;
 	sbi = EXT3_SB(inode->i_sb);
 
 	jbd_debug(4, "remove inode %lu from orphan list\n", inode->i_ino);
 
-	list_del(&inode->u.ext3_i.i_orphan);
-	INIT_LIST_HEAD(&inode->u.ext3_i.i_orphan);
+	list_del_init(&ei->i_orphan);
 
 	/* If we're on an error path, we may not have a valid
 	 * transaction handle with which to update the orphan list on
@@ -1520,8 +1520,7 @@ int ext3_orphan_del(handle_t *handle, st
 		err = ext3_journal_dirty_metadata(handle, sbi->s_sbh);
 	} else {
 		struct ext3_iloc iloc2;
-		struct inode *i_prev =
-			list_entry(prev, struct inode, u.ext3_i.i_orphan);
+		struct inode *i_prev = orphan_list_entry(prev);
 
 		jbd_debug(4, "orphan inode %lu will point to %lu\n",
 			  i_prev->i_ino, ino_next);
@@ -1695,10 +1695,10 @@ static int ext3_symlink (struct inode * 
 			goto out_no_entry;
 	} else {
 		inode->i_op = &ext3_fast_symlink_inode_operations;
-		memcpy((char*)&inode->u.ext3_i.i_data,symname,l);
+		memcpy((char*)&EXT3_I(inode)->i_data,symname,l);
 		inode->i_size = l-1;
 	}
-	inode->u.ext3_i.i_disksize = inode->i_size;
+	EXT3_I(inode)->i_disksize = inode->i_size;
 	err = ext3_add_nondir(handle, dentry, inode);
 	ext3_mark_inode_dirty(handle, inode);
 out_stop:
--- ./fs/ext3/super.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/super.c	Tue May  7 16:05:44 2002
@@ -121,7 +121,7 @@ static int ext3_error_behaviour(struct s
 	/* If no overrides were specified on the mount, then fall back
 	 * to the default behaviour set in the filesystem's superblock
 	 * on disk. */
-	switch (le16_to_cpu(sb->u.ext3_sb.s_es->s_errors)) {
+	switch (le16_to_cpu(EXT3_SB(sb)->s_es->s_errors)) {
 	case EXT3_ERRORS_PANIC:
 		return EXT3_ERRORS_PANIC;
 	case EXT3_ERRORS_RO:
@@ -269,9 +269,9 @@ void ext3_abort (struct super_block * sb
 		return;
 	
 	printk (KERN_CRIT "Remounting filesystem read-only\n");
-	sb->u.ext3_sb.s_mount_state |= EXT3_ERROR_FS;
+	EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
 	sb->s_flags |= MS_RDONLY;
-	sb->u.ext3_sb.s_mount_opt |= EXT3_MOUNT_ABORT;
+	EXT3_SB(sb)->s_mount_opt |= EXT3_MOUNT_ABORT;
 	journal_abort(EXT3_SB(sb)->s_journal, -EIO);
 }
 
@@ -377,8 +377,6 @@ static int ext3_blkdev_remove(struct ext3
 	return ret;
 }
 
-#define orphan_list_entry(l) list_entry((l), struct inode, u.ext3_i.i_orphan)
-
 static void dump_orphan_list(struct super_block *sb, struct ext3_sb_info *sbi)
 {
 	struct list_head *l;
@@ -818,7 +818,7 @@ static void ext3_orphan_cleanup (struct 
 		sb->s_flags &= ~MS_RDONLY;
 	}
 
-	if (sb->u.ext3_sb.s_mount_state & EXT3_ERROR_FS) {
+	if (EXT3_SB(sb)->s_mount_state & EXT3_ERROR_FS) {
 		if (es->s_last_orphan)
 			jbd_debug(1, "Errors on filesystem, "
 				  "clearing orphan list.\n");
@@ -1463,12 +1463,14 @@ static void ext3_commit_super (struct su
 			       struct ext3_super_block * es,
 			       int sync)
 {
+	struct buffer_head *sbh = EXT3_SB(sb)->s_sbh;
+
 	es->s_wtime = cpu_to_le32(CURRENT_TIME);
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "marking dirty");
-	mark_buffer_dirty(sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(sbh, "marking dirty");
+	mark_buffer_dirty(sbh);
 	if (sync) {
-		ll_rw_block(WRITE, 1, &sb->u.ext3_sb.s_sbh);
-		wait_on_buffer(sb->u.ext3_sb.s_sbh);
+		ll_rw_block(WRITE, 1, &sbh);
+		wait_on_buffer(sbh);
 	}
 }
 
@@ -1519,7 +1521,7 @@ static void ext3_clear_journal_err(struc
 		ext3_warning(sb, __FUNCTION__, "Marking fs in need of "
 			     "filesystem check.");
 		
-		sb->u.ext3_sb.s_mount_state |= EXT3_ERROR_FS;
+		EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
 		es->s_state |= cpu_to_le16(EXT3_ERROR_FS);
 		ext3_commit_super (sb, es, 1);
 
--- ./fs/ext3/symlink.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/symlink.c	Tue May  7 15:25:39 2002
@@ -23,13 +23,13 @@
 
 static int ext3_readlink(struct dentry *dentry, char *buffer, int buflen)
 {
-	char *s = (char *)dentry->d_inode->u.ext3_i.i_data;
-	return vfs_readlink(dentry, buffer, buflen, s);
+	struct ext3_inode_info *ei = EXT3_I(dentry->d_inode);
+	return vfs_readlink(dentry, buffer, buflen, (char *)ei->i_data);
 }
 
 static int ext3_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	char *s = (char *)dentry->d_inode->u.ext3_i.i_data;
-	return vfs_follow_link(nd, s);
+	struct ext3_inode_info *ei = EXT3_I(dentry->d_inode);
+	return vfs_follow_link(nd, (char*)ei->i_data);
 }
 
--- ./include/linux/ext3_fs.h.orig	Tue Apr 16 14:27:25 2002
+++ ./include/linux/ext3_fs.h	Tue May  7 16:47:36 2002
@@ -84,22 +84,25 @@
 #define EXT3_MIN_BLOCK_SIZE		1024
 #define	EXT3_MAX_BLOCK_SIZE		4096
 #define EXT3_MIN_BLOCK_LOG_SIZE		  10
+
 #ifdef __KERNEL__
-# define EXT3_BLOCK_SIZE(s)		((s)->s_blocksize)
-#else
-# define EXT3_BLOCK_SIZE(s)		(EXT3_MIN_BLOCK_SIZE << (s)->s_log_block_size)
-#endif
-#define	EXT3_ADDR_PER_BLOCK(s)		(EXT3_BLOCK_SIZE(s) / sizeof (__u32))
-#ifdef __KERNEL__
-# define EXT3_BLOCK_SIZE_BITS(s)	((s)->s_blocksize_bits)
-#else
-# define EXT3_BLOCK_SIZE_BITS(s)	((s)->s_log_block_size + 10)
-#endif
-#ifdef __KERNEL__
-#define	EXT3_ADDR_PER_BLOCK_BITS(s)	((s)->u.ext3_sb.s_addr_per_block_bits)
-#define EXT3_INODE_SIZE(s)		((s)->u.ext3_sb.s_inode_size)
-#define EXT3_FIRST_INO(s)		((s)->u.ext3_sb.s_first_ino)
+#define EXT3_SB(sb)	(&((sb)->u.ext3_sb))
+#define EXT3_I(inode)	(&((inode)->u.ext3_i))
+
+#define EXT3_BLOCK_SIZE(s)		((s)->s_blocksize)
+#define EXT3_BLOCK_SIZE_BITS(s)		((s)->s_blocksize_bits)
+#define	EXT3_ADDR_PER_BLOCK_BITS(s)	(EXT3_SB(s)->s_addr_per_block_bits)
+#define EXT3_INODE_SIZE(s)		(EXT3_SB(s)->s_inode_size)
+#define EXT3_FIRST_INO(s)		(EXT3_SB(s)->s_first_ino)
 #else
+
+/* Assume that user mode programs are passing in an ext3fs superblock, not
+ * a kernel struct super_block.  This will allow us to call the feature-test
+ * macros from user land. */
+#define EXT3_SB(sb)	(sb)
+
+#define EXT3_BLOCK_SIZE(s)	(EXT3_MIN_BLOCK_SIZE << (s)->s_log_block_size)
+#define EXT3_BLOCK_SIZE_BITS(s)	((s)->s_log_block_size + 10)
 #define EXT3_INODE_SIZE(s)	(((s)->s_rev_level == EXT3_GOOD_OLD_REV) ? \
 				 EXT3_GOOD_OLD_INODE_SIZE : \
 				 (s)->s_inode_size)
@@ -108,6 +110,7 @@
 				 EXT3_GOOD_OLD_FIRST_INO : \
 				 (s)->s_first_ino)
 #endif
+#define EXT3_ADDR_PER_BLOCK(s)	(EXT3_BLOCK_SIZE(s) / sizeof (__u32))
 
 /*
  * Macro-instructions used to manage fragments
@@ -116,8 +120,8 @@
 #define	EXT3_MAX_FRAG_SIZE		4096
 #define EXT3_MIN_FRAG_LOG_SIZE		  10
 #ifdef __KERNEL__
-# define EXT3_FRAG_SIZE(s)		((s)->u.ext3_sb.s_frag_size)
-# define EXT3_FRAGS_PER_BLOCK(s)	((s)->u.ext3_sb.s_frags_per_block)
+# define EXT3_FRAG_SIZE(s)		(EXT3_SB(s)->s_frag_size)
+# define EXT3_FRAGS_PER_BLOCK(s)	(EXT3_SB(s)->s_frags_per_block)
 #else
 # define EXT3_FRAG_SIZE(s)		(EXT3_MIN_FRAG_SIZE << (s)->s_log_frag_size)
 # define EXT3_FRAGS_PER_BLOCK(s)	(EXT3_BLOCK_SIZE(s) / EXT3_FRAG_SIZE(s))
@@ -163,15 +167,13 @@
 /*
  * Macro-instructions used to manage group descriptors
  */
+# define EXT3_BLOCKS_PER_GROUP(s)	(EXT3_SB(s)->s_blocks_per_group)
+# define EXT3_INODES_PER_GROUP(s)	(EXT3_SB(s)->s_inodes_per_group)
 #ifdef __KERNEL__
-# define EXT3_BLOCKS_PER_GROUP(s)	((s)->u.ext3_sb.s_blocks_per_group)
-# define EXT3_DESC_PER_BLOCK(s)		((s)->u.ext3_sb.s_desc_per_block)
-# define EXT3_INODES_PER_GROUP(s)	((s)->u.ext3_sb.s_inodes_per_group)
-# define EXT3_DESC_PER_BLOCK_BITS(s)	((s)->u.ext3_sb.s_desc_per_block_bits)
+# define EXT3_DESC_PER_BLOCK(s)		(EXT3_SB(s)->s_desc_per_block)
+# define EXT3_DESC_PER_BLOCK_BITS(s)	(EXT3_SB(s)->s_desc_per_block_bits)
 #else
-# define EXT3_BLOCKS_PER_GROUP(s)	((s)->s_blocks_per_group)
 # define EXT3_DESC_PER_BLOCK(s)		(EXT3_BLOCK_SIZE(s) / sizeof (struct ext3_group_desc))
-# define EXT3_INODES_PER_GROUP(s)	((s)->s_inodes_per_group)
 #endif
 
 /*
@@ -344,7 +347,7 @@
 #ifndef _LINUX_EXT2_FS_H
 #define clear_opt(o, opt)		o &= ~EXT3_MOUNT_##opt
 #define set_opt(o, opt)			o |= EXT3_MOUNT_##opt
-#define test_opt(sb, opt)		((sb)->u.ext3_sb.s_mount_opt & \
+#define test_opt(sb, opt)		(EXT3_SB(sb)->s_mount_opt & \
 					 EXT3_MOUNT_##opt)
 #else
 #define EXT2_MOUNT_NOLOAD		EXT3_MOUNT_NOLOAD
@@ -441,17 +443,11 @@
 /*EC*/	__u32	s_reserved[197];	/* Padding to the end of the block */
 };
 
-#ifdef __KERNEL__
-#define EXT3_SB(sb)	(&((sb)->u.ext3_sb))
-#define EXT3_I(inode)	(&((inode)->u.ext3_i))
-#else
-/* Assume that user mode programs are passing in an ext3fs superblock, not
- * a kernel struct super_block.  This will allow us to call the feature-test
- * macros from user land. */
-#define EXT3_SB(sb)	(sb)
-#endif
-
-#define NEXT_ORPHAN(inode) (inode)->u.ext3_i.i_dtime
+#define NEXT_ORPHAN(inode) EXT3_I(inode)->i_dtime
+static inline struct inode *orphan_list_entry(struct list_head *l)
+{
+	return list_entry(l, struct inode, u.ext3_i.i_orphan);
+}
 
 /*
  * Codes for operating systems
--- ./include/linux/ext3_jbd.h.orig	Tue May  7 14:44:08 2002
+++ ./include/linux/ext3_jbd.h	Tue May  7 14:44:43 2002
@@ -291,7 +291,7 @@
 		return 1;
 	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)
 		return 1;
-	if (inode->u.ext3_i.i_flags & EXT3_JOURNAL_DATA_FL)
+	if (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)
 		return 1;
 	return 0;
 }
--- linux-2.4.17/fs/ext3/super.c.orig	Fri Dec 21 10:41:55 2001
+++ linux-2.4.17/fs/ext3/super.c	Fri Mar 22 11:00:41 2002
@@ -1344,10 +1342,10 @@
 		printk(KERN_ERR "EXT3-fs: I/O error on journal device\n");
 		goto out_journal;
 	}
-	if (ntohl(journal->j_superblock->s_nr_users) != 1) {
+	if (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {
 		printk(KERN_ERR "EXT3-fs: External journal has more than one "
 					"user (unsupported) - %d\n",
-			ntohl(journal->j_superblock->s_nr_users));
+			be32_to_cpu(journal->j_superblock->s_nr_users));
 		goto out_journal;
 	}
 	EXT3_SB(sb)->journal_bdev = bdev;
@@ -1560,6 +1560,7 @@
 	unlock_kernel();
 	return ret;
 }
+EXPORT_SYMBOL(ext3_force_commit); /* here to avoid potential patch collisions */
 
 /*
  * Ext3 always journals updates to the superblock itself, so we don't
diff -ru lustre-head/fs/ext3/ialloc.c lustre/fs/ext3/ialloc.c
--- lustre-head/fs/ext3/ialloc.c	Mon Dec 23 10:02:58 2002
+++ lustre/fs/ext3/ialloc.c	Mon Dec 23 09:46:20 2002
@@ -289,6 +289,37 @@
 }
 
 /*
+ * @block_group: block group of inode
+ * @offset: relative offset of inode within @block_group
+ *
+ * Check whether any of the inodes in this disk block are in use.
+ *
+ * Caller must be holding superblock lock (group/bitmap read lock in future).
+ */
+int ext3_itable_block_used(struct super_block *sb, unsigned int block_group,
+			   int offset)
+{
+	int bitmap_nr = load_inode_bitmap(sb, block_group);
+	int inodes_per_block;
+	unsigned long inum, iend;
+	struct buffer_head *ibitmap;
+
+	if (bitmap_nr < 0)
+		return 1;
+
+	inodes_per_block = sb->s_blocksize / EXT3_SB(sb)->s_inode_size;
+	inum = offset & ~(inodes_per_block - 1);
+	iend = inum + inodes_per_block;
+	ibitmap = EXT3_SB(sb)->s_inode_bitmap[bitmap_nr];
+	for (; inum < iend; inum++) {
+		if (inum != offset && ext3_test_bit(inum, ibitmap->b_data))
+			return 1;
+	}
+
+	return 0;
+}
+
+/*
  * There are two policies for allocating an inode.  If the new inode is
  * a directory, then a forward search is made for a block group with both
  * free space and a low directory-to-inode ratio; if that fails, then of
@@ -312,6 +343,7 @@
 	struct ext3_group_desc * gdp;
 	struct ext3_group_desc * tmp;
 	struct ext3_super_block * es;
+	struct ext3_iloc iloc;
 	int err = 0;
 
 	/* Cannot create files in a deleted directory */
@@ -505,7 +538,7 @@
 	ei->i_prealloc_count = 0;
 #endif
 	ei->i_block_group = i;
-	
+
 	if (ei->i_flags & EXT3_SYNC_FL)
 		inode->i_flags |= S_SYNC;
 	if (IS_SYNC(inode))
@@ -514,9 +547,18 @@
 	inode->i_generation = sbi->s_next_generation++;
 
 	ei->i_state = EXT3_STATE_NEW;
-	err = ext3_mark_inode_dirty(handle, inode);
+	err = ext3_get_inode_loc_new(inode, &iloc, 1);
 	if (err) goto fail;
-	
+	BUFFER_TRACE(iloc->bh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, iloc.bh);
+	if (err) {
+		brelse(iloc.bh);
+		iloc.bh = NULL;
+		goto fail;
+	}
+	err = ext3_mark_iloc_dirty(handle, inode, &iloc);
+	if (err) goto fail;
+
 	unlock_super (sb);
 	if(DQUOT_ALLOC_INODE(inode)) {
 		DQUOT_DROP(inode);
diff -ru lustre-head/fs/ext3/inode.c lustre/fs/ext3/inode.c
--- lustre-head/fs/ext3/inode.c	Mon Dec 23 10:02:58 2002
+++ lustre/fs/ext3/inode.c	Mon Dec 23 09:50:25 2002
@@ -2011,23 +1994,28 @@
 	ext3_journal_stop(handle, inode);
 }
 
-/* 
- * ext3_get_inode_loc returns with an extra refcount against the
- * inode's underlying buffer_head on success. 
- */
+#define NUM_INODE_PREREAD	16
 
-int ext3_get_inode_loc (struct inode *inode, struct ext3_iloc *iloc)
+/*
+ * ext3_get_inode_loc returns with an extra refcount against the inode's
+ * underlying buffer_head on success.  If this is for a new inode allocation
+ * (new is non-zero) then we may be able to optimize away the read if there
+ * are no other in-use inodes in this inode table block.  If we need to do
+ * a read, then read in a whole chunk of blocks to avoid blocking again soon
+ * if we are doing lots of creates/updates.
+ */
+int ext3_get_inode_loc_new(struct inode *inode, struct ext3_iloc *iloc, int new)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ext3_sb_info *sbi = EXT3_SB(sb);
-	struct buffer_head *bh = 0;
+	struct buffer_head *bh[NUM_INODE_PREREAD];
 	unsigned long block;
 	unsigned long block_group;
 	unsigned long group_desc;
 	unsigned long desc;
 	unsigned long offset;
 	struct ext3_group_desc * gdp;
-		
+
 	if ((inode->i_ino != EXT3_ROOT_INO &&
 		inode->i_ino != EXT3_JOURNAL_INO &&
 		inode->i_ino < EXT3_FIRST_INO(sb)) ||
@@ -2042,38 +2034,86 @@
 	}
 	group_desc = block_group >> sbi->s_desc_per_block_bits;
 	desc = block_group & (sbi->s_desc_per_block - 1);
-	bh = sbi->s_group_desc[group_desc];
-	if (!bh) {
+	if (!sbi->s_group_desc[group_desc]) {
 		ext3_error(sb, __FUNCTION__, "Descriptor not loaded");
 		goto bad_inode;
 	}
 
-	gdp = (struct ext3_group_desc *) bh->b_data;
+	gdp = (struct ext3_group_desc *)(sbi->s_group_desc[group_desc]->b_data);
+
 	/*
 	 * Figure out the offset within the block group inode table
 	 */
-	offset = ((inode->i_ino - 1) % sbi->s_inodes_per_group) *
-		sbi->s_inode_size;
+	offset = ((inode->i_ino - 1) % sbi->s_inodes_per_group);
+
 	block = le32_to_cpu(gdp[desc].bg_inode_table) +
-		(offset >> EXT3_BLOCK_SIZE_BITS(sb));
-	if (!(bh = sb_bread(sb, block))) {
-		ext3_error (sb, __FUNCTION__,
-			    "unable to read inode block - "
-			    "inode=%lu, block=%lu", inode->i_ino, block);
-		goto bad_inode;
+		(offset * sbi->s_inode_size >> EXT3_BLOCK_SIZE_BITS(sb));
+
+	bh[0] = sb_getblk(sb, block);
+	if (buffer_uptodate(bh[0]))
+		goto done;
+
+	/* If we don't really need to read this block, and it isn't already
+	 * in memory, then we just zero it out.  Otherwise, we keep the
+	 * current block contents (deleted inode data) for posterity.
+	 */
+	if (new && !ext3_itable_block_used(sb, block_group, offset)) {
+		lock_buffer(bh[0]);
+		memset(bh[0]->b_data, 0, bh[0]->b_size);
+		mark_buffer_uptodate(bh[0], 1);
+		unlock_buffer(bh[0]);
+	} else {
+		unsigned long block_end, itable_end;
+		int count = 1;
+
+		itable_end = le32_to_cpu(gdp[desc].bg_inode_table) +
+				sbi->s_itb_per_group;
+		block_end = block + NUM_INODE_PREREAD;
+		if (block_end > itable_end)
+			block_end = itable_end;
+
+		for (; block < block_end; block++) {
+			bh[count] = sb_getblk(sb, block);
+			if (count && (buffer_uptodate(bh[count]) ||
+				      buffer_locked(bh[count]))) {
+				__brelse(bh[count]);
+			} else
+				count++;
+		}
+
+		ll_rw_block(READ, count, bh);
+
+		/* Release all but the block we actually need (bh[0]) */
+		while (--count > 0)
+			__brelse(bh[count]);
+
+		wait_on_buffer(bh[0]);
+		if (!buffer_uptodate(bh[0])) {
+			ext3_error(sb, __FUNCTION__,
+				   "unable to read inode block - "
+				   "inode=%lu, block=%lu", inode->i_ino,
+				   bh[0]->b_blocknr);
+			goto bad_inode;
+		}
 	}
-	offset &= (EXT3_BLOCK_SIZE(sb) - 1);
+ done:
+	offset = (offset * sbi->s_inode_size) & (EXT3_BLOCK_SIZE(sb) - 1);
 
-	iloc->bh = bh;
-	iloc->raw_inode = (struct ext3_inode *) (bh->b_data + offset);
+	iloc->bh = bh[0];
+	iloc->raw_inode = (struct ext3_inode *)(bh[0]->b_data + offset);
 	iloc->block_group = block_group;
-	
+
 	return 0;
-	
+
  bad_inode:
 	return -EIO;
 }
 
+int ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)
+{
+	return ext3_get_inode_loc_new(inode, iloc, 0);
+}
+
 void ext3_read_inode(struct inode * inode)
 {
 	struct ext3_iloc iloc;
diff -ru include/linux/ext3_fs.h.orig include/linux/ext3_fs.h
--- lustre/include/linux/ext3_fs.h.orig	Sat Mar  8 01:23:09 2003
+++ lustre/include/linux/ext3_fs.h	Sat Mar  8 01:24:31 2003
@@ -642,6 +646,8 @@
 extern struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);
 extern struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);
 
+extern int ext3_itable_block_used(struct super_block *sb, unsigned int, int);
+extern int ext3_get_inode_loc_new(struct inode *, struct ext3_iloc *, int);
 extern int  ext3_get_inode_loc (struct inode *, struct ext3_iloc *);
 extern void ext3_read_inode (struct inode *);
 extern void ext3_write_inode (struct inode *, int);
 fs/ext3/ialloc.c        |   38 ++++++++++++++++++++++++++++++++++++--
 fs/ext3/ioctl.c         |   25 +++++++++++++++++++++++++
 fs/ext3/namei.c         |   12 ++++++++----
 include/linux/ext3_fs.h |    5 ++++-
 4 files changed, 73 insertions(+), 7 deletions(-)

--- linux-2.4.20/fs/ext3/namei.c~extN-wantedi	2003-04-08 23:35:55.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/namei.c	2003-04-08 23:35:55.000000000 -0600
@@ -1555,7 +1555,8 @@ static int ext3_create (struct inode * d
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, mode);
+	inode = ext3_new_inode (handle, dir, mode,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (!IS_ERR(inode)) {
 		inode->i_op = &ext3_file_inode_operations;
@@ -1583,7 +1584,8 @@ static int ext3_mknod (struct inode * di
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, mode);
+	inode = ext3_new_inode (handle, dir, mode,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (!IS_ERR(inode)) {
 		init_special_inode(inode, mode, rdev);
@@ -1613,7 +1615,8 @@ static int ext3_mkdir(struct inode * dir
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, S_IFDIR | mode);
+	inode = ext3_new_inode (handle, dir, S_IFDIR | mode,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_stop;
@@ -2009,7 +2012,8 @@ static int ext3_symlink (struct inode * 
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, S_IFLNK|S_IRWXUGO);
+	inode = ext3_new_inode (handle, dir, S_IFLNK|S_IRWXUGO,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_stop;
--- linux-2.4.20/fs/ext3/ialloc.c~extN-wantedi	2003-04-08 23:35:55.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/ialloc.c	2003-04-08 23:35:55.000000000 -0600
@@ -299,7 +299,8 @@ error_return:
  * group to find a free inode.
  */
 struct inode * ext3_new_inode (handle_t *handle,
-				const struct inode * dir, int mode)
+				const struct inode * dir, int mode,
+                               unsigned long goal)
 {
 	struct super_block * sb;
 	struct buffer_head * bh;
@@ -323,7 +324,39 @@ struct inode * ext3_new_inode (handle_t 
 	init_rwsem(&inode->u.ext3_i.truncate_sem);
 
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
+ 
+ 	if (goal) {
+ 		i = (goal - 1) / EXT3_INODES_PER_GROUP(sb);
+ 		j = (goal - 1) % EXT3_INODES_PER_GROUP(sb);
+ 		gdp = ext3_get_group_desc(sb, i, &bh2);
+ 
+ 		bitmap_nr = load_inode_bitmap (sb, i);
+ 		if (bitmap_nr < 0)
+ 			goto fail;
+ 
+ 		bh = EXT3_SB(sb)->s_inode_bitmap[bitmap_nr];
+ 
+ 		BUFFER_TRACE(bh, "get_write_access");
+ 		err = ext3_journal_get_write_access(handle, bh);
+ 		if (err) goto fail;
+ 
+ 		if (ext3_set_bit(j, bh->b_data)) {
+ 			printk(KERN_ERR "goal inode %lu unavailable\n", goal);
+ 			/* Oh well, we tried. */
+ 			goto repeat;
+ 		}
+ 
+ 		BUFFER_TRACE(bh, "call ext3_journal_dirty_metadata");
+ 		err = ext3_journal_dirty_metadata(handle, bh);
+ 		if (err) goto fail;
+ 
+ 		/* We've shortcircuited the allocation system successfully,
+ 		 * now finish filling in the inode.
+ 		 */
+ 		goto have_bit_and_group;
+ 	}
+ 
 repeat:
 	gdp = NULL;
 	i = 0;
@@ -438,6 +471,7 @@ repeat:
 		}
 		goto repeat;
 	}
+ have_bit_and_group:
 	j += i * EXT3_INODES_PER_GROUP(sb) + 1;
 	if (j < EXT3_FIRST_INO(sb) || j > le32_to_cpu(es->s_inodes_count)) {
 		ext3_error (sb, "ext3_new_inode",
--- linux-2.4.20/fs/ext3/ioctl.c~extN-wantedi	2003-04-08 23:35:55.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/ioctl.c	2003-04-08 23:35:55.000000000 -0600
@@ -23,6 +23,31 @@ int ext3_ioctl (struct inode * inode, st
 	ext3_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
+ 	case EXT3_IOC_CREATE_INUM: {
+ 		char name[32];
+ 		struct dentry *dchild, *dparent;
+ 		int rc = 0;
+ 
+ 		dparent = list_entry(inode->i_dentry.next, struct dentry,
+ 				     d_alias);
+ 		snprintf(name, sizeof name, "%lu", arg);
+ 		dchild = lookup_one_len(name, dparent, strlen(name));
+ 		if (dchild->d_inode) {
+ 			printk(KERN_ERR "%*s/%lu already exists (ino %lu)\n",
+ 			       dparent->d_name.len, dparent->d_name.name, arg,
+ 			       dchild->d_inode->i_ino);
+ 			rc = -EEXIST;
+ 		} else {
+ 			dchild->d_fsdata = (void *)arg;
+ 			rc = vfs_create(inode, dchild, 0644);
+ 			if (rc)
+ 				printk(KERN_ERR "vfs_create: %d\n", rc);
+ 			else if (dchild->d_inode->i_ino != arg)
+ 				rc = -EEXIST;
+ 		}
+ 		dput(dchild);
+ 		return rc;
+ 	}
 	case EXT3_IOC_GETFLAGS:
 		flags = inode->u.ext3_i.i_flags & EXT3_FL_USER_VISIBLE;
 		return put_user(flags, (int *) arg);
--- linux-2.4.20/include/linux/ext3_fs.h~extN-wantedi	2003-04-08 23:35:55.000000000 -0600
+++ linux-2.4.20-braam/include/linux/ext3_fs.h	2003-04-08 23:35:55.000000000 -0600
@@ -201,6 +201,7 @@ struct ext3_group_desc
 #define	EXT3_IOC_SETFLAGS		_IOW('f', 2, long)
 #define	EXT3_IOC_GETVERSION		_IOR('f', 3, long)
 #define	EXT3_IOC_SETVERSION		_IOW('f', 4, long)
+/* EXT3_IOC_CREATE_INUM at bottom of file (visible to kernel and user). */
 #define	EXT3_IOC_GETVERSION_OLD		_IOR('v', 1, long)
 #define	EXT3_IOC_SETVERSION_OLD		_IOW('v', 2, long)
 #ifdef CONFIG_JBD_DEBUG
@@ -671,7 +672,8 @@ extern int ext3fs_dirhash(const char *na
 			  dx_hash_info *hinfo);
 
 /* ialloc.c */
-extern struct inode * ext3_new_inode (handle_t *, const struct inode *, int);
+extern struct inode * ext3_new_inode (handle_t *, const struct inode *, int,
+ 				      unsigned long);
 extern void ext3_free_inode (handle_t *, struct inode *);
 extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);
 extern unsigned long ext3_count_free_inodes (struct super_block *);
@@ -757,4 +759,5 @@ extern struct inode_operations ext3_fast
 
 #endif	/* __KERNEL__ */
 
+#define EXT3_IOC_CREATE_INUM			_IOW('f', 5, long)
 #endif	/* _LINUX_EXT3_FS_H */

_
 fs/ext3/inode.c |   82 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 82 insertions(+)

--- linux-2.4.20/fs/ext3/inode.c~extN-san	2003-04-08 23:35:59.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/inode.c	2003-04-08 23:35:59.000000000 -0600
@@ -2734,3 +2734,85 @@ int ext3_change_inode_journal_flag(struc
  * here, in ext3_aops_journal_start() to ensure that the forthcoming "see if we
  * need to extend" test in ext3_prepare_write() succeeds.  
  */
+
+/* for each block: 1 ind + 1 dind + 1 tind
+ * for each block: 3 bitmap blocks
+ * for each block: 3 group descriptor blocks
+ * i inode block
+ * 1 superblock
+ * 2 * EXT3_SINGLEDATA_TRANS_BLOCKS for the quote files
+ * ((1+1+1) * 3 * nblocks) + 1 + 1 + 2 * EXT3_SINGLEDATA_TRANS_BLOCKS
+ *
+ * XXX assuming:
+ * (1) fs logic block size == page size
+ * (2) ext3 in writeback mode
+ */
+static inline int ext3_san_write_trans_blocks(int nblocks)
+{
+	int ret;
+	
+	ret = (1 + 1 + 1) * 3 * nblocks + 1 + 1;
+
+#ifdef CONFIG_QUOTA
+	ret += 2 * EXT3_SINGLEDATA_TRANS_BLOCKS;
+#endif
+
+	return ret;
+}
+
+/* Alloc blocks for an inode, while don't create any buffer/page
+ * for data I/O; set the inode size if file is extended.
+ *
+ * @inode:    target inode
+ * @blocks:   array of logic block number
+ * @nblocks:  how many blocks need be alloced
+ * @newsize:  new filesize we should set
+ *
+ * return:    0 success, otherwise failed
+ *            (*blocks) contains physical block number alloced
+ *
+ * XXX this assume the fs block size == page size
+ */
+int ext3_prep_san_write(struct inode *inode, long *blocks,
+			int nblocks, loff_t newsize)
+{
+	handle_t *handle;
+	struct buffer_head bh_tmp;
+	int needed_blocks;
+	int i, ret = 0, ret2;
+
+	needed_blocks = ext3_san_write_trans_blocks(nblocks);
+
+	lock_kernel();
+	handle = ext3_journal_start(inode, needed_blocks);
+	if (IS_ERR(handle)) {
+		unlock_kernel();
+		return PTR_ERR(handle);
+	}
+	unlock_kernel();
+
+	/* alloc blocks one by one */
+	for (i = 0; i < nblocks; i++) {
+		ret = ext3_get_block_handle(handle, inode, blocks[i],
+						&bh_tmp, 1);
+		if (ret)
+			break;
+
+		blocks[i] = bh_tmp.b_blocknr;
+	}
+
+	/* set inode size if needed */
+	if (!ret && (newsize > inode->i_size)) {
+		inode->i_size = newsize;
+		ext3_mark_inode_dirty(handle, inode);
+	}
+
+	lock_kernel();
+	ret2 = ext3_journal_stop(handle, inode);
+	unlock_kernel();
+
+	if (!ret)
+		ret = ret2;
+	return ret;
+}
+EXPORT_SYMBOL(ext3_prep_san_write);

_
--- ./include/linux/ext3_fs.h.orig	Tue May  7 17:06:03 2002
+++ ./include/linux/ext3_fs.h	Tue May  7 17:07:11 2002
@@ -17,6 +17,8 @@
 #define _LINUX_EXT3_FS_H
 
 #include <linux/types.h>
+#include <linux/ext3_fs_sb.h>
+#include <linux/ext3_fs_i.h>
 
 /*
  * The second extended filesystem constants/structures
@@ -86,8 +88,8 @@
 #define EXT3_MIN_BLOCK_LOG_SIZE		  10
 
 #ifdef __KERNEL__
-#define EXT3_SB(sb)	(&((sb)->u.ext3_sb))
-#define EXT3_I(inode)	(&((inode)->u.ext3_i))
+#define EXT3_SB(sb)	((struct ext3_sb_info *)&((sb)->u.generic_sbp))
+#define EXT3_I(inode)	((struct ext3_inode_info *)&((inode)->u.generic_ip))
 
 #define EXT3_BLOCK_SIZE(s)		((s)->s_blocksize)
 #define EXT3_BLOCK_SIZE_BITS(s)		((s)->s_blocksize_bits)
@@ -447,7 +447,9 @@
 #define NEXT_ORPHAN(inode) EXT3_I(inode)->i_dtime
 static inline struct inode *orphan_list_entry(struct list_head *l)
 {
-	return list_entry(l, struct inode, u.ext3_i.i_orphan);
+	return ((struct inode *)((char *)l -
+		(unsigned long)(offsetof(struct inode, u.generic_ip) +
+				offsetof(struct ext3_inode_info, i_orphan))));
 }
 
 /*
