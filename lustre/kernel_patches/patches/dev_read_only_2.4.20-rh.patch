diff -ur linux-2.4.20-rh.orig/drivers/block/ll_rw_blk.c linux-2.4.20-rh/drivers/block/ll_rw_blk.c
--- linux-2.4.20-rh.orig/drivers/block/ll_rw_blk.c	2004-05-27 11:25:09.000000000 -0700
+++ linux-2.4.20-rh/drivers/block/ll_rw_blk.c	2005-04-08 09:02:14.734804881 -0700
@@ -645,6 +645,84 @@ void set_device_ro(kdev_t dev,int flag)
 	else ro_bits[major][minor >> 5] &= ~(1 << (minor & 31));
 }
 
+/*
+ * Debug code for turning block devices read-only *silently* (will
+ * discard writes silently).  This is only for filesystem crash/recovery
+ * testing.
+ */
+struct deventry {
+	kdev_t dev;
+	struct deventry *next;
+};
+
+static struct deventry *devlist = NULL;
+static spinlock_t devlock = SPIN_LOCK_UNLOCKED;
+
+int dev_check_rdonly(kdev_t dev) {
+	struct deventry *cur;
+	spin_lock(&devlock);
+	cur = devlist;
+	while(cur) {
+		if (dev == cur->dev) {
+			spin_unlock(&devlock);
+			return 1;
+		}
+		cur = cur->next;
+	}
+	spin_unlock(&devlock);
+	return 0;
+}
+
+void dev_set_rdonly(kdev_t dev)
+{
+	struct deventry *newdev, *cur;
+	newdev = kmalloc(sizeof(struct deventry), GFP_KERNEL);
+	if (!newdev) return;
+
+	spin_lock(&devlock);
+	cur = devlist;
+	while(cur) {
+		if (dev == cur->dev) {
+			spin_unlock(&devlock);
+			kfree(newdev);
+			return;
+		}
+		cur = cur->next;
+	}
+	newdev->dev = dev;
+	newdev->next = devlist;
+	devlist = newdev;
+	spin_unlock(&devlock);
+	printk(KERN_WARNING "Turning device %s read-only\n", bdevname(dev));
+}
+
+void dev_clear_rdonly(kdev_t dev) {
+	struct deventry *cur, *last = NULL;
+
+	spin_lock(&devlock);
+	cur = devlist;
+	while(cur) {
+		if (dev == cur->dev) {
+			if (last)
+				last->next = cur->next;
+			else
+				devlist = cur->next;
+			spin_unlock(&devlock);
+			kfree(cur);
+			printk(KERN_WARNING "Removing read-only on %s\n",
+			       bdevname(dev));
+			return;
+		}
+		last = cur;
+		cur = cur->next;
+	}
+	spin_unlock(&devlock);
+}
+
+EXPORT_SYMBOL(dev_set_rdonly);
+EXPORT_SYMBOL(dev_check_rdonly);
+EXPORT_SYMBOL(dev_clear_rdonly);
+
 inline void drive_stat_acct (kdev_t dev, int rw,
 				unsigned long nr_sectors, int new_io)
 {
@@ -1183,6 +1263,10 @@ void generic_make_request (int rw, struc
 			buffer_IO_error(bh);
 			break;
 		}
+		if ((rw & WRITE)&&(dev_check_rdonly(bh->b_rdev))) {
+			bh->b_end_io(bh, 0);
+			break;
+		}
 	} while (q->make_request_fn(q, rw, bh));
 }
 
diff -ur linux-2.4.20-rh.orig/fs/block_dev.c linux-2.4.20-rh/fs/block_dev.c
--- linux-2.4.20-rh.orig/fs/block_dev.c	2002-08-02 17:39:45.000000000 -0700
+++ linux-2.4.20-rh/fs/block_dev.c	2005-04-08 09:02:15.005789333 -0700
@@ -645,6 +645,7 @@ int blkdev_put(struct block_device *bdev
 		bdev->bd_op = NULL;
 	unlock_kernel();
 	up(&bdev->bd_sem);
+       dev_clear_rdonly(to_kdev_t(bdev->bd_dev));
 	bdput(bdev);
 	return ret;
 }
diff -ur linux-2.4.20-rh.orig/include/linux/fs.h linux-2.4.20-rh/include/linux/fs.h
--- linux-2.4.20-rh.orig/include/linux/fs.h	2004-05-27 11:25:09.000000000 -0700
+++ linux-2.4.20-rh/include/linux/fs.h	2005-04-08 09:02:14.915794496 -0700
@@ -1425,6 +1425,10 @@ extern struct buffer_head * getblk(kdev_
 extern void ll_rw_block(int, int, struct buffer_head * bh[]);
 extern void submit_bh(int, struct buffer_head *);
 extern int is_read_only(kdev_t);
+#define HAVE_CLEAR_RDONLY_ON_PUT
+void dev_set_rdonly(kdev_t dev);
+int dev_check_rdonly(kdev_t dev);
+void dev_clear_rdonly(kdev_t dev);
 extern void __brelse(struct buffer_head *);
 static inline void brelse(struct buffer_head *buf)
 {

