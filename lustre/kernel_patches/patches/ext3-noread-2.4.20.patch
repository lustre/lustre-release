 fs/ext3/ialloc.c        |   47 ++++++++++++++++++++++-
 fs/ext3/inode.c         |   96 +++++++++++++++++++++++++++++++++++++-----------
 include/linux/ext3_fs.h |    2 +
 3 files changed, 121 insertions(+), 24 deletions(-)

--- linux-2.4.20/fs/ext3/ialloc.c~extN-noread-2.4.20	2003-05-04 16:41:22.000000000 +0800
+++ linux-2.4.20-root/fs/ext3/ialloc.c	2003-05-04 17:19:29.000000000 +0800
@@ -289,6 +289,37 @@ error_return:
 }
 
 /*
+ * @block_group: block group of inode
+ * @offset: relative offset of inode within @block_group
+ *
+ * Check whether any of the inodes in this disk block are in use.
+ *
+ * Caller must be holding superblock lock (group/bitmap read lock in future).
+ */
+int ext3_itable_block_used(struct super_block *sb, unsigned int block_group,
+			   int offset)
+{
+	int bitmap_nr = load_inode_bitmap(sb, block_group);
+	int inodes_per_block;
+	unsigned long inum, iend;
+	struct buffer_head *ibitmap;
+
+	if (bitmap_nr < 0)
+		return 1;
+
+	inodes_per_block = sb->s_blocksize / EXT3_SB(sb)->s_inode_size;
+	inum = offset & ~(inodes_per_block - 1);
+	iend = inum + inodes_per_block;
+	ibitmap = EXT3_SB(sb)->s_inode_bitmap[bitmap_nr];
+	for (; inum < iend; inum++) {
+		if (inum != offset && ext3_test_bit(inum, ibitmap->b_data))
+			return 1;
+	}
+
+	return 0;
+}
+
+/*
  * There are two policies for allocating an inode.  If the new inode is
  * a directory, then a forward search is made for a block group with both
  * free space and a low directory-to-inode ratio; if that fails, then of
@@ -310,6 +341,7 @@ struct inode * ext3_new_inode (handle_t 
 	struct ext3_group_desc * gdp;
 	struct ext3_group_desc * tmp;
 	struct ext3_super_block * es;
+	struct ext3_iloc iloc;
 	int err = 0;
 
 	/* Cannot create files in a deleted directory */
@@ -510,8 +542,19 @@ repeat:
 	inode->i_generation = sb->u.ext3_sb.s_next_generation++;
 
 	inode->u.ext3_i.i_state = EXT3_STATE_NEW;
-	err = ext3_mark_inode_dirty(handle, inode);
-	if (err) goto fail;
+ 	err = ext3_get_inode_loc_new(inode, &iloc, 1);
+  	if (err) goto fail;
+ 	BUFFER_TRACE(iloc->bh, "get_write_access");
+ 	err = ext3_journal_get_write_access(handle, iloc.bh);
+ 	if (err) {
+ 		brelse(iloc.bh);
+ 		iloc.bh = NULL;
+ 		goto fail;
+ 	}
+ 	err = ext3_mark_iloc_dirty(handle, inode, &iloc);
+ 	if (err) goto fail;
+ 
+
 	
 	unlock_super (sb);
 	if(DQUOT_ALLOC_INODE(inode)) {
--- linux-2.4.20/fs/ext3/inode.c~extN-noread-2.4.20	2003-05-04 16:41:26.000000000 +0800
+++ linux-2.4.20-root/fs/ext3/inode.c	2003-05-04 17:22:49.000000000 +0800
@@ -2013,14 +2013,19 @@ out_stop:
 	ext3_journal_stop(handle, inode);
 }
 
-/* 
- * ext3_get_inode_loc returns with an extra refcount against the
- * inode's underlying buffer_head on success. 
- */
-
-int ext3_get_inode_loc (struct inode *inode, struct ext3_iloc *iloc)
+#define NUM_INODE_PREREAD	16
+  
+/*
+  * ext3_get_inode_loc returns with an extra refcount against the inode's
+  * underlying buffer_head on success.  If this is for a new inode allocation
+  * (new is non-zero) then we may be able to optimize away the read if there
+  * are no other in-use inodes in this inode table block.  If we need to do
+  * a read, then read in a whole chunk of blocks to avoid blocking again soon
+  * if we are doing lots of creates/updates.
+  */
+int ext3_get_inode_loc_new(struct inode *inode, struct ext3_iloc *iloc, int new)
 {
-	struct buffer_head *bh = 0;
+ 	struct buffer_head *bh[NUM_INODE_PREREAD];
 	unsigned long block;
 	unsigned long block_group;
 	unsigned long group_desc;
@@ -2045,31 +2050,73 @@ int ext3_get_inode_loc (struct inode *in
 	}
 	group_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(inode->i_sb);
 	desc = block_group & (EXT3_DESC_PER_BLOCK(inode->i_sb) - 1);
-	bh = inode->i_sb->u.ext3_sb.s_group_desc[group_desc];
-	if (!bh) {
+	if (!(inode->i_sb->u.ext3_sb.s_group_desc[group_desc])) {
 		ext3_error (inode->i_sb, "ext3_get_inode_loc",
 			    "Descriptor not loaded");
 		goto bad_inode;
 	}
 
-	gdp = (struct ext3_group_desc *) bh->b_data;
+ 	gdp = (struct ext3_group_desc *)(inode->i_sb->u.ext3_sb.s_group_desc[group_desc]->b_data);
 	/*
 	 * Figure out the offset within the block group inode table
 	 */
-	offset = ((inode->i_ino - 1) % EXT3_INODES_PER_GROUP(inode->i_sb)) *
-		EXT3_INODE_SIZE(inode->i_sb);
+	offset = ((inode->i_ino - 1) % EXT3_INODES_PER_GROUP(inode->i_sb));
+
 	block = le32_to_cpu(gdp[desc].bg_inode_table) +
-		(offset >> EXT3_BLOCK_SIZE_BITS(inode->i_sb));
-	if (!(bh = sb_bread(inode->i_sb, block))) {
-		ext3_error (inode->i_sb, "ext3_get_inode_loc",
-			    "unable to read inode block - "
-			    "inode=%lu, block=%lu", inode->i_ino, block);
-		goto bad_inode;
-	}
-	offset &= (EXT3_BLOCK_SIZE(inode->i_sb) - 1);
+ 		(offset * EXT3_INODE_SIZE(inode->i_sb) >> EXT3_BLOCK_SIZE_BITS(inode->i_sb));
 
-	iloc->bh = bh;
-	iloc->raw_inode = (struct ext3_inode *) (bh->b_data + offset);
+ 	bh[0] = sb_getblk(inode->i_sb, block);
+ 	if (buffer_uptodate(bh[0]))
+ 		goto done;
+ 
+ 	/* If we don't really need to read this block, and it isn't already
+ 	 * in memory, then we just zero it out.  Otherwise, we keep the
+ 	 * current block contents (deleted inode data) for posterity.
+ 	 */
+ 	if (new && !ext3_itable_block_used(inode->i_sb, block_group, offset)) {
+ 		lock_buffer(bh[0]);
+ 		memset(bh[0]->b_data, 0, bh[0]->b_size);
+ 		mark_buffer_uptodate(bh[0], 1);
+ 		unlock_buffer(bh[0]);
+ 	} else {
+ 		unsigned long block_end, itable_end;
+ 		int count = 1;
+ 
+ 		itable_end = le32_to_cpu(gdp[desc].bg_inode_table) +
+ 				inode->i_sb->u.ext3_sb.s_itb_per_group;
+ 		block_end = block + NUM_INODE_PREREAD;
+ 		if (block_end > itable_end)
+ 			block_end = itable_end;
+ 
+ 		for (; block < block_end; block++) {
+ 			bh[count] = sb_getblk(inode->i_sb, block);
+ 			if (count && (buffer_uptodate(bh[count]) ||
+ 				      buffer_locked(bh[count]))) {
+ 				__brelse(bh[count]);
+ 			} else
+ 				count++;
+ 		}
+ 
+ 		ll_rw_block(READ, count, bh);
+ 
+ 		/* Release all but the block we actually need (bh[0]) */
+ 		while (--count > 0)
+ 			__brelse(bh[count]);
+ 
+ 		wait_on_buffer(bh[0]);
+ 		if (!buffer_uptodate(bh[0])) {
+ 			ext3_error(inode->i_sb, __FUNCTION__,
+ 				   "unable to read inode block - "
+ 				   "inode=%lu, block=%lu", inode->i_ino,
+ 				   bh[0]->b_blocknr);
+ 			goto bad_inode;
+ 		}
+  	}
+  done:
+ 	offset = (offset * EXT3_INODE_SIZE(inode->i_sb)) & (EXT3_BLOCK_SIZE(inode->i_sb) - 1);
+  
+ 	iloc->bh = bh[0];
+ 	iloc->raw_inode = (struct ext3_inode *)(bh[0]->b_data + offset);
 	iloc->block_group = block_group;
 	
 	return 0;
@@ -2078,6 +2125,11 @@ int ext3_get_inode_loc (struct inode *in
 	return -EIO;
 }
 
+int ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)
+{
+ 	return ext3_get_inode_loc_new(inode, iloc, 0);
+}
+ 
 void ext3_read_inode(struct inode * inode)
 {
 	struct ext3_iloc iloc;
--- linux-2.4.20/include/linux/ext3_fs.h~extN-noread-2.4.20	2003-05-04 16:41:22.000000000 +0800
+++ linux-2.4.20-root/include/linux/ext3_fs.h	2003-05-04 17:19:29.000000000 +0800
@@ -683,6 +683,8 @@ extern int ext3_forget(handle_t *, int, 
 extern struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);
 extern struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);
 
+extern int ext3_itable_block_used(struct super_block *sb, unsigned int, int);
+extern int ext3_get_inode_loc_new(struct inode *, struct ext3_iloc *, int);
 extern int  ext3_get_inode_loc (struct inode *, struct ext3_iloc *);
 extern void ext3_read_inode (struct inode *);
 extern void ext3_write_inode (struct inode *, int);

_
