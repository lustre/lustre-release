Index: linux-2.4.20/fs/ext3/extents-in-ea.c
===================================================================
--- linux-2.4.20.orig/fs/ext3/extents-in-ea.c	2003-01-30 13:24:37.000000000 +0300
+++ linux-2.4.20/fs/ext3/extents-in-ea.c	2004-01-24 14:54:04.000000000 +0300
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2003 Alex Tomas <alex@clusterfs.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public Licens
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/time.h>
+#include <linux/ext3_jbd.h>
+#include <linux/jbd.h>
+#include <linux/smp_lock.h>
+#include <linux/highuid.h>
+#include <linux/pagemap.h>
+#include <linux/quotaops.h>
+#include <linux/string.h>
+#include <linux/ext3_extents.h>
+#include <linux/ext3_xattr.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+
+static int ext3_get_ea_write_access(handle_t *handle, void *buffer)
+{
+	struct buffer_head *bh = (struct buffer_head *) buffer;
+	return ext3_journal_get_write_access(handle, bh);
+}
+
+static int ext3_mark_ea_buffer_dirty(handle_t *handle, void *buffer)
+{
+	struct buffer_head *bh = (struct buffer_head *) buffer;
+	ext3_journal_dirty_metadata(handle, bh);
+	return 0;
+}
+
+int ext3_init_tree_in_ea_desc(struct ext3_extents_tree *tree,
+				struct inode *inode, int name_index,
+				const char *eaname)
+{
+	struct buffer_head *bh;
+	int offset, err, size;
+
+	err = ext3_xattr_get_ea_loc(inode, name_index, eaname,
+					&bh, &offset, &size);
+	if (err)
+		return err;
+
+	EXT_ASSERT(bh);
+	EXT_ASSERT(size >= sizeof(struct ext3_extent_header)
+				+ sizeof(struct ext3_extent));
+	tree->inode = inode;
+	tree->root = (void *) bh->b_data + offset;
+	tree->buffer_len = size;
+	tree->buffer = (void *) bh;
+	tree->get_write_access = ext3_get_ea_write_access;
+	tree->mark_buffer_dirty = ext3_mark_ea_buffer_dirty;
+	tree->mergable = NULL;
+	tree->remove_extent = NULL;
+	tree->remove_extent_credits = NULL;
+	tree->new_block = NULL;
+	tree->cex = NULL; 	/* FIXME: add cache store later */
+	return 0;
+}
+
+void ext3_release_tree_in_ea_desc(struct ext3_extents_tree *tree)
+{
+	struct buffer_head *bh;
+
+	bh = (struct buffer_head *) tree->buffer;
+	EXT_ASSERT(bh);
+	brelse(bh);
+}
+
+int ext3_init_tree_in_ea(struct inode *inode, int name_index,
+				const char *eaname, int size)
+{
+	struct ext3_extents_tree tree;
+	handle_t *handle;
+	char *root;
+	int err;
+
+	root = kmalloc(size, GFP_USER);
+	if (!root)
+		return -ENOMEM;
+	memset(root, 0, size);
+
+	/* first, create ea to store root of the tree */
+	handle = ext3_journal_start(inode, EXT3_ALLOC_NEEDED + 1);
+	if (IS_ERR(handle))
+		return PTR_ERR(handle);
+	if ((err = ext3_xattr_set(handle, inode, name_index,
+					eaname, root, size, 0)))
+		goto out;
+	if ((err = ext3_init_tree_in_ea_desc(&tree, inode, name_index, eaname)))
+		goto out;
+	err = ext3_extent_tree_init(handle, &tree);
+	ext3_release_tree_in_ea_desc(&tree);
+out:
+	ext3_journal_stop(handle, inode);
+	kfree(root);
+	return err;
+}
+
+static int
+ext3_ext_in_ea_new_extent(struct ext3_extents_tree *tree,
+			struct ext3_ext_path *path,
+			struct ext3_extent *newex, int exist)
+{
+	handle_t *handle;
+	int needed, err;
+
+	if (exist)
+		return EXT_CONTINUE;
+
+	needed = ext3_ext_calc_credits_for_insert(tree, path);
+	handle = ext3_journal_start(tree->inode, needed);
+	if (IS_ERR(handle))
+		return PTR_ERR(handle);
+
+	/* insert new extent */
+	newex->e_start = 0;
+	err = ext3_ext_insert_extent(handle, tree, path, newex);
+	if (!err)
+		ext3_journal_stop(handle, tree->inode);
+
+	return err;
+}
+
+int ext3_ext_in_ea_alloc_space(struct inode *inode, int name_index,
+				const char *eaname, unsigned long from,
+				unsigned long num)
+{
+	struct ext3_extents_tree tree;
+	int err;
+
+	err = ext3_init_tree_in_ea_desc(&tree, inode, name_index, eaname);
+	if (err == 0) {
+		err = ext3_ext_walk_space(&tree, from, num,
+						ext3_ext_in_ea_new_extent);
+		ext3_release_tree_in_ea_desc(&tree);
+	}
+	return err;
+}
+
+int ext3_ext_in_ea_remove_space(struct inode *inode, int name_index,
+				const char *eaname, unsigned long from,
+				unsigned long num)
+{
+	struct ext3_extents_tree tree;
+	int err;
+
+	err = ext3_init_tree_in_ea_desc(&tree, inode, name_index, eaname);
+	if (err == 0) {
+		err = ext3_ext_remove_space(&tree, from, num);
+		ext3_release_tree_in_ea_desc(&tree);
+	}
+	return err;
+}
+
+int ext3_ext_in_ea_presence(struct inode *inode, int name_index,
+				const char *eaname, unsigned long block)
+{
+	struct ext3_extents_tree tree;
+	struct ext3_ext_path *path;
+	struct ext3_extent *ex;
+	int err, depth;
+
+	err = ext3_init_tree_in_ea_desc(&tree, inode, name_index, eaname);
+	if (err)
+		return err;
+
+	/* find extent for this block */
+	path = ext3_ext_find_extent(&tree, block, NULL);
+	if (IS_ERR(path)) {
+		err = PTR_ERR(path);
+		goto out;
+	}
+
+	depth = EXT_DEPTH(&tree);
+	ex = path[depth].p_ext;
+	if (!ex) {
+		/* there is no extent yet */
+		goto out;
+	}
+
+	if (block >= ex->e_block && block < ex->e_block + ex->e_num)
+		err = 1;
+out:
+	ext3_release_tree_in_ea_desc(&tree);
+	return err;
+}
+
Index: linux-2.4.20/fs/ext3/Makefile
===================================================================
--- linux-2.4.20.orig/fs/ext3/Makefile	2004-01-24 00:45:20.000000000 +0300
+++ linux-2.4.20/fs/ext3/Makefile	2004-01-24 14:34:27.000000000 +0300
@@ -17,7 +17,7 @@
 obj-m    := $(O_TARGET)
 
 export-objs += xattr.o
-obj-$(CONFIG_EXT3_FS_XATTR) += xattr.o
+obj-$(CONFIG_EXT3_FS_XATTR) += xattr.o extents-in-ea.o
 obj-$(CONFIG_EXT3_FS_XATTR_USER) += xattr_user.o
 
 include $(TOPDIR)/Rules.make
Index: linux-2.4.20/fs/ext3/xattr.c
===================================================================
--- linux-2.4.20.orig/fs/ext3/xattr.c	2004-01-23 19:00:43.000000000 +0300
+++ linux-2.4.20/fs/ext3/xattr.c	2004-01-24 14:34:27.000000000 +0300
@@ -771,7 +771,8 @@
  */
 int
 ext3_xattr_ibody_find(struct inode *inode, int name_index, 
-		const char *name, struct ext3_xattr_entry *rentry, int *free)
+		const char *name, struct ext3_xattr_entry *rentry, int *free,
+		struct buffer_head **bh, int *offset)
 {
 	struct ext3_xattr_entry *last;
 	struct ext3_inode *raw_inode;
@@ -818,6 +819,15 @@
 		    name_len == last->e_name_len &&
 		    !memcmp(name, last->e_name, name_len)) {
 			memcpy(rentry, last, sizeof(struct ext3_xattr_entry));
+			if (offset) {
+				void *voff;
+				voff = start + le16_to_cpu(last->e_value_offs);
+				*offset = voff - (void *) iloc.bh->b_data;
+			}
+			if (bh) {
+				get_bh(iloc.bh);	
+				*bh = iloc.bh;
+			}
 			ret = 0;
 		} else {
 			*free -= EXT3_XATTR_LEN(last->e_name_len);
@@ -838,7 +848,8 @@
  */
 int
 ext3_xattr_block_find(struct inode *inode, int name_index, const char *name,
-	       struct ext3_xattr_entry *rentry, int *free)
+	       struct ext3_xattr_entry *rentry, int *free,
+	       struct buffer_head **tbh, int *offset)
 {
 	struct buffer_head *bh = NULL;
 	struct ext3_xattr_entry *entry;
@@ -881,6 +892,12 @@
 		    memcmp(name, entry->e_name, name_len) == 0) {
 			memcpy(rentry, entry, sizeof(struct ext3_xattr_entry));
 			error = 0;
+			if (offset)
+				*offset = le16_to_cpu(entry->e_value_offs);
+			if (tbh) {
+				get_bh(bh);	
+				*tbh = bh;
+			}
 		} else {
 			*free -= EXT3_XATTR_LEN(entry->e_name_len);
 			*free -= le32_to_cpu(entry->e_value_size);
@@ -1073,7 +1090,8 @@
 		return -ERANGE;
 
 	/* try to find attribute in inode body */
-	err = ext3_xattr_ibody_find(inode, name_index, name, &entry, &free1);
+	err = ext3_xattr_ibody_find(inode, name_index, name,
+					&entry, &free1, NULL, NULL);
 	if (err == 0) {
 		/* found EA in inode */
 		found = 1;
@@ -1082,7 +1100,7 @@
 		/* there is no such attribute in inode body */
 		/* try to find attribute in dedicated block */
 		err = ext3_xattr_block_find(inode, name_index, name,
-						&entry, &free2);
+						&entry, &free2, NULL, NULL);
 		if (err != 0 && err != -ENOENT) {
 			/* not found EA in block */
 			goto finish;	
@@ -1138,6 +1156,38 @@
 	return err;
 }
 
+int ext3_xattr_get_ea_loc(struct inode *inode, int name_index,
+				const char *name, struct buffer_head **bh,
+				int *offset, int *size)
+{
+	int free1 = -1, free2 = -1, err, name_len;
+	struct ext3_xattr_entry entry;
+	
+	ea_idebug(inode, "name=%d.%s", name_index, name);
+
+	if (name == NULL)
+		return -EINVAL;
+	name_len = strlen(name);
+	if (name_len > 255)
+		return -ERANGE;
+
+	down(&ext3_xattr_sem);
+
+	/* try to find attribute in inode body */
+	err = ext3_xattr_ibody_find(inode, name_index, name,
+					&entry, &free1, bh, offset);
+	if (err == -ENOENT) {
+		/* there is no such attribute in inode body */
+		/* try to find attribute in dedicated block */
+		err = ext3_xattr_block_find(inode, name_index, name,
+						&entry, &free2, bh, offset);
+	}
+	if (err == 0 && size)
+		*size = le32_to_cpu(entry.e_value_size);
+	up(&ext3_xattr_sem);
+	return err;
+}
+
 /*
  * ext3_xattr_block_set()
  * 
Index: linux-2.4.20/include/linux/ext3_xattr.h
===================================================================
--- linux-2.4.20.orig/include/linux/ext3_xattr.h	2004-01-24 14:22:28.000000000 +0300
+++ linux-2.4.20/include/linux/ext3_xattr.h	2004-01-24 14:34:27.000000000 +0300
@@ -80,6 +80,7 @@
 extern int ext3_xattr_get(struct inode *, int, const char *, void *, size_t);
 extern int ext3_xattr_list(struct inode *, char *, size_t);
 extern int ext3_xattr_set(handle_t *handle, struct inode *, int, const char *, const void *, size_t, int);
+extern int ext3_xattr_get_ea_loc(struct inode *, int, const char *, struct buffer_head **, int *, int *);
 
 extern void ext3_xattr_delete_inode(handle_t *, struct inode *);
 extern void ext3_xattr_put_super(struct super_block *);
