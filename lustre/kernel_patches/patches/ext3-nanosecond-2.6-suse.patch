Index: linux-2.6.5-7.283/fs/ext3/ialloc.c
===================================================================
--- linux-2.6.5-7.283.orig/fs/ext3/ialloc.c
+++ linux-2.6.5-7.283/fs/ext3/ialloc.c
@@ -613,7 +613,8 @@ got:
 	/* This is the optimal IO size (for stat), not the fs block size */
 	inode->i_blksize = PAGE_SIZE;
 	inode->i_blocks = 0;
-	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
+	inode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =
+							       CURRENT_TIME;
 
 	memset(ei->i_data, 0, sizeof(ei->i_data));
 	ei->i_next_alloc_block = 0;
@@ -651,9 +652,8 @@ got:
 	spin_unlock(&sbi->s_next_gen_lock);
 
 	ei->i_state = EXT3_STATE_NEW;
-	ei->i_extra_isize =
-		(EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) ?
-		sizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE : 0;
+
+	ei->i_extra_isize = EXT3_SB(sb)->s_want_extra_isize;
 
 	ret = inode;
 	if(DQUOT_ALLOC_INODE(inode)) {
Index: linux-2.6.5-7.283/fs/ext3/inode.c
===================================================================
--- linux-2.6.5-7.283.orig/fs/ext3/inode.c
+++ linux-2.6.5-7.283/fs/ext3/inode.c
@@ -2459,7 +2459,11 @@ void ext3_read_inode(struct inode * inod
 	inode->i_atime.tv_sec = le32_to_cpu(raw_inode->i_atime);
 	inode->i_ctime.tv_sec = le32_to_cpu(raw_inode->i_ctime);
 	inode->i_mtime.tv_sec = le32_to_cpu(raw_inode->i_mtime);
-	inode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;
+	if (EXT3_FITS_IN_INODE(raw_inode, ei, i_crtime)) {
+		ei->i_crtime.tv_sec = le32_to_cpu(raw_inode->i_crtime);
+	}
+	inode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec =
+							    ei->i_crtime.tv_nsec = 0;
 
 	ei->i_state = 0;
 	ei->i_next_alloc_block = 0;
@@ -2603,6 +2607,10 @@ static int ext3_do_update_inode(handle_t
 	raw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
 	raw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);
 	raw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);
+	if (EXT3_FITS_IN_INODE(raw_inode, ei, i_crtime)) {
+		raw_inode->i_crtime = cpu_to_le32(ei->i_crtime.tv_sec);
+	}
+
 	raw_inode->i_blocks = cpu_to_le32(inode->i_blocks);
 	raw_inode->i_dtime = cpu_to_le32(ei->i_dtime);
 	raw_inode->i_flags = cpu_to_le32(ei->i_flags);
Index: linux-2.6.5-7.283/fs/ext3/super.c
===================================================================
--- linux-2.6.5-7.283.orig/fs/ext3/super.c
+++ linux-2.6.5-7.283/fs/ext3/super.c
@@ -1515,6 +1515,32 @@ static int ext3_fill_super (struct super
 	}
 
 	ext3_setup_super (sb, es, sb->s_flags & MS_RDONLY);
+
+	/* determine the minimum size of new large inodes, if present */
+	if (sbi->s_inode_size > EXT3_GOOD_OLD_INODE_SIZE) {
+		sbi->s_want_extra_isize = sizeof(struct ext3_inode) -
+						     EXT3_GOOD_OLD_INODE_SIZE;
+		if (EXT3_HAS_RO_COMPAT_FEATURE(sb,
+				       EXT3_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {
+			if (sbi->s_want_extra_isize <
+			    le16_to_cpu(es->s_want_extra_isize))
+				sbi->s_want_extra_isize =
+					le16_to_cpu(es->s_want_extra_isize);
+			if (sbi->s_want_extra_isize <
+			    le16_to_cpu(es->s_min_extra_isize))
+				sbi->s_want_extra_isize =
+					le16_to_cpu(es->s_min_extra_isize);
+		}
+	}
+	/* Check if enough inode space is available */
+	if (EXT3_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >
+							sbi->s_inode_size) {
+		sbi->s_want_extra_isize = sizeof(struct ext3_inode) -
+						       EXT3_GOOD_OLD_INODE_SIZE;
+		printk(KERN_INFO "EXT3-fs: required extra inode space not"
+			"available.\n");
+	}
+
 	/*
 	 * akpm: core read_super() calls in here with the superblock locked.
 	 * That deadlocks, because orphan cleanup needs to lock the superblock
Index: linux-2.6.5-7.283/include/linux/ext3_fs.h
===================================================================
--- linux-2.6.5-7.283.orig/include/linux/ext3_fs.h
+++ linux-2.6.5-7.283/include/linux/ext3_fs.h
@@ -232,7 +232,7 @@ struct ext3_inode {
 	__u16	i_uid;		/* Low 16 bits of Owner Uid */
 	__u32	i_size;		/* Size in bytes */
 	__u32	i_atime;	/* Access time */
-	__u32	i_ctime;	/* Creation time */
+	__u32	i_ctime;	/* Inode Change time */
 	__u32	i_mtime;	/* Modification time */
 	__u32	i_dtime;	/* Deletion Time */
 	__u16	i_gid;		/* Low 16 bits of Group Id */
@@ -281,10 +281,25 @@ struct ext3_inode {
 	} osd2;				/* OS dependent 2 */
 	__u16	i_extra_isize;
 	__u16	i_pad1;
+	__le32  i_ctime_extra;	/* extra Change time      (nsec << 2 | epoch) */
+	__le32  i_mtime_extra;	/* extra Modification time(nsec << 2 | epoch) */
+	__le32  i_atime_extra;	/* extra Access time      (nsec << 2 | epoch) */
+	__le32  i_crtime;	/* File Creation time */
+	__le32  i_crtime_extra;	/* extra File Creation time (nsec << 2 | epoch) */
 };
 
 #define i_size_high	i_dir_acl
 
+#define EXT3_EPOCH_BITS 2
+#define EXT3_EPOCH_MASK ((1 << EXT3_EPOCH_BITS) - 1)
+#define EXT3_NSEC_MASK  (~0UL << EXT3_EPOCH_BITS)
+
+#define EXT3_FITS_IN_INODE(ext3_inode, einode, field)	\
+	((offsetof(typeof(*ext3_inode), field) +	\
+	 sizeof((ext3_inode)->field))			\
+	 <= (EXT3_GOOD_OLD_INODE_SIZE +			\
+	     (einode)->i_extra_isize))			\
+
 #if defined(__KERNEL__) || defined(__linux__)
 #define i_reserved1	osd1.linux1.l_i_reserved1
 #define i_frag		osd2.linux2.l_i_frag
@@ -464,7 +479,9 @@ struct ext3_super_block {
 	__u16	s_reserved_word_pad;
 	__u32	s_default_mount_opts;
 	__u32	s_first_meta_bg; 	/* First metablock block group */
-	__u32	s_reserved[190];	/* Padding to the end of the block */
+	__le16  s_min_extra_isize;	/* All inodes have at least # bytes */
+	__le16  s_want_extra_isize;	/* New inodes should reserve # bytes */
+	__u32   s_reserved[189];	/* Padding to the end of the block */
 };
 
 #ifdef __KERNEL__
@@ -539,6 +556,7 @@ static inline struct ext3_inode_info *EX
 #define EXT3_FEATURE_RO_COMPAT_LARGE_FILE	0x0002
 #define EXT3_FEATURE_RO_COMPAT_BTREE_DIR	0x0004
 #define EXT3_FEATURE_RO_COMPAT_DIR_NLINK	0x0020
+#define EXT3_FEATURE_RO_COMPAT_EXTRA_ISIZE	0x0040
 
 #define EXT3_FEATURE_INCOMPAT_COMPRESSION	0x0001
 #define EXT3_FEATURE_INCOMPAT_FILETYPE		0x0002
@@ -555,6 +573,7 @@ static inline struct ext3_inode_info *EX
 #define EXT3_FEATURE_RO_COMPAT_SUPP	(EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER| \
 					 EXT3_FEATURE_RO_COMPAT_LARGE_FILE| \
 					 EXT3_FEATURE_RO_COMPAT_DIR_NLINK| \
+					 EXT3_FEATURE_RO_COMPAT_EXTRA_ISIZE| \
 					 EXT3_FEATURE_RO_COMPAT_BTREE_DIR)
 
 /*
Index: linux-2.6.5-7.283/include/linux/ext3_fs_i.h
===================================================================
--- linux-2.6.5-7.283.orig/include/linux/ext3_fs_i.h
+++ linux-2.6.5-7.283/include/linux/ext3_fs_i.h
@@ -131,6 +131,7 @@ struct ext3_inode_info {
 	struct inode vfs_inode;
 
 	struct ext3_ext_cache i_cached_extent;
+	struct timespec i_crtime;
 };
 
 #endif	/* _LINUX_EXT3_FS_I */
Index: linux-2.6.5-7.283/include/linux/ext3_fs_sb.h
===================================================================
--- linux-2.6.5-7.283.orig/include/linux/ext3_fs_sb.h
+++ linux-2.6.5-7.283/include/linux/ext3_fs_sb.h
@@ -119,6 +119,8 @@ struct ext3_sb_info {
 	spinlock_t s_bal_lock;
 	unsigned long s_mb_buddies_generated;
 	unsigned long long s_mb_generation_time;
+
+	unsigned int s_want_extra_isize; /* New inodes should reserve # bytes */
 };
 
 #define EXT3_GROUP_INFO(sb, group)					   \
