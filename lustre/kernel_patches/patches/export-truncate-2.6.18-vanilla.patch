 include/linux/mm.h |    2 ++
 mm/truncate.c      |    4 ++--
 2 files changed, 4 insertions(+), 2 deletions(-)

Index: linux-2.6.27.21-0.1/include/linux/mm.h
===================================================================
--- linux-2.6.27.21-0.1.orig/include/linux/mm.h
+++ linux-2.6.27.21-0.1/include/linux/mm.h
@@ -602,6 +602,8 @@ static __always_inline void *lowmem_page
 {
 	return __va(page_to_pfn(page) << PAGE_SHIFT);
 }
+/* truncate.c */
+extern int truncate_complete_page(struct address_space *mapping,struct page *);
 
 #if defined(CONFIG_HIGHMEM) && !defined(WANT_PAGE_VIRTUAL)
 #define HASHED_PAGE_VIRTUAL
Index: linux-2.6.27.21-0.1/mm/truncate.c
===================================================================
--- linux-2.6.27.21-0.1.orig/mm/truncate.c
+++ linux-2.6.27.21-0.1/mm/truncate.c
@@ -92,7 +92,7 @@ EXPORT_SYMBOL(cancel_dirty_page);
  * its lock, b) when a concurrent invalidate_mapping_pages got there first and
  * c) when tmpfs swizzles a page between a tmpfs inode and swapper_space.
  */
-static int
+int
 truncate_complete_page(struct address_space *mapping, struct page *page)
 {
 	if (page->mapping != mapping)
@@ -107,7 +107,7 @@ truncate_complete_page(struct address_sp
 	page_cache_release(page);	/* pagecache ref */
	return 0;
 }
-
+EXPORT_SYMBOL_GPL(truncate_complete_page);
 /*
  * This is for invalidate_mapping_pages().  That function can be called at
  * any time, and is not supposed to throw away dirty pages.  But pages can
