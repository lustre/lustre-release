<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:lang="en-US" xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" xml:id='troubleshootingrecovery'>
  <info>
    <title xml:id='troubleshootingrecovery.title'>Troubleshooting Recovery</title>
  </info>
  <para><anchor xml:id="dbdoclet.50438225_pgfId-1292105" xreflabel=""/>This chapter describes what to do if something goes wrong during recovery. It describes:</para>

  <itemizedlist><listitem>
      <para><xref linkend="dbdoclet.50438225_71141"/></para>
    </listitem>

<listitem>
      <para><xref linkend="dbdoclet.50438225_37365"/></para>
    </listitem>

<listitem>
      <para><xref linkend="dbdoclet.50438225_12316"/></para>
    </listitem>

</itemizedlist>

    <section xml:id="dbdoclet.50438225_71141">
      <title>27.1 Recovering from Errors or <anchor xml:id="dbdoclet.50438225_marker-1292184" xreflabel=""/>Corruption on a Backing File System</title>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1291241" xreflabel=""/>When an OSS, MDS, or MGS server crash occurs, it is not necessary to run e2fsck on the file system. ldiskfs journaling ensures that the file system remains coherent. The backing file systems are never accessed directly from the client, so client crashes are not relevant.</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1291243" xreflabel=""/>The only time it is REQUIRED that e2fsck be run on a device is when an event causes problems that ldiskfs journaling is unable to handle, such as a hardware device failure or I/O error. If the ldiskfs kernel code detects corruption on the disk, it mounts the file system as read-only to prevent further corruption, but still allows read access to the device. This appears as error &quot;-30&quot; (EROFS) in the syslogs on the server, e.g.:</para>
      <screen><anchor xml:id="dbdoclet.50438225_pgfId-1291304" xreflabel=""/>Dec 29 14:11:32 mookie kernel: LDISKFS-fs error (device sdz): ldiskfs_looku\
p: unlinked inode 5384166 in dir #145170469
</screen>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1291325" xreflabel=""/>Dec 29 14:11:32 mookie kernel: Remounting filesystem read-only</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1291305" xreflabel=""/>In such a situation, it is normally required that e2fsck only be run on the bad device before placing the device back into service.</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1291245" xreflabel=""/>In the vast majority of cases, Lustre can cope with any inconsistencies it finds on the disk and between other devices in the file system.</para>
              <note><para>lfsck is rarely required for Lustre operation.</para></note>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1291249" xreflabel=""/>For problem analysis, it is strongly recommended that e2fsck be run under a logger, like script, to record all of the output and changes that are made to the file system in case this information is needed later.</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1291251" xreflabel=""/>If time permits, it is also a good idea to first run e2fsck in non-fixing mode (-n option) to assess the type and extent of damage to the file system. The drawback is that in this mode, e2fsck does not recover the file system journal, so there may appear to be file system corruption when none really exists.</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1291253" xreflabel=""/>To address concern about whether corruption is real or only due to the journal not being replayed, you can briefly mount and unmount the ldiskfs filesystem directly on the node with Lustre stopped (NOT via Lustre), using a command similar to:</para>
      <screen><anchor xml:id="dbdoclet.50438225_pgfId-1291255" xreflabel=""/>mount -t ldiskfs /dev/{ostdev} /mnt/ost; umount /mnt/ost
</screen>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1291257" xreflabel=""/>This causes the journal to be recovered.</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1291259" xreflabel=""/>The e2fsck utility works well when fixing file system corruption (better than similar file system recovery tools and a primary reason why ldiskfs was chosen over other file systems for Lustre). However, it is often useful to identify the type of damage that has occurred so an ldiskfs expert can make intelligent decisions about what needs fixing, in place of e2fsck.</para>
      <screen><anchor xml:id="dbdoclet.50438225_pgfId-1291261" xreflabel=""/>root# {stop lustre services for this device, if running} 
<anchor xml:id="dbdoclet.50438225_pgfId-1291375" xreflabel=""/>root# script /tmp/e2fsck.sda 
<anchor xml:id="dbdoclet.50438225_pgfId-1291378" xreflabel=""/>Script started, file is /tmp/e2fsck.sda 
<anchor xml:id="dbdoclet.50438225_pgfId-1291381" xreflabel=""/>root# mount -t ldiskfs /dev/sda /mnt/ost 
<anchor xml:id="dbdoclet.50438225_pgfId-1291384" xreflabel=""/>root# umount /mnt/ost 
<anchor xml:id="dbdoclet.50438225_pgfId-1291387" xreflabel=""/>root# e2fsck -fn /dev/sda   # don&apos;t fix file system, just check for corrupt\
ion 
<anchor xml:id="dbdoclet.50438225_pgfId-1291268" xreflabel=""/>: 
<anchor xml:id="dbdoclet.50438225_pgfId-1291393" xreflabel=""/>[e2fsck output] 
<anchor xml:id="dbdoclet.50438225_pgfId-1291270" xreflabel=""/>: 
<anchor xml:id="dbdoclet.50438225_pgfId-1291399" xreflabel=""/>root# e2fsck -fp /dev/sda   # fix filesystem using &quot;prudent&quot; answers (usually\
 &apos;y&apos;)
</screen>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1291234" xreflabel=""/>In addition, the e2fsprogs package contains the lfsck tool, which does distributed coherency checking for the Lustre file system after e2fsck has been run. Running lfsck is NOT required in a large majority of cases, at a small risk of having some leaked space in the file system. To avoid a lengthy downtime, it can be run (with care) after Lustre is started.</para>
    </section>
    <section xml:id="dbdoclet.50438225_37365">
      <title>27.2 Recovering from <anchor xml:id="dbdoclet.50438225_marker-1292186" xreflabel=""/>Corruption in the Lustre File System</title>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1289918" xreflabel=""/>In cases where the MDS or an OST becomes corrupt, you can run a distributed check on the file system to determine what sort of problems exist. Use lfsck to correct any defects found.</para>
      <orderedlist><listitem>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290095" xreflabel=""/>Stop the Lustre file system.</para>
  </listitem><listitem>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290099" xreflabel=""/>Run e2fsck -f on the individual MDS / OST that had problems to fix any local file system damage.</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290108" xreflabel=""/>We recommend running e2fsck under script, to create a log of changes made to the file system in case it is needed later. After e2fsck is run, bring up the file system, if necessary, to reduce the outage window.</para>
  </listitem><listitem>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290111" xreflabel=""/>Run a full e2fsck of the MDS to create a database for lfsck. You <emphasis>must</emphasis> use the -n option for a mounted file system, otherwise you will corrupt the file system.</para>
      <screen><anchor xml:id="dbdoclet.50438225_pgfId-1290120" xreflabel=""/>e2fsck -n -v --mdsdb /tmp/mdsdb /dev/{mdsdev}
</screen>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290115" xreflabel=""/>The mdsdb file can grow fairly large, depending on the number of files in the file system (10 GB or more for millions of files, though the actual file size is larger because the file is sparse). It is quicker to write the file to a local file system due to seeking and small writes. Depending on the number of files, this step can take several hours to complete.</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290147" xreflabel=""/><emphasis role="bold">Example</emphasis></para>
      <screen><anchor xml:id="dbdoclet.50438225_pgfId-1290148" xreflabel=""/>e2fsck -n -v --mdsdb /tmp/mdsdb /dev/sdb
<anchor xml:id="dbdoclet.50438225_pgfId-1290149" xreflabel=""/>e2fsck 1.39.cfs1 (29-May-2006)
<anchor xml:id="dbdoclet.50438225_pgfId-1290150" xreflabel=""/>Warning: skipping journal recovery because doing a read-only filesystem che\
ck.
<anchor xml:id="dbdoclet.50438225_pgfId-1290151" xreflabel=""/>lustre-MDT0000 contains a file system with errors, check forced.
<anchor xml:id="dbdoclet.50438225_pgfId-1290152" xreflabel=""/>Pass 1: Checking inodes, blocks, and sizes
<anchor xml:id="dbdoclet.50438225_pgfId-1290153" xreflabel=""/>MDS: ost_idx 0 max_id 288
<anchor xml:id="dbdoclet.50438225_pgfId-1290154" xreflabel=""/>MDS: got 8 bytes = 1 entries in lov_objids
<anchor xml:id="dbdoclet.50438225_pgfId-1290155" xreflabel=""/>MDS: max_files = 13
<anchor xml:id="dbdoclet.50438225_pgfId-1290156" xreflabel=""/>MDS: num_osts = 1
<anchor xml:id="dbdoclet.50438225_pgfId-1290157" xreflabel=""/>mds info db file written
<anchor xml:id="dbdoclet.50438225_pgfId-1290158" xreflabel=""/>Pass 2: Checking directory structure
<anchor xml:id="dbdoclet.50438225_pgfId-1290159" xreflabel=""/>Pass 3: Checking directory connectivity
<anchor xml:id="dbdoclet.50438225_pgfId-1290160" xreflabel=""/>Pass 4: Checking reference counts
<anchor xml:id="dbdoclet.50438225_pgfId-1290161" xreflabel=""/>Pass 5: Checking group summary information
<anchor xml:id="dbdoclet.50438225_pgfId-1290162" xreflabel=""/>Free blocks count wrong (656160, counted=656058).
<anchor xml:id="dbdoclet.50438225_pgfId-1290163" xreflabel=""/>Fix? no
<anchor xml:id="dbdoclet.50438225_pgfId-1290164" xreflabel=""/> 
<anchor xml:id="dbdoclet.50438225_pgfId-1290165" xreflabel=""/>Free inodes count wrong (786419, counted=786036).
<anchor xml:id="dbdoclet.50438225_pgfId-1290166" xreflabel=""/>Fix? no
<anchor xml:id="dbdoclet.50438225_pgfId-1290167" xreflabel=""/> 
<anchor xml:id="dbdoclet.50438225_pgfId-1290168" xreflabel=""/>Pass 6: Acquiring information for lfsck
<anchor xml:id="dbdoclet.50438225_pgfId-1290169" xreflabel=""/>MDS: max_files = 13
<anchor xml:id="dbdoclet.50438225_pgfId-1290170" xreflabel=""/>MDS: num_osts = 1
<anchor xml:id="dbdoclet.50438225_pgfId-1290171" xreflabel=""/>MDS: &apos;lustre-MDT0000_UUID&apos; mdt idx 0: compat 0x4 rocomp 0x1 incomp 0x4
<anchor xml:id="dbdoclet.50438225_pgfId-1290172" xreflabel=""/>lustre-MDT0000: ******* WARNING: Filesystem still has errors *******
<anchor xml:id="dbdoclet.50438225_pgfId-1290173" xreflabel=""/>   13 inodes used (0%)
<anchor xml:id="dbdoclet.50438225_pgfId-1290174" xreflabel=""/>           2 non-contiguous inodes (15.4%)
<anchor xml:id="dbdoclet.50438225_pgfId-1290175" xreflabel=""/>                   # of inodes with ind/dind/tind blocks: 0/0/0
<anchor xml:id="dbdoclet.50438225_pgfId-1290176" xreflabel=""/>130272 blocks used (16%)
<anchor xml:id="dbdoclet.50438225_pgfId-1290177" xreflabel=""/>   0 bad blocks
<anchor xml:id="dbdoclet.50438225_pgfId-1290178" xreflabel=""/>   1 large file
<anchor xml:id="dbdoclet.50438225_pgfId-1290179" xreflabel=""/>   296 regular files
<anchor xml:id="dbdoclet.50438225_pgfId-1290180" xreflabel=""/>   91 directories
<anchor xml:id="dbdoclet.50438225_pgfId-1290181" xreflabel=""/>   0 character device files
<anchor xml:id="dbdoclet.50438225_pgfId-1290182" xreflabel=""/>   0 block device files
<anchor xml:id="dbdoclet.50438225_pgfId-1290183" xreflabel=""/>   0 fifos
<anchor xml:id="dbdoclet.50438225_pgfId-1290184" xreflabel=""/>   0 links
<anchor xml:id="dbdoclet.50438225_pgfId-1290185" xreflabel=""/>   0 symbolic links (0 fast symbolic links)
<anchor xml:id="dbdoclet.50438225_pgfId-1290186" xreflabel=""/>   0 sockets
<anchor xml:id="dbdoclet.50438225_pgfId-1290187" xreflabel=""/>   --------
<anchor xml:id="dbdoclet.50438225_pgfId-1290188" xreflabel=""/>   387 files
</screen>
  </listitem><listitem>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290139" xreflabel=""/>Make this file accessible on all OSTs, either by using a shared file system or copying the file to the OSTs. The pdcp command is useful here.</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1289927" xreflabel=""/>The pdcp command (installed with pdsh), can be used to copy files to groups of hosts. Pdcp is available here:</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290242" xreflabel=""/><link xl:href="http://sourceforge.net/projects/pdsh">http://sourceforge.net/projects/pdsh</link></para>
  </listitem><listitem>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1289928" xreflabel=""/>Run a similar e2fsck step on the OSTs. The e2fsck --ostdb command can be run in parallel on all OSTs.</para>
      <screen><anchor xml:id="dbdoclet.50438225_pgfId-1290293" xreflabel=""/>e2fsck -n -v --mdsdb /tmp/mdsdb --ostdb /tmp/{ostNdb} \/dev/{ostNdev}
</screen>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290266" xreflabel=""/>The mdsdb file is read-only in this step; a single copy can be shared by all OSTs.</para>
              <note><para>If the OSTs do not have shared file system access to the MDS, a stub mdsdb file, {mdsdb}.mdshdr, is generated. This can be used instead of the full mdsdb file.</para></note>
       <para><anchor xml:id="dbdoclet.50438225_pgfId-1292837" xreflabel=""/><emphasis role="bold">Example:</emphasis></para>
      <screen><anchor xml:id="dbdoclet.50438225_pgfId-1290319" xreflabel=""/>[root@oss161 ~]# e2fsck -n -v --mdsdb /tmp/mdsdb --ostdb \ /tmp/ostdb /dev/\
sda 
<anchor xml:id="dbdoclet.50438225_pgfId-1290349" xreflabel=""/>e2fsck 1.39.cfs1 (29-May-2006)
<anchor xml:id="dbdoclet.50438225_pgfId-1290321" xreflabel=""/>Warning: skipping journal recovery because doing a read-only filesystem che\
ck.
<anchor xml:id="dbdoclet.50438225_pgfId-1290322" xreflabel=""/>lustre-OST0000 contains a file system with errors, check forced.
<anchor xml:id="dbdoclet.50438225_pgfId-1290323" xreflabel=""/>Pass 1: Checking inodes, blocks, and sizes
<anchor xml:id="dbdoclet.50438225_pgfId-1290324" xreflabel=""/>Pass 2: Checking directory structure
<anchor xml:id="dbdoclet.50438225_pgfId-1290325" xreflabel=""/>Pass 3: Checking directory connectivity
<anchor xml:id="dbdoclet.50438225_pgfId-1290326" xreflabel=""/>Pass 4: Checking reference counts
<anchor xml:id="dbdoclet.50438225_pgfId-1290327" xreflabel=""/>Pass 5: Checking group summary information
<anchor xml:id="dbdoclet.50438225_pgfId-1290328" xreflabel=""/>Free blocks count wrong (989015, counted=817968).
<anchor xml:id="dbdoclet.50438225_pgfId-1290329" xreflabel=""/>Fix? no
<anchor xml:id="dbdoclet.50438225_pgfId-1290330" xreflabel=""/> 
<anchor xml:id="dbdoclet.50438225_pgfId-1290331" xreflabel=""/>Free inodes count wrong (262088, counted=261767).
<anchor xml:id="dbdoclet.50438225_pgfId-1290332" xreflabel=""/>Fix? no
<anchor xml:id="dbdoclet.50438225_pgfId-1290333" xreflabel=""/> 
<anchor xml:id="dbdoclet.50438225_pgfId-1290334" xreflabel=""/>Pass 6: Acquiring information for lfsck
<anchor xml:id="dbdoclet.50438225_pgfId-1290335" xreflabel=""/>OST: &apos;lustre-OST0000_UUID&apos; ost idx 0: compat 0x2 rocomp 0 incomp 0x2
<anchor xml:id="dbdoclet.50438225_pgfId-1290336" xreflabel=""/>OST: num files = 321
<anchor xml:id="dbdoclet.50438225_pgfId-1290337" xreflabel=""/>OST: last_id = 321
<anchor xml:id="dbdoclet.50438225_pgfId-1290338" xreflabel=""/> 
<anchor xml:id="dbdoclet.50438225_pgfId-1290358" xreflabel=""/>lustre-OST0000: ******* WARNING: Filesystem still has errors *******
<anchor xml:id="dbdoclet.50438225_pgfId-1290359" xreflabel=""/> 
<anchor xml:id="dbdoclet.50438225_pgfId-1290360" xreflabel=""/>   56 inodes used (0%)
<anchor xml:id="dbdoclet.50438225_pgfId-1290361" xreflabel=""/>   27 non-contiguous inodes (48.2%)
<anchor xml:id="dbdoclet.50438225_pgfId-1290362" xreflabel=""/>           # of inodes with ind/dind/tind blocks: 13/0/0
<anchor xml:id="dbdoclet.50438225_pgfId-1290363" xreflabel=""/>59561 blocks used (5%)
<anchor xml:id="dbdoclet.50438225_pgfId-1290364" xreflabel=""/>   0 bad blocks
<anchor xml:id="dbdoclet.50438225_pgfId-1290365" xreflabel=""/>   1 large file
<anchor xml:id="dbdoclet.50438225_pgfId-1290366" xreflabel=""/>   329 regular files
<anchor xml:id="dbdoclet.50438225_pgfId-1290367" xreflabel=""/>   39 directories
<anchor xml:id="dbdoclet.50438225_pgfId-1290368" xreflabel=""/>   0 character device files
<anchor xml:id="dbdoclet.50438225_pgfId-1290369" xreflabel=""/>   0 block device files
<anchor xml:id="dbdoclet.50438225_pgfId-1290370" xreflabel=""/>   0 fifos
<anchor xml:id="dbdoclet.50438225_pgfId-1290371" xreflabel=""/>   0 links
<anchor xml:id="dbdoclet.50438225_pgfId-1290372" xreflabel=""/>   0 symbolic links (0 fast symbolic links)
<anchor xml:id="dbdoclet.50438225_pgfId-1290373" xreflabel=""/>   0 sockets
<anchor xml:id="dbdoclet.50438225_pgfId-1290374" xreflabel=""/>   --------
<anchor xml:id="dbdoclet.50438225_pgfId-1290375" xreflabel=""/>   368 files
<anchor xml:id="dbdoclet.50438225_pgfId-1290356" xreflabel=""/> 
</screen>
  </listitem><listitem>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290316" xreflabel=""/>Make the mdsdb file and all ostdb files available on a mounted client and run lfsck to examine the file system. Optionally, correct the defects found by lfsck.</para>
      <screen><anchor xml:id="dbdoclet.50438225_pgfId-1289934" xreflabel=""/>script /root/lfsck.lustre.log 
<anchor xml:id="dbdoclet.50438225_pgfId-1290406" xreflabel=""/>lfsck -n -v --mdsdb /tmp/mdsdb --ostdb /tmp/{ost1db} /tmp/{ost2db} ... /lus\
tre/mount/point
</screen>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290428" xreflabel=""/><emphasis role="bold">Example:</emphasis></para>
      <screen><anchor xml:id="dbdoclet.50438225_pgfId-1290429" xreflabel=""/>script /root/lfsck.lustre.log
<anchor xml:id="dbdoclet.50438225_pgfId-1290430" xreflabel=""/>lfsck -n -v --mdsdb /home/mdsdb --ostdb /home/{ost1db} \/mnt/lustre/client/
<anchor xml:id="dbdoclet.50438225_pgfId-1290431" xreflabel=""/>MDSDB: /home/mdsdb
<anchor xml:id="dbdoclet.50438225_pgfId-1290432" xreflabel=""/>OSTDB[0]: /home/ostdb
<anchor xml:id="dbdoclet.50438225_pgfId-1290433" xreflabel=""/>MOUNTPOINT: /mnt/lustre/client/
<anchor xml:id="dbdoclet.50438225_pgfId-1290434" xreflabel=""/>MDS: max_id 288 OST: max_id 321
<anchor xml:id="dbdoclet.50438225_pgfId-1290435" xreflabel=""/>lfsck: ost_idx 0: pass1: check for duplicate objects
<anchor xml:id="dbdoclet.50438225_pgfId-1290436" xreflabel=""/>lfsck: ost_idx 0: pass1 OK (287 files total)
<anchor xml:id="dbdoclet.50438225_pgfId-1290437" xreflabel=""/>lfsck: ost_idx 0: pass2: check for missing inode objects
<anchor xml:id="dbdoclet.50438225_pgfId-1290438" xreflabel=""/>lfsck: ost_idx 0: pass2 OK (287 objects)
<anchor xml:id="dbdoclet.50438225_pgfId-1290439" xreflabel=""/>lfsck: ost_idx 0: pass3: check for orphan objects
<anchor xml:id="dbdoclet.50438225_pgfId-1290440" xreflabel=""/>[0] uuid lustre-OST0000_UUID
<anchor xml:id="dbdoclet.50438225_pgfId-1290441" xreflabel=""/>[0] last_id 288
<anchor xml:id="dbdoclet.50438225_pgfId-1290442" xreflabel=""/>[0] zero-length orphan objid 1
<anchor xml:id="dbdoclet.50438225_pgfId-1290443" xreflabel=""/>lfsck: ost_idx 0: pass3 OK (321 files total)
<anchor xml:id="dbdoclet.50438225_pgfId-1290444" xreflabel=""/>lfsck: pass4: check for duplicate object references
<anchor xml:id="dbdoclet.50438225_pgfId-1290445" xreflabel=""/>lfsck: pass4 OK (no duplicates)
<anchor xml:id="dbdoclet.50438225_pgfId-1290446" xreflabel=""/>lfsck: fixed 0 errors
</screen>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1290426" xreflabel=""/>By default, lfsck reports errors, but it does not repair any inconsistencies found. lfsck checks for three kinds of inconsistencies:</para>
      <itemizedlist><listitem>
          <para><anchor xml:id="dbdoclet.50438225_pgfId-1290034" xreflabel=""/> Inode exists but has missing objects (dangling inode). This normally happens if there was a problem with an OST.</para>
        </listitem>

<listitem>
          <para><anchor xml:id="dbdoclet.50438225_pgfId-1290418" xreflabel=""/> Inode is missing but OST has unreferenced objects (orphan object). Normally, this happens if there was a problem with the MDS.</para>
        </listitem>

<listitem>
          <para><anchor xml:id="dbdoclet.50438225_pgfId-1290421" xreflabel=""/> Multiple inodes reference the same objects. This can happen if the MDS is corrupted or if the MDS storage is cached and loses some, but not all, writes.</para>
        </listitem>

</itemizedlist>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1289943" xreflabel=""/>If the file system is in use and being modified while the --mdsdb and --ostdb steps are running, lfsck may report inconsistencies where none exist due to files and objects being created/removed after the database files were collected. Examine the lfsck results closely. You may want to re-run the test.</para>
  </listitem></orderedlist>
      <section remap="h3">
        <title><anchor xml:id="dbdoclet.50438225_pgfId-1290574" xreflabel=""/>27.2.1 <anchor xml:id="dbdoclet.50438225_13916" xreflabel=""/>Working with Orphaned <anchor xml:id="dbdoclet.50438225_marker-1292187" xreflabel=""/>Objects</title>
        <para><anchor xml:id="dbdoclet.50438225_pgfId-1289945" xreflabel=""/>The easiest problem to resolve is that of orphaned objects. When the -l option for lfsck is used, these objects are linked to new files and put into lost+found in the Lustre file system, where they can be examined and saved or deleted as necessary. If you are certain the objects are not useful, run lfsck with the -d option to delete orphaned objects and free up any space they are using.</para>
        <para><anchor xml:id="dbdoclet.50438225_pgfId-1290628" xreflabel=""/>To fix dangling inodes, use lfsck with the -c option to create new, zero-length objects on the OSTs. These files read back with binary zeros for stripes that had objects re-created. Even without lfsck repair, these files can be read by entering:</para>
        <screen><anchor xml:id="dbdoclet.50438225_pgfId-1289949" xreflabel=""/>dd if=/lustre/bad/file of=/new/file bs=4k conv=sync,noerror
</screen>
        <para><anchor xml:id="dbdoclet.50438225_pgfId-1289951" xreflabel=""/>Because it is rarely useful to have files with large holes in them, most users delete these files after reading them (if useful) and/or restoring them from backup.</para>
                <note><para>You cannot write to the holes of such files without having lfsck re-create the objects. Generally, it is easier to delete these files and restore them from backup.</para></note>
        <para><anchor xml:id="dbdoclet.50438225_pgfId-1289916" xreflabel=""/>To fix inodes with duplicate objects, use lfsck with the -c option to copy the duplicate object to a new object and assign it to a file. One file will be okay and the duplicate will likely contain garbage. By itself, lfsck cannot tell which file is the usable one.</para>
      </section>
    </section>
    <section xml:id="dbdoclet.50438225_12316">
      <title>27.3 Recovering from an <anchor xml:id="dbdoclet.50438225_marker-1292768" xreflabel=""/>Unavailable OST</title>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1292771" xreflabel=""/>One of the most common problems encountered in a Lustre environment is when an OST becomes unavailable, because of a network partition, OSS node crash, etc. When this happens, the OSTâ€™s clients pause and wait for the OST to become available again, either on the primary OSS or a failover OSS. When the OST comes back online, Lustre starts a recovery process to enable clients to reconnect to the OST. Lustre servers put a limit on the time they will wait in recovery for clients to reconnect. The timeout length is determined by the obd_timeout parameter.</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1292775" xreflabel=""/>During recovery, clients reconnect and replay their requests serially, in the same order they were done originally. Until a client receives a confirmation that a given transaction has been written to stable storage, the client holds on to the transaction, in case it needs to be replayed. Periodically, a progress message prints to the log, stating how_many/expected clients have reconnected. If the recovery is aborted, this log shows how many clients managed to reconnect. When all clients have completed recovery, or if the recovery timeout is reached, the recovery period ends and the OST resumes normal request processing.</para>
      <para><anchor xml:id="dbdoclet.50438225_pgfId-1292779" xreflabel=""/>If some clients fail to replay their requests during the recovery period, this will not stop the recovery from completing. You may have a situation where the OST recovers, but some clients are not able to participate in recovery (e.g. network problems or client failure), so they are evicted and their requests are not replayed. This would result in any operations on the evicted clients failing, including in-progress writes, which would cause cached writes to be lost. This is a normal outcome; the recovery cannot wait indefinitely, or the file system would be hung any time a client failed. The lost transactions are an unfortunate result of the recovery process.</para>
      <note><para>The version-based recovery (VBR) feature enables a failed client to be &apos;&apos;skipped&apos;&apos;, so remaining clients can replay their requests, resulting in a more successful recovery from a downed OST. For more information about the VBR feature, see <xref linkend='lustrerecovery'/>(Version-based Recovery).</para></note>
  </section>
</chapter>
