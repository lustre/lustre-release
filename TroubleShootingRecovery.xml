<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:lang="en-US" xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" xml:id='troubleshootingrecovery'>
  <info>
    <title xml:id='troubleshootingrecovery.title'>Troubleshooting Recovery</title>
  </info>
  <para>This chapter describes what to do if something goes wrong during recovery. It describes:</para>

  <itemizedlist><listitem>
      <para><xref linkend="dbdoclet.50438225_71141"/></para>
    </listitem>

<listitem>
      <para><xref linkend="dbdoclet.50438225_37365"/></para>
    </listitem>

<listitem>
      <para><xref linkend="dbdoclet.50438225_12316"/></para>
    </listitem>

</itemizedlist>

    <section xml:id="dbdoclet.50438225_71141">
      <title>27.1 Recovering from Errors or <anchor xml:id="dbdoclet.50438225_marker-1292184" xreflabel=""/>Corruption on a Backing File System</title>
      <para>When an OSS, MDS, or MGS server crash occurs, it is not necessary to run e2fsck on the file system. ldiskfs journaling ensures that the file system remains coherent. The backing file systems are never accessed directly from the client, so client crashes are not relevant.</para>
      <para>The only time it is REQUIRED that e2fsck be run on a device is when an event causes problems that ldiskfs journaling is unable to handle, such as a hardware device failure or I/O error. If the ldiskfs kernel code detects corruption on the disk, it mounts the file system as read-only to prevent further corruption, but still allows read access to the device. This appears as error &quot;-30&quot; (EROFS) in the syslogs on the server, e.g.:</para>
      <screen>Dec 29 14:11:32 mookie kernel: LDISKFS-fs error (device sdz): ldiskfs_looku\
p: unlinked inode 5384166 in dir #145170469
</screen>
      <para>Dec 29 14:11:32 mookie kernel: Remounting filesystem read-only</para>
      <para>In such a situation, it is normally required that e2fsck only be run on the bad device before placing the device back into service.</para>
      <para>In the vast majority of cases, Lustre can cope with any inconsistencies it finds on the disk and between other devices in the file system.</para>
              <note><para>lfsck is rarely required for Lustre operation.</para></note>
      <para>For problem analysis, it is strongly recommended that e2fsck be run under a logger, like script, to record all of the output and changes that are made to the file system in case this information is needed later.</para>
      <para>If time permits, it is also a good idea to first run e2fsck in non-fixing mode (-n option) to assess the type and extent of damage to the file system. The drawback is that in this mode, e2fsck does not recover the file system journal, so there may appear to be file system corruption when none really exists.</para>
      <para>To address concern about whether corruption is real or only due to the journal not being replayed, you can briefly mount and unmount the ldiskfs filesystem directly on the node with Lustre stopped (NOT via Lustre), using a command similar to:</para>
      <screen>mount -t ldiskfs /dev/{ostdev} /mnt/ost; umount /mnt/ost
</screen>
      <para>This causes the journal to be recovered.</para>
      <para>The e2fsck utility works well when fixing file system corruption (better than similar file system recovery tools and a primary reason why ldiskfs was chosen over other file systems for Lustre). However, it is often useful to identify the type of damage that has occurred so an ldiskfs expert can make intelligent decisions about what needs fixing, in place of e2fsck.</para>
      <screen>root# {stop lustre services for this device, if running} 
root# script /tmp/e2fsck.sda 
Script started, file is /tmp/e2fsck.sda 
root# mount -t ldiskfs /dev/sda /mnt/ost 
root# umount /mnt/ost 
root# e2fsck -fn /dev/sda   # don&apos;t fix file system, just check for corrupt\
ion 
: 
[e2fsck output] 
: 
root# e2fsck -fp /dev/sda   # fix filesystem using &quot;prudent&quot; answers (usually\
 &apos;y&apos;)
</screen>
      <para>In addition, the e2fsprogs package contains the lfsck tool, which does distributed coherency checking for the Lustre file system after e2fsck has been run. Running lfsck is NOT required in a large majority of cases, at a small risk of having some leaked space in the file system. To avoid a lengthy downtime, it can be run (with care) after Lustre is started.</para>
    </section>
    <section xml:id="dbdoclet.50438225_37365">
      <title>27.2 Recovering from <anchor xml:id="dbdoclet.50438225_marker-1292186" xreflabel=""/>Corruption in the Lustre File System</title>
      <para>In cases where the MDS or an OST becomes corrupt, you can run a distributed check on the file system to determine what sort of problems exist. Use lfsck to correct any defects found.</para>
      <orderedlist><listitem>
      <para>Stop the Lustre file system.</para>
  </listitem><listitem>
      <para>Run e2fsck -f on the individual MDS / OST that had problems to fix any local file system damage.</para>
      <para>We recommend running e2fsck under script, to create a log of changes made to the file system in case it is needed later. After e2fsck is run, bring up the file system, if necessary, to reduce the outage window.</para>
  </listitem><listitem>
      <para>Run a full e2fsck of the MDS to create a database for lfsck. You <emphasis>must</emphasis> use the -n option for a mounted file system, otherwise you will corrupt the file system.</para>
      <screen>e2fsck -n -v --mdsdb /tmp/mdsdb /dev/{mdsdev}
</screen>
      <para>The mdsdb file can grow fairly large, depending on the number of files in the file system (10 GB or more for millions of files, though the actual file size is larger because the file is sparse). It is quicker to write the file to a local file system due to seeking and small writes. Depending on the number of files, this step can take several hours to complete.</para>
      <para><emphasis role="bold">Example</emphasis></para>
      <screen>e2fsck -n -v --mdsdb /tmp/mdsdb /dev/sdb
e2fsck 1.39.cfs1 (29-May-2006)
Warning: skipping journal recovery because doing a read-only filesystem che\
ck.
lustre-MDT0000 contains a file system with errors, check forced.
Pass 1: Checking inodes, blocks, and sizes
MDS: ost_idx 0 max_id 288
MDS: got 8 bytes = 1 entries in lov_objids
MDS: max_files = 13
MDS: num_osts = 1
mds info db file written
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
Free blocks count wrong (656160, counted=656058).
Fix? no
 
Free inodes count wrong (786419, counted=786036).
Fix? no
 
Pass 6: Acquiring information for lfsck
MDS: max_files = 13
MDS: num_osts = 1
MDS: &apos;lustre-MDT0000_UUID&apos; mdt idx 0: compat 0x4 rocomp 0x1 incomp 0x4
lustre-MDT0000: ******* WARNING: Filesystem still has errors *******
   13 inodes used (0%)
           2 non-contiguous inodes (15.4%)
                   # of inodes with ind/dind/tind blocks: 0/0/0
130272 blocks used (16%)
   0 bad blocks
   1 large file
   296 regular files
   91 directories
   0 character device files
   0 block device files
   0 fifos
   0 links
   0 symbolic links (0 fast symbolic links)
   0 sockets
   --------
   387 files
</screen>
  </listitem><listitem>
      <para>Make this file accessible on all OSTs, either by using a shared file system or copying the file to the OSTs. The pdcp command is useful here.</para>
      <para>The pdcp command (installed with pdsh), can be used to copy files to groups of hosts. Pdcp is available here:</para>
      <para><link xl:href="http://sourceforge.net/projects/pdsh">http://sourceforge.net/projects/pdsh</link></para>
  </listitem><listitem>
      <para>Run a similar e2fsck step on the OSTs. The e2fsck --ostdb command can be run in parallel on all OSTs.</para>
      <screen>e2fsck -n -v --mdsdb /tmp/mdsdb --ostdb /tmp/{ostNdb} \/dev/{ostNdev}
</screen>
      <para>The mdsdb file is read-only in this step; a single copy can be shared by all OSTs.</para>
              <note><para>If the OSTs do not have shared file system access to the MDS, a stub mdsdb file, {mdsdb}.mdshdr, is generated. This can be used instead of the full mdsdb file.</para></note>
       <para><emphasis role="bold">Example:</emphasis></para>
      <screen>[root@oss161 ~]# e2fsck -n -v --mdsdb /tmp/mdsdb --ostdb \ /tmp/ostdb /dev/\
sda 
e2fsck 1.39.cfs1 (29-May-2006)
Warning: skipping journal recovery because doing a read-only filesystem che\
ck.
lustre-OST0000 contains a file system with errors, check forced.
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
Free blocks count wrong (989015, counted=817968).
Fix? no
 
Free inodes count wrong (262088, counted=261767).
Fix? no
 
Pass 6: Acquiring information for lfsck
OST: &apos;lustre-OST0000_UUID&apos; ost idx 0: compat 0x2 rocomp 0 incomp 0x2
OST: num files = 321
OST: last_id = 321
 
lustre-OST0000: ******* WARNING: Filesystem still has errors *******
 
   56 inodes used (0%)
   27 non-contiguous inodes (48.2%)
           # of inodes with ind/dind/tind blocks: 13/0/0
59561 blocks used (5%)
   0 bad blocks
   1 large file
   329 regular files
   39 directories
   0 character device files
   0 block device files
   0 fifos
   0 links
   0 symbolic links (0 fast symbolic links)
   0 sockets
   --------
   368 files
 
</screen>
  </listitem><listitem>
      <para>Make the mdsdb file and all ostdb files available on a mounted client and run lfsck to examine the file system. Optionally, correct the defects found by lfsck.</para>
      <screen>script /root/lfsck.lustre.log 
lfsck -n -v --mdsdb /tmp/mdsdb --ostdb /tmp/{ost1db} /tmp/{ost2db} ... /lus\
tre/mount/point
</screen>
      <para><emphasis role="bold">Example:</emphasis></para>
      <screen>script /root/lfsck.lustre.log
lfsck -n -v --mdsdb /home/mdsdb --ostdb /home/{ost1db} \/mnt/lustre/client/
MDSDB: /home/mdsdb
OSTDB[0]: /home/ostdb
MOUNTPOINT: /mnt/lustre/client/
MDS: max_id 288 OST: max_id 321
lfsck: ost_idx 0: pass1: check for duplicate objects
lfsck: ost_idx 0: pass1 OK (287 files total)
lfsck: ost_idx 0: pass2: check for missing inode objects
lfsck: ost_idx 0: pass2 OK (287 objects)
lfsck: ost_idx 0: pass3: check for orphan objects
[0] uuid lustre-OST0000_UUID
[0] last_id 288
[0] zero-length orphan objid 1
lfsck: ost_idx 0: pass3 OK (321 files total)
lfsck: pass4: check for duplicate object references
lfsck: pass4 OK (no duplicates)
lfsck: fixed 0 errors
</screen>
      <para>By default, lfsck reports errors, but it does not repair any inconsistencies found. lfsck checks for three kinds of inconsistencies:</para>
      <itemizedlist><listitem>
          <para> Inode exists but has missing objects (dangling inode). This normally happens if there was a problem with an OST.</para>
        </listitem>

<listitem>
          <para> Inode is missing but OST has unreferenced objects (orphan object). Normally, this happens if there was a problem with the MDS.</para>
        </listitem>

<listitem>
          <para> Multiple inodes reference the same objects. This can happen if the MDS is corrupted or if the MDS storage is cached and loses some, but not all, writes.</para>
        </listitem>

</itemizedlist>
      <para>If the file system is in use and being modified while the --mdsdb and --ostdb steps are running, lfsck may report inconsistencies where none exist due to files and objects being created/removed after the database files were collected. Examine the lfsck results closely. You may want to re-run the test.</para>
  </listitem></orderedlist>
      <section remap="h3">
        <title>27.2.1 <anchor xml:id="dbdoclet.50438225_13916" xreflabel=""/>Working with Orphaned <anchor xml:id="dbdoclet.50438225_marker-1292187" xreflabel=""/>Objects</title>
        <para>The easiest problem to resolve is that of orphaned objects. When the -l option for lfsck is used, these objects are linked to new files and put into lost+found in the Lustre file system, where they can be examined and saved or deleted as necessary. If you are certain the objects are not useful, run lfsck with the -d option to delete orphaned objects and free up any space they are using.</para>
        <para>To fix dangling inodes, use lfsck with the -c option to create new, zero-length objects on the OSTs. These files read back with binary zeros for stripes that had objects re-created. Even without lfsck repair, these files can be read by entering:</para>
        <screen>dd if=/lustre/bad/file of=/new/file bs=4k conv=sync,noerror
</screen>
        <para>Because it is rarely useful to have files with large holes in them, most users delete these files after reading them (if useful) and/or restoring them from backup.</para>
                <note><para>You cannot write to the holes of such files without having lfsck re-create the objects. Generally, it is easier to delete these files and restore them from backup.</para></note>
        <para>To fix inodes with duplicate objects, use lfsck with the -c option to copy the duplicate object to a new object and assign it to a file. One file will be okay and the duplicate will likely contain garbage. By itself, lfsck cannot tell which file is the usable one.</para>
      </section>
    </section>
    <section xml:id="dbdoclet.50438225_12316">
      <title>27.3 Recovering from an <anchor xml:id="dbdoclet.50438225_marker-1292768" xreflabel=""/>Unavailable OST</title>
      <para>One of the most common problems encountered in a Lustre environment is when an OST becomes unavailable, because of a network partition, OSS node crash, etc. When this happens, the OST's clients pause and wait for the OST to become available again, either on the primary OSS or a failover OSS. When the OST comes back online, Lustre starts a recovery process to enable clients to reconnect to the OST. Lustre servers put a limit on the time they will wait in recovery for clients to reconnect. The timeout length is determined by the obd_timeout parameter.</para>
      <para>During recovery, clients reconnect and replay their requests serially, in the same order they were done originally. Until a client receives a confirmation that a given transaction has been written to stable storage, the client holds on to the transaction, in case it needs to be replayed. Periodically, a progress message prints to the log, stating how_many/expected clients have reconnected. If the recovery is aborted, this log shows how many clients managed to reconnect. When all clients have completed recovery, or if the recovery timeout is reached, the recovery period ends and the OST resumes normal request processing.</para>
      <para>If some clients fail to replay their requests during the recovery period, this will not stop the recovery from completing. You may have a situation where the OST recovers, but some clients are not able to participate in recovery (e.g. network problems or client failure), so they are evicted and their requests are not replayed. This would result in any operations on the evicted clients failing, including in-progress writes, which would cause cached writes to be lost. This is a normal outcome; the recovery cannot wait indefinitely, or the file system would be hung any time a client failed. The lost transactions are an unfortunate result of the recovery process.</para>
      <note><para>The version-based recovery (VBR) feature enables a failed client to be &apos;&apos;skipped&apos;&apos;, so remaining clients can replay their requests, resulting in a more successful recovery from a downed OST. For more information about the VBR feature, see <xref linkend='lustrerecovery'/>(Version-based Recovery).</para></note>
  </section>
</chapter>
