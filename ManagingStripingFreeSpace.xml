<?xml version='1.0' encoding='UTF-8'?><chapter xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en-US" xml:id="managingstripingfreespace">
  <title xml:id="managingstripingfreespace.title">Managing File Layout (Striping) and Free
    Space</title>
  <para>This chapter describes file layout (striping) and I/O options, and includes the following
    sections:</para>
  <itemizedlist>
    <listitem>
      <para><xref linkend="dbdoclet.50438209_79324"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438209_48033"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438209_78664"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438209_44776"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438209_10424"/></para>
    </listitem>
    <listitem>
      <para><xref xmlns:xlink="http://www.w3.org/1999/xlink" linkend="section_syy_gcl_qk"/></para>
    </listitem>
  </itemizedlist>
  <section xml:id="dbdoclet.50438209_79324">
      <title>
      <indexterm>
        <primary>space</primary>
      </indexterm>
      <indexterm>
        <primary>striping</primary>
        <secondary>how it works</secondary>
      </indexterm>
      <indexterm>
        <primary>striping</primary>
        <see>space</see>
      </indexterm>
      <indexterm>
        <primary>space</primary>
        <secondary>striping</secondary>
      </indexterm>How Lustre File System Striping Works</title>
    <para>In a Lustre file system, the MDS allocates objects to OSTs using either a round-robin
      algorithm or a weighted algorithm. When the amount of free space is well balanced (i.e., by
      default, when the free space across OSTs differs by less than 17%), the round-robin algorithm
      is used to select the next OST to which a stripe is to be written. Periodically, the MDS
      adjusts the striping layout to eliminate some degenerated cases in which applications that
      create very regular file layouts (striping patterns) preferentially use a particular OST in
      the sequence.</para>
    <para> Normally the usage of OSTs is well balanced. However, if users create a small number of
      exceptionally large files or incorrectly specify striping parameters, imbalanced OST usage may
      result. When the free space across OSTs differs by more than a specific amount (17% by
      default), the MDS then uses weighted random allocations with a preference for allocating
      objects on OSTs with more free space. (This can reduce I/O performance until space usage is
      rebalanced again.) For a more detailed description of how striping is allocated, see <xref
        linkend="dbdoclet.50438209_10424"/>.</para>
    <para condition="l22">Files can only be striped over a finite number of OSTs. Prior to Lustre
      software release 2.2, the maximum number of OSTs that a file could be striped across was
      limited to 160. As of Lustre software release 2.2, the maximum number of OSTs is 2000. For
      more information, see <xref xmlns:xlink="http://www.w3.org/1999/xlink"
        linkend="section_syy_gcl_qk"/>.</para>
  </section>
  <section xml:id="dbdoclet.50438209_48033">
      <title><indexterm>
        <primary>file layout</primary>
        <secondary>See striping</secondary>
      </indexterm><indexterm>
        <primary>striping</primary>
        <secondary>considerations</secondary>
      </indexterm>
      <indexterm>
        <primary>space</primary>
        <secondary>considerations</secondary>
      </indexterm> Lustre File Layout (Striping) Considerations</title>
    <para>Whether you should set up file striping and what parameter values you select depends on
      your needs. A good rule of thumb is to stripe over as few objects as will meet those needs and
      no more.</para>
    <para>Some reasons for using striping include:</para>
    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Providing high-bandwidth access.</emphasis> Many applications
          require high-bandwidth access to a single file, which may be more bandwidth than can be
          provided by a single OSS. Examples are a scientific application that writes to a single
          file from hundreds of nodes, or a binary executable that is loaded by many nodes when an
          application starts.</para>
        <para>In cases like these, a file can be striped over as many OSSs as it takes to achieve
          the required peak aggregate bandwidth for that file. Striping across a larger number of
          OSSs should only be used when the file size is very large and/or is accessed by many nodes
          at a time. Currently, Lustre files can be striped across up to 2000 OSTs, the maximum
          stripe count for an <literal>ldiskfs</literal> file system.</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Improving performance when OSS bandwidth is exceeded.</emphasis>
          Striping across many OSSs can improve performance if the aggregate client bandwidth
          exceeds the server bandwidth and the application reads and writes data fast enough to take
          advantage of the additional OSS bandwidth. The largest useful stripe count is bounded by
          the I/O rate of the clients/jobs divided by the performance per OSS.</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Providing space for very large files.</emphasis> Striping is
          useful when a single OST does not have enough free space to hold the entire file.</para>
      </listitem>
    </itemizedlist>
    <para>Some reasons to minimize or avoid striping:</para>
    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Increased overhead.</emphasis> Striping results in more locks
          and extra network operations during common operations such as <literal>stat</literal> and
            <literal>unlink</literal>. Even when these operations are performed in parallel, one
          network operation takes less time than 100 operations.</para>
        <para>Increased overhead also results from server contention. Consider a cluster with 100
          clients and 100 OSSs, each with one OST. If each file has exactly one object and the load
          is distributed evenly, there is no contention and the disks on each server can manage
          sequential I/O. If each file has 100 objects, then the clients all compete with one
          another for the attention of the servers, and the disks on each node seek in 100 different
          directions resulting in needless contention.</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Increased risk.</emphasis> When files are striped across all
          servers and one of the servers breaks down, a small part of each striped file is lost. By
          comparison, if each file has exactly one stripe, fewer files are lost, but they are lost
          in their entirety. Many users would prefer to lose some of their files entirely than all
          of their files partially.</para>
      </listitem>
    </itemizedlist>
    <section remap="h3">
        <title><indexterm><primary>striping</primary><secondary>size</secondary></indexterm>
            Choosing a Stripe Size</title>
      <para>Choosing a stripe size is a balancing act, but reasonable defaults are described below.
        The stripe size has no effect on a single-stripe file.</para>
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">The stripe size must be a multiple of the page
              size.</emphasis> Lustre software tools enforce a multiple of 64 KB (the maximum page
            size on ia64 and PPC64 nodes) so that users on platforms with smaller pages do not
            accidentally create files that might cause problems for ia64 clients.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">The smallest recommended stripe size is 512 KB.</emphasis>
            Although you can create files with a stripe size of 64 KB, the smallest practical stripe
            size is 512 KB because the Lustre file system sends 1MB chunks over the network.
            Choosing a smaller stripe size may result in inefficient I/O to the disks and reduced
            performance.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">A good stripe size for sequential I/O using high-speed
              networks is between 1 MB and 4 MB.</emphasis> In most situations, stripe sizes larger
            than 4 MB may result in longer lock hold times and contention during shared file
            access.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">The maximum stripe size is 4 GB.</emphasis> Using a large
            stripe size can improve performance when accessing very large files. It allows each
            client to have exclusive access to its own part of a file. However, a large stripe size
            can be counterproductive in cases where it does not match your I/O pattern.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Choose a stripe pattern that takes into account the write
              patterns of your application.</emphasis> Writes that cross an object boundary are
            slightly less efficient than writes that go entirely to one server. If the file is
            written in a consistent and aligned way, make the stripe size a multiple of the
              <literal>write()</literal> size.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section xml:id="dbdoclet.50438209_78664">
      <title><indexterm>
        <primary>striping</primary>
        <secondary>configuration</secondary>
      </indexterm>Setting the File Layout/Striping Configuration (<literal>lfs
      setstripe</literal>)</title>
    <para>Use the <literal>lfs setstripe</literal> command to create new files with a specific file layout (stripe pattern) configuration.</para>
    <screen>lfs setstripe [--size|-s stripe_size] [--count|-c stripe_count] \
[--index|-i start_ost] [--pool|-p pool_name] <replaceable>filename|dirname</replaceable> </screen>
    <para><emphasis role="bold">
        <literal>stripe_size</literal>
      </emphasis>
      </para>
    <para>The <literal>stripe_size</literal> indicates how much data to write to one OST before
      moving to the next OST. The default <literal>stripe_size</literal> is 1 MB. Passing a
        <literal>stripe_size</literal> of 0 causes the default stripe size to be used. Otherwise,
      the <literal>stripe_size</literal> value must be a multiple of 64 KB.</para>
    <para><emphasis role="bold">
        <literal>stripe_count</literal>
      </emphasis>
      </para>
    <para>The <literal>stripe_count</literal> indicates how many OSTs to use. The default <literal>stripe_count</literal> value is 1. Setting <literal>stripe_count</literal> to 0 causes the default stripe count to be used. Setting <literal>stripe_count</literal> to -1 means stripe over all available OSTs (full OSTs are skipped).</para>
    <para><emphasis role="bold">
        <literal>start_ost</literal>
      </emphasis>
      </para>
    <para>The start OST is the first OST to which files are written. The default value for
        <literal>start_ost</literal> is -1, which allows the MDS to choose the starting index. This
      setting is strongly recommended, as it allows space and load balancing to be done by the MDS
      as needed. If the value of <literal>start_ost</literal> is set to a value other than -1, the
      file starts on the specified OST index. OST index numbering starts at 0.</para>
    <note>
      <para>If the specified OST is inactive or in a degraded mode, the MDS will silently choose
        another target.</para>
    </note>
    <note>
      <para>If you pass a <literal>start_ost</literal> value of 0 and a
          <literal>stripe_count</literal> value of <emphasis>1</emphasis>, all files are written to
        OST 0, until space is exhausted. <emphasis role="italic">This is probably not what you meant
          to do.</emphasis> If you only want to adjust the stripe count and keep the other
        parameters at their default settings, do not specify any of the other parameters:</para>
      <para><screen>client# lfs setstripe -c <replaceable>stripe_count</replaceable> <replaceable>filename</replaceable></screen></para>
    </note>
    <para><emphasis role="bold">
        <literal>pool_name</literal>
      </emphasis>
      </para>
    <para>The <literal>pool_name</literal> specifies the OST pool to which the file will be written.
      This allows limiting the OSTs used to a subset of all OSTs in the file system. For more
      details about using OST pools, see <link xl:href="ManagingFileSystemIO.html#50438211_75549"
        >Creating and Managing OST Pools</link>.</para>
    <section remap="h3">
      <title>Specifying a File Layout (Striping Pattern) for a Single File</title>
      <para>It is possible to specify the file layout when a new file is created using the command <literal>lfs setstripe</literal>. This allows users to override the file system default parameters to tune the file layout more optimally for their application. Execution of an <literal>lfs setstripe</literal> command fails if the file already exists.</para>
      <section xml:id="dbdoclet.50438209_60155">
        <title>Setting the Stripe Size</title>
        <para>The command to create a new file with a specified stripe size is similar to:</para>
        <screen>[client]# lfs setstripe -s 4M /mnt/lustre/new_file</screen>
        <para>This example command creates the new file <literal>/mnt/lustre/new_file</literal> with a stripe size of 4 MB.</para>
        <para>Now, when the file is created, the new stripe setting creates the file on a single OST with a stripe size of 4M:</para>
        <screen> [client]# lfs getstripe /mnt/lustre/new_file
/mnt/lustre/4mb_file
lmm_stripe_count:   1
lmm_stripe_size:    4194304
lmm_pattern:        1
lmm_layout_gen:     0
lmm_stripe_offset:  1
obdidx     objid        objid           group
1          690550       0xa8976         0 </screen>
        <para>In this example, the stripe size is 4 MB.</para>
      </section>
      <section remap="h4">
          <title><indexterm><primary>striping</primary><secondary>count</secondary></indexterm>
              Setting the Stripe Count</title>
        <para>The command below creates a new file with a stripe count of <literal>-1</literal> to
          specify striping over all available OSTs:</para>
        <screen>[client]# lfs setstripe -c -1 /mnt/lustre/full_stripe</screen>
        <para>The example below indicates that the file <literal>full_stripe</literal> is striped
          over all six active OSTs in the configuration:</para>
        <screen>[client]# lfs getstripe /mnt/lustre/full_stripe
/mnt/lustre/full_stripe
  obdidx   objid   objid   group
  0        8       0x8     0
  1        4       0x4     0
  2        5       0x5     0
  3        5       0x5     0
  4        4       0x4     0
  5        2       0x2     0</screen>
        <para> This is in contrast to the output in <xref linkend="dbdoclet.50438209_60155"/>, which
          shows only a single object for the file.</para>
      </section>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>striping</primary>
          <secondary>per directory</secondary>
        </indexterm>Setting the Striping Layout for a Directory</title>
      <para>In a directory, the <literal>lfs setstripe</literal> command sets a default striping
        configuration for files created in the directory. The usage is the same as <literal>lfs
          setstripe</literal> for a regular file, except that the directory must exist prior to
        setting the default striping configuration. If a file is created in a directory with a
        default stripe configuration (without otherwise specifying striping), the Lustre file system
        uses those striping parameters instead of the file system default for the new file.</para>
      <para>To change the striping pattern for a sub-directory, create a directory with desired file
        layout as described above. Sub-directories inherit the file layout of the root/parent
        directory.</para>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>striping</primary>
          <secondary>per file system</secondary>
        </indexterm>Setting the Striping Layout for a File System</title>
      <para>Setting the striping specification on the <literal>root</literal> directory determines
        the striping for all new files created in the file system unless an overriding striping
        specification takes precedence (such as a striping layout specified by the application, or
        set using <literal>lfs setstripe</literal>, or specified for the parent directory).</para>
      <note>
        <para>The striping settings for a <literal>root</literal> directory are, by default, applied
          to any new child directories created in the root directory, unless striping settings have
          been specified for the child directory.</para>
      </note>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>striping</primary>
          <secondary>on specific OST</secondary>
        </indexterm>Creating a File on a Specific OST</title>
      <para>You can use <literal>lfs setstripe</literal> to create a file on a specific OST. In the
        following example, the file <literal>file1</literal> is created on the first OST (OST index
        is 0).</para>
      <screen>$ lfs setstripe --count 1 --index 0 file1
$ dd if=/dev/zero of=file1 count=1 bs=100M
1+0 records in
1+0 records out

$ lfs getstripe file1
/mnt/testfs/file1
lmm_stripe_count:   1
lmm_stripe_size:    1048576
lmm_pattern:        1
lmm_layout_gen:     0
lmm_stripe_offset:  0               
     obdidx    objid   objid    group                    
     0         37364   0x91f4   0</screen>
    </section>
  </section>
  <section xml:id="dbdoclet.50438209_44776">
    <title><indexterm><primary>striping</primary><secondary>getting information</secondary></indexterm>Retrieving File Layout/Striping Information (<literal>getstripe</literal>)</title>
    <para>The <literal>lfs getstripe</literal> command is used to display information that shows
      over which OSTs a file is distributed. For each OST, the index and UUID is displayed, along
      with the OST index and object ID for each stripe in the file. For directories, the default
      settings for files created in that directory are displayed.</para>
    <section remap="h3">
      <title>Displaying the Current Stripe Size</title>
      <para>To see the current stripe size for a Lustre file or directory, use the <literal>lfs
          getstripe</literal> command. For example, to view information for a directory, enter a
        command similar to:</para>
      <screen>[client]# lfs getstripe /mnt/lustre </screen>
      <para>This command produces output similar to:</para>
      <screen>/mnt/lustre 
(Default) stripe_count: 1 stripe_size: 1M stripe_offset: -1</screen>
      <para>In this example, the default stripe count is <literal>1</literal> (data blocks are
        striped over a single OST), the default stripe size is 1 MB, and the objects are created
        over all available OSTs.</para>
      <para>To view information for a file, enter a command similar to:</para>
      <screen>$ lfs getstripe /mnt/lustre/foo
/mnt/lustre/foo
lmm_stripe_count:   1
lmm_stripe_size:    1048576
lmm_pattern:        1
lmm_layout_gen:     0
lmm_stripe_offset:  0
  obdidx   objid    objid      group
  2        835487   m0xcbf9f   0 </screen>
      <para>In this example, the file is located on <literal>obdidx 2</literal>, which corresponds
        to the OST <literal>lustre-OST0002</literal>. To see which node is serving that OST, run:
        <screen>$ lctl get_param osc.lustre-OST0002-osc.ost_conn_uuid
osc.lustre-OST0002-osc.ost_conn_uuid=192.168.20.1@tcp</screen></para>
    </section>
    <section remap="h3">
      <title>Inspecting the File Tree</title>
      <para>To inspect an entire tree of files, use the <literal>lfs find</literal>  command:</para>
      <screen>lfs find [--recursive | -r] <replaceable>file|directory</replaceable> ...</screen>
    </section>
	<section>
      <title><indexterm>
          <primary>striping</primary>
          <secondary>remote directories</secondary>
        </indexterm>Locating the MDT for a remote directory</title>
      <para condition="l24">Lustre software release 2.4 can be configured with
          multiple MDTs in the same file system. Each sub-directory can have a
          different MDT. To identify on which MDT a given subdirectory is
          located, pass the <literal>getstripe [--mdt-index|-M]</literal>
          parameters to <literal>lfs</literal>. An example of this command is
          provided in the section <xref linkend="dbdoclet.rmremotedir"/>.</para>
    </section>
  </section>
  <section xml:id="dbdoclet.50438209_10424">
    <title><indexterm>
        <primary>space</primary>
        <secondary>free space</secondary>
      </indexterm><indexterm>
        <primary>striping</primary>
        <secondary>round-robin algorithm</secondary>
      </indexterm><indexterm>
        <primary>striping</primary>
        <secondary>weighted algorithm</secondary>
      </indexterm><indexterm>
        <primary>round-robin algorithm</primary>
      </indexterm><indexterm>
        <primary>weighted algorithm</primary>
      </indexterm>Managing Free Space</title>
    <para>To optimize file system performance, the MDT assigns file stripes to OSTs based on two
      allocation algorithms. The <emphasis role="italic">round-robin</emphasis> allocator gives
      preference to location (spreading out stripes across OSSs to increase network bandwidth
      utilization) and the weighted allocator gives preference to available space (balancing loads
      across OSTs). Threshold and weighting factors for these two algorithms can be adjusted by the
      user. The MDT reserves 0.1 percent of total OST space and 32 inodes for each OST. The MDT
      stops object allocation for the OST if available space is less than reserved or the OST has
      fewer than 32 free inodes. The MDT starts object allocation when available space is twice
      as big as the reserved space and the OST has more than 64 free inodes. Note, clients
      could append existing files no matter what object allocation state is.</para>
    <para condition="l29"> The reserved space for each OST can be adjusted by the user. Use the
      <literal>lctl set_param</literal> command, for example the next command reserve 1GB space
      for all OSTs.
      <screen>lctl set_param -P osp.*.reserved_mb_low=1024</screen></para>
    <para>This section describes how to check available free space on disks and how free space is
      allocated. It then describes how to set the threshold and weighting factors for the allocation
      algorithms.</para>
    <section xml:id="dbdoclet.50438209_35838">
      <title>Checking File System Free Space</title>
      <para>Free space is an important consideration in assigning file stripes. The <literal>lfs
          df</literal> command can be used to show available disk space on the mounted Lustre file
        system and space consumption per OST. If multiple Lustre file systems are mounted, a path
        may be specified, but is not required. Options to the <literal>lfs df</literal> command are
        shown below.</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Option</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <literal>-h</literal></para>
              </entry>
              <entry>
                <para> Displays sizes in human readable format (for example: 1K, 234M, 5G).</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal role="bold">-i, --inodes</literal></para>
              </entry>
              <entry>
                <para> Lists inodes instead of block usage.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <note>
        <para>The <literal>df -i</literal> and <literal>lfs df -i</literal> commands show the
            <emphasis role="italic">minimum</emphasis> number of inodes that can be created in the
          file system at the current time. If the total number of objects available across all of
          the OSTs is smaller than those available on the MDT(s), taking into account the default
          file striping, then <literal>df -i</literal> will also report a smaller number of inodes
          than could be created. Running <literal>lfs df -i</literal> will report the actual number
          of inodes that are free on each target.</para>
        <para>For ZFS file systems, the number of inodes that can be created is dynamic and depends
          on the free space in the file system. The Free and Total inode counts reported for a ZFS
          file system are only an estimate based on the current usage for each target. The Used
          inode count is the actual number of inodes used by the file system.</para>
      </note>
      <para><emphasis role="bold">Examples</emphasis></para>
      <screen>[client1] $ lfs df
UUID                1K-blockS  Used      Available Use% Mounted on
mds-lustre-0_UUID   9174328    1020024   8154304   11%  /mnt/lustre[MDT:0]
ost-lustre-0_UUID   94181368   56330708  37850660  59%  /mnt/lustre[OST:0]
ost-lustre-1_UUID   94181368   56385748  37795620  59%  /mnt/lustre[OST:1]
ost-lustre-2_UUID   94181368   54352012  39829356  57%  /mnt/lustre[OST:2]
filesystem summary: 282544104  167068468 39829356  57%  /mnt/lustre
 
[client1] $ lfs df -h
UUID                bytes    Used    Available   Use%  Mounted on
mds-lustre-0_UUID   8.7G     996.1M  7.8G        11%   /mnt/lustre[MDT:0]
ost-lustre-0_UUID   89.8G    53.7G   36.1G       59%   /mnt/lustre[OST:0]
ost-lustre-1_UUID   89.8G    53.8G   36.0G       59%   /mnt/lustre[OST:1]
ost-lustre-2_UUID   89.8G    51.8G   38.0G       57%   /mnt/lustre[OST:2]
filesystem summary: 269.5G   159.3G  110.1G      59%   /mnt/lustre
 
[client1] $ lfs df -i 
UUID                Inodes  IUsed IFree   IUse% Mounted on
mds-lustre-0_UUID   2211572 41924 2169648 1%    /mnt/lustre[MDT:0]
ost-lustre-0_UUID   737280  12183 725097  1%    /mnt/lustre[OST:0]
ost-lustre-1_UUID   737280  12232 725048  1%    /mnt/lustre[OST:1]
ost-lustre-2_UUID   737280  12214 725066  1%    /mnt/lustre[OST:2]
filesystem summary: 2211572 41924 2169648 1%    /mnt/lustre[OST:2]</screen>
    </section>
    <section remap="h3">
        <title><indexterm>
          <primary>striping</primary>
          <secondary>allocations</secondary>
        </indexterm> Stripe Allocation Methods</title>
      <para>Two stripe allocation methods are provided:</para>
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Round-robin allocator</emphasis> - When the OSTs have
            approximately the same amount of free space, the round-robin allocator alternates
            stripes between OSTs on different OSSs, so the OST used for stripe 0 of each file is
            evenly distributed among OSTs, regardless of the stripe count. In a simple example with
            eight OSTs numbered 0-7, objects would be allocated like this:</para>
          <para>
            <screen>File 1: OST1, OST2, OST3, OST4
File 2: OST5, OST6, OST7
File 3: OST0, OST1, OST2, OST3, OST4, OST5
File 4: OST6, OST7, OST0</screen>
          </para>
          <para>Here are several more sample round-robin stripe orders (each letter represents a
            different OST on a single OSS):</para>
          <informaltable frame="none">
            <tgroup cols="2">
              <colspec colname="c1" colwidth="50*"/>
              <colspec colname="c2" colwidth="50*"/>
              <tbody>
                <row>
                  <entry>
                    <para> 3: AAA</para>
                  </entry>
                  <entry>
                    <para> One 3-OST OSS</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para> 3x3: ABABAB</para>
                  </entry>
                  <entry>
                    <para> Two 3-OST OSSs</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para> 3x4: BBABABA</para>
                  </entry>
                  <entry>
                    <para> One 3-OST OSS (A) and one 4-OST OSS (B)</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para> 3x5: BBABBABA</para>
                  </entry>
                  <entry>
                    <para> One 3-OST OSS (A) and one 5-OST OSS (B)</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para> 3x3x3: ABCABCABC</para>
                  </entry>
                  <entry>
                    <para> Three 3-OST OSSs</para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Weighted allocator</emphasis> - When the free space difference
            between the OSTs becomes significant, the weighting algorithm is used to influence OST
            ordering based on size (amount of free space available on each OST) and location
            (stripes evenly distributed across OSTs). The weighted allocator fills the emptier OSTs
            faster, but uses a weighted random algorithm, so the OST with the most free space is not
            necessarily chosen each time.</para>
        </listitem>
      </itemizedlist>
      <para>The allocation method is determined by the amount of free-space imbalance on the OSTs.
        When free space is relatively balanced across OSTs, the faster round-robin allocator is
        used, which maximizes network balancing. The weighted allocator is used when any two OSTs
        are out of balance by more than the specified threshold (17% by default). The threshold
        between the two allocation methods is defined in the file
            <literal>/proc/fs/<replaceable>fsname</replaceable>/lov/<replaceable>fsname</replaceable>-mdtlov/qos_threshold_rr</literal>. </para>
      <para>To set the <literal>qos_threshold_r</literal> to <literal>25</literal>,  enter this
        command on the
        MGS:<screen>lctl set_param lov.<replaceable>fsname</replaceable>-mdtlov.quos_threshold_rr=25</screen></para>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>space</primary>
          <secondary>location weighting</secondary>
        </indexterm>Adjusting the Weighting Between Free Space and Location</title>
      <para>The weighting priority used by the weighted allocator is set in the file
            <literal>/proc/fs/<replaceable>fsname</replaceable>/lov/<replaceable>fsname</replaceable>-mdtlov/qos_prio_free</literal>.
        Increasing the value of <literal>qos_prio_free</literal> puts more weighting on the amount
        of free space available on each OST and less on how stripes are distributed across OSTs. The
        default value is <literal>91</literal> (percent). When the free space priority is set to
          <literal>100</literal> (percent), weighting is based entirely on free space and location
        is no longer used by the striping algorithm. </para>
      <para>To change the allocator weighting to <literal>100</literal>, enter this command on the
        MGS:</para>
      <screen>lctl conf_param <replaceable>fsname</replaceable>-MDT0000.lov.qos_prio_free=100</screen>
      <para> .</para>
      <note>
        <para>When <literal>qos_prio_free</literal> is set to <literal>100</literal>, a weighted
          random algorithm is still used to assign stripes, so, for example, if OST2 has twice as
          much free space as OST1, OST2 is twice as likely to be used, but it is not guaranteed to
          be used.</para>
      </note>
    </section>
  </section>
  <section xml:id="section_syy_gcl_qk">
    <title><indexterm>
        <primary>striping</primary>
        <secondary>wide striping</secondary>
      </indexterm><indexterm>
        <primary>wide striping</primary>
      </indexterm>Lustre Striping Internals</title>
    <para>For Lustre releases prior to Lustre software release 2.2, files can be striped across a
      maximum of 160 OSTs. Lustre inodes use an extended attribute to record the location of each
      object (the object ID and the number of the OST on which it is stored). The size of the
      extended attribute limits the maximum stripe count to 160 objects.</para>
    <para condition="l22">In Lustre software release 2.2 and subsequent releases, the maximum number
      of OSTs over which files can be striped has been raised to 2000 by allocating a new block on
      which to store the extended attribute that holds the object information. This feature, known
      as "wide striping," only allocates the additional extended attribute data block if the file is
      striped with a stripe count greater than 160. The file layout (object ID, OST number) is
      stored on the new data block with a pointer to this block stored in the original Lustre inode
      for the file. For files smaller than 160 objects, the Lustre inode is used to store the file
      layout.</para>
  </section>
</chapter>
