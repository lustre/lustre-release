<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:lang="en-US" xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" xml:id='benchmarkingtests'>
  <info>
    <title xml:id='benchmarkingtests.title'>Benchmarking Lustre Performance (Lustre I/O Kit)</title>
  </info>

  <para>This chapter describes the Lustre I/O kit, a collection of I/O benchmarking tools for a Lustre cluster, and PIOS, a parallel I/O simulator for Linux and Solaris. It includes:</para>
  <itemizedlist><listitem>
          <para><xref linkend="dbdoclet.50438212_44437"/></para>
    </listitem>

<listitem>
    <para><xref linkend="dbdoclet.50438212_51053"/></para>
    </listitem>

<listitem>
    <para><xref linkend="dbdoclet.50438212_26516"/></para>
    </listitem>

<listitem>
    <para><xref linkend="dbdoclet.50438212_85136"/></para>
    </listitem>

<listitem>
    <para><xref linkend="dbdoclet.50438212_58201"/></para>
    </listitem>

</itemizedlist>

    <section xml:id="dbdoclet.50438212_44437">
      <title>24.1 Using Lustre I/O Kit Tools</title>
      <para>The tools in the Lustre I/O Kit are used to benchmark Lustre hardware and validate that it is working as expected before you install the Lustre software. It can also be used to to validate the performance of the various hardware and software layers in the cluster and also to find and troubleshoot I/O issues.</para>
      <para>Typically, performance is measured starting with single raw devices and then proceeding to groups of devices. Once raw performance has been established, other software layers are then added incrementally and tested.</para>
      <section remap="h3">
        <title>24.1.1 Contents of the Lustre I/O Kit</title>
        <para>The I/O kit contains three tests, each of which tests a progressively higher layer in the Lustre stack:</para>
        <itemizedlist><listitem>
            <para>sgpdd_survey  - Measure basic 'bare metal' performance of devices while bypassing the kernel block device layers, buffer cache, and file system.</para>
          </listitem>

<listitem>
            <para>obdfilter_survey  - Measure the performance of one or more OSTs directly on the OSS node or alternately over the network from a Lustre client.</para>
          </listitem>

<listitem>
            <para>ost_survey  - Performs I/O against OSTs individually to allow performance comparisons to detect if an OST is performing suboptimally due to hardware issues.</para>
          </listitem>

</itemizedlist>
        <para>Typically with these tests, Lustre should deliver 85-90% of the raw device performance.</para>
        <para>A utility stats-collect is also provided to collect application profiling information from Lustre clients and servers. See <link xl:href="BenchmarkingTests.html#50438212_58201">Collecting Application Profiling Information (stats-collect)</link> for more information.</para>
      </section>
      <section remap="h3">
        <title>24.1.2 Preparing to Use the Lustre <anchor xml:id="dbdoclet.50438212_marker-1289913" xreflabel=""/>I/O Kit</title>
        <para>The following prerequisites must be met to use the tests in the Lustre I/O kit:</para>
        <itemizedlist><listitem>
            <para> Password-free remote access to nodes in the system (provided by ssh or rsh).</para>
          </listitem>

<listitem>
    <para> LNET self-test completed to test that Lustre Networking has been properly installed and configured. See <xref linkend='lnetselftest'/>.</para>
          </listitem>

<listitem>
            <para> Lustre file system software installed.</para>
          </listitem>

<listitem>
            <para>sg3_utils  package providing the sgp_dd tool (sg3_utils is a separate RPM package available online using YUM).</para>
          </listitem>

</itemizedlist>
        <para>Download the Lustre I/O kit (lustre-iokit)from:</para>
        <para><link xl:href="http://downloads.lustre.org/public/tools/lustre-iokit/">http://downloads.lustre.org/public/tools/lustre-iokit/</link></para>
      </section>
    </section>
    <section xml:id="dbdoclet.50438212_51053">
      <title>24.2 Testing I/O Performance of Raw Hardware (sgpdd_survey<anchor xml:id="dbdoclet.50438212_marker-1302844" xreflabel=""/>)</title>
      <para>The sgpdd_survey tool is used to test bare metal I/O performance of the raw hardware, while bypassing as much of the kernel as possible. This survey may be used to characterize the performance of a SCSI device by simulating an OST serving multiple stripe files. The data gathered by this survey can help set expectations for the performance of a Lustre OST using this device.</para>
      <para>The script uses sgp_dd to carry out raw sequential disk I/O. It runs with variable numbers of sgp_dd threads to show how performance varies with different request queue depths.</para>
      <para>The script spawns variable numbers of sgp_dd instances, each reading or writing a separate area of the disk to demonstrate performance variance within a number of concurrent stripe files.</para>
      <para>Several tips and insights for disk performance measurement are described below. Some of this information is specific to RAID arrays and/or the Linux RAID implementation.</para>
      <itemizedlist><listitem>
          <para><emphasis>Performance is limited by the slowest disk.</emphasis></para>
        </listitem>

</itemizedlist>
      <para>Before creating a RAID array, benchmark all disks individually. We have frequently encountered situations where drive performance was not consistent for all devices in the array. Replace any disks that are significantly slower than the rest.</para>
      <itemizedlist><listitem>
          <para><emphasis>Disks and arrays are very sensitive to request size.</emphasis></para>
        </listitem>

</itemizedlist>
      <para>To identify the optimal request size for a given disk, benchmark the disk with different record sizes ranging from 4 KB to 1 to 2 MB.</para>

              <caution><para>The sgpdd_survey script overwrites the device being tested, which results in the <emphasis>LOSS OF ALL DATA</emphasis> on that device. Exercise caution when selecting the device to be tested.</para></caution>

              <note><para>Array performance with all LUNs loaded does not always match the performance of a single LUN when tested in isolation.</para></note>

      <para></para>
      <para><emphasis role="bold">Prequisites:</emphasis></para>
      <itemizedlist><listitem>
          <para>sgp_dd  tool in the sg3_utils package</para>
        </listitem>

<listitem>
          <para> Lustre software is <emphasis>NOT</emphasis> required</para>
        </listitem>

</itemizedlist>
      <para>The device(s) being tested must meet one of these two requirements:</para>
      <itemizedlist><listitem>
          <para> If the device is a SCSI device, it must appear in the output of sg_map (make sure the kernel module sg is loaded).</para>
        </listitem>

<listitem>
          <para> If the device is a raw device, it must appear in the output of raw -qa.</para>
        </listitem>

</itemizedlist>
      <para>Raw and SCSI devices cannot be mixed in the test specification.</para>

              <note><para>If you need to create raw devices to use the sgpdd_survey tool, note that raw device 0 cannot be used due to a bug in certain versions of the &quot;raw&quot; utility (including that shipped with RHEL4U4.)</para></note>

      <section remap="h3">
        <title>24.2.1 Tuning Linux Storage Devices</title>
        <para>To get large I/O transfers (1 MB) to disk, it may be necessary to tune several kernel parameters as specified:</para>
        <screen>/sys/block/sdN/queue/max_sectors_kb = 4096
/sys/block/sdN/queue/max_phys_segments = 256
/proc/scsi/sg/allow_dio = 1
/sys/module/ib_srp/parameters/srp_sg_tablesize = 255
/sys/block/sdN/queue/scheduler</screen>
      </section>
      <section remap="h3">
        <title>24.2.2 Running sgpdd_survey</title>
        <para>The sgpdd_survey script must be customized for the particular device being tested and for the location where the script saves its working and result files (by specifying the ${rslt} variable). Customization variables are described at the beginning of the script.</para>
        <para>When the sgpdd_survey script runs, it creates a number of working files and a pair of result files. The names of all the files created start with the prefixdefined in the variable ${rslt}. (The default value is /tmp.) The files include:</para>
        <itemizedlist><listitem>
            <para> File containing standard output data (same as stdout)</para>
          </listitem>

</itemizedlist>
        <screen>${rslt}_<emphasis>&lt;date/time&gt;</emphasis>.summary<emphasis/></screen>
        <itemizedlist><listitem>
            <para> Temporary (tmp) files</para>
          </listitem>

</itemizedlist>
        <screen>${rslt}_<emphasis>&lt;date/time&gt;</emphasis>_*
</screen>
        <itemizedlist><listitem>
            <para> Collected tmp files for post-mortem</para>
          </listitem>

</itemizedlist>
        <screen>${rslt}_<emphasis>&lt;date/time&gt;</emphasis>.detail
</screen>
        <para>The stdout and the .summary file will contain lines like this:</para>
        <screen>total_size 8388608K rsz 1024 thr 1 crg 1 180.45 MB/s 1 x 180.50 \=/ 180.50 \
MB/s
</screen>
        <para>Each line corresponds to a run of the test. Each test run will have a different number of threads, record size, or number of regions.</para>
        <itemizedlist><listitem>
            <para>total_size  - Size of file being tested in KBs (8 GB in above example).</para>
          </listitem>

<listitem>
            <para>rsz  - Record size in KBs (1 MB in above example).</para>
          </listitem>

<listitem>
            <para>thr  - Number of threads generating I/O (1 thread in above example).</para>
          </listitem>

<listitem>
            <para> crg - Current regions, the number of disjount areas on the disk to which I/O is being sent (1 region in above example, indicating that no seeking is done).</para>
          </listitem>

<listitem>
            <para>MB/s  - Aggregate bandwidth measured by dividing the total amount of data by the elapsed time (180.45 MB/s in the above example).</para>
          </listitem>

<listitem>
            <para>MB/s  - The remaining numbers show the number of regions X performance of the slowest disk as a sanity check on the aggregate bandwidth.</para>
          </listitem>

</itemizedlist>
        <para>If there are so many threads that the sgp_dd script is unlikely to be able to allocate I/O buffers, then ENOMEM is printed in place of the aggregate bandwidth result.</para>
        <para>If one or more sgp_dd instances do not successfully report a bandwidth number, then FAILED is printed in place of the aggregate bandwidth result.</para>
      </section>
    </section>
    <section xml:id="dbdoclet.50438212_26516">
      <title>24.3 <anchor xml:id="dbdoclet.50438212_40624" xreflabel=""/>Testing OST Performance (obdfilter_survey<anchor xml:id="dbdoclet.50438212_marker-1289957" xreflabel=""/>)</title>
      <para>The obdfilter_survey script generates sequential I/O from varying numbers of threads and objects (files) to simulate the I/O patterns of a Lustre client.</para>
      <para>The obdfilter_survey script can be run directly on the OSS node to measure the OST storage performance without any intervening network, or it can be run remotely on a Lustre client to measure the OST performance including network overhead.</para>
      <para>The obdfilter_survey is used to characterize the performance of the following:</para>
      <itemizedlist><listitem>
          <para><emphasis role="bold">Local file system</emphasis>  - In this mode, the obdfilter_survey script exercises one or more instances of the obdfilter directly. The script may run on one or more OSS nodes, for example, when the OSSs are all attached to the same multi-ported disk subsystem.</para>
        </listitem>

</itemizedlist>
      <para>Run the script using the case=disk parameter to run the test against all the local OSTs. The script automatically detects all local OSTs and includes them in the survey.</para>
      <para>To run the test against only specific OSTs, run the script using the target= parameter to list the OSTs to be tested explicitly. If some OSTs are on remote nodes, specify their hostnames in addition to the OST name (for example, oss2:lustre-OST0004).</para>
      <para>All obdfilter instances are driven directly. The script automatically loads the obdecho module (if required) and creates one instance of echo_client for each obdfilter instance in order to generate I/O requests directly to the OST.</para>
      <para>For more details, see <link xl:href="BenchmarkingTests.html#50438212_59319">Testing Local Disk Performance</link>.</para>
      <itemizedlist><listitem>
          <para><emphasis role="bold">Network</emphasis>  - In this mode, the Lustre client generates I/O requests over the network but these requests are not sent to the OST file system. The OSS node runs the obdecho server to receive the requests but discards them before they are sent to the disk.</para>
        </listitem>

</itemizedlist>
      <para>Pass the parameters case=network and target=<emphasis>&lt;hostname</emphasis>|<emphasis>IP_of_server&gt;</emphasis> to the script. For each network case, the script does the required setup.</para>
      <para>For more details, see <link xl:href="BenchmarkingTests.html#50438212_36037">Testing Network Performance</link></para>
      <itemizedlist><listitem>
          <para><emphasis role="bold">Remote file system over the network</emphasis>  - In this mode the obdfilter_survey script generates I/O from a Lustre client to a remote OSS to write the data to the file system.</para>
        </listitem>

</itemizedlist>
      <para>To run the test against all the local OSCs, pass the parameter case=netdisk to the script. Alternately you can pass the target= parameter with one or more OSC devices (e.g., lustre-OST0000-osc-ffff88007754bc00) against which the tests are to be run.</para>
      <para>For more details, see <link xl:href="BenchmarkingTests.html#50438212_62662">Testing Remote Disk Performance</link>.</para>
              <caution><para>The obdfilter_survey script is destructive and should not be run on devices that containing existing data that needs to be preserved. Thus, tests using obdfilter_survey should be run before the Lustre file system is placed in production.</para></caution>

              <note><para>If the obdfilter_survey test is terminated before it completes, some small amount of space is leaked. you can either ignore it or reformat the file system.</para></note>
              <note><para>The obdfilter_survey script is <emphasis>NOT</emphasis> scalable beyond tens of OSTs since it is only intended to measure the I/O performance of individual storage subsystems, not the scalability of the entire system.</para></note>

              <note><para>The obdfilter_survey script must be customized, depending on the components under test and where the script's working files should be kept. Customization variables are described at the beginning of the obdfilter_survey script. In particular, pay attention to the listed maximum values listed for each parameter in the script.</para></note>

      <section remap="h3">
        <title>24.3.1 <anchor xml:id="dbdoclet.50438212_59319" xreflabel=""/>Testing Local Disk Performance</title>
        <para>The obdfilter_survey script can be run automatically or manually against a local disk. This script profiles the overall throughput of storage hardware, including the file system and RAID layers managing the storage, by sending workloads to the OSTs that vary in thread count, object count, and I/O size.</para>
        <para>When the obdfilter_survey script is run, it provides information about the performance abilities of the storage hardware and shows the saturation points.</para>
        <para>The plot-obdfilter script generates from the output of the obdfilter_survey a CSV file and parameters for importing into a spreadsheet or gnuplot to visualize the data.</para>
        <para>To run the obdfilter_survey script, create a standard Lustre configuration; no special setup is needed.</para>
        <para><emphasis role="bold">To perform an automatic run:</emphasis></para>
        <orderedlist><listitem>
        <para> 1. Start the Lustre OSTs.</para>
        <para>The Lustre OSTs should be mounted on the OSS node(s) to be tested. The Lustre client is not required to be mounted at this time.</para>
    </listitem><listitem>
        <para> 2. Verify that the obdecho module is loaded. Run:</para>
        <screen>modprobe obdecho</screen>
    </listitem><listitem>
        <para> 3. Run the obdfilter_survey script with the parameter case=disk.</para>
        <para>For example, to run a local test with up to two objects (nobjhi), up to two threads (thrhi), and 1024 MB transfer size (size):</para>
        <screen>$ nobjhi=2 thrhi=2 size=1024 case=disk sh obdfilter-survey
 
</screen>
    </listitem></orderedlist>
        <para><emphasis role="bold">To perform a manual run:</emphasis></para>
        <orderedlist><listitem>
        <para> 1. Start the Lustre OSTs.</para>
        <para>The Lustre OSTs should be mounted on the OSS node(s) to be tested. The Lustre client is not required to be mounted at this time.</para>
    </listitem><listitem>
        <para> 2. Verify that the obdecho module is loaded. Run:</para>
        <para>modprobe obdecho</para>
    </listitem><listitem>
        <para> 3. Determine the OST names.</para>
        <para>On the OSS nodes to be tested, run the lctldl command. The OST device names are listed in the fourth column of the output. For example:</para>
        <screen>$ lctl dl |grep obdfilter
0 UP obdfilter lustre-OST0001 lustre-OST0001_UUID 1159
2 UP obdfilter lustre-OST0002 lustre-OST0002_UUID 1159
...
</screen>
    </listitem><listitem>
        <para> 4. List all OSTs you want to test.</para>
        <para>Use the target= parameter to list the OSTs separated by spaces. List the individual OSTs by name using the format <emphasis>&lt;fsname&gt;-&lt;OSTnumber&gt;</emphasis> (for example, lustre-OST0001). You do not have to specify an MDS or LOV.</para>
    </listitem><listitem>
        <para> 5. Run the obdfilter_survey script with the target= parameter.</para>
        <para>For example, to run a local test with up to two objects (nobjhi), up to two threads (thrhi), and 1024 Mb (size) transfer size:</para>
        <screen>$ nobjhi=2 thrhi=2 size=1024 targets='lustre-OST0001 \
lustre-OST0002' sh obdfilter-survey
</screen>
    </listitem></orderedlist>
      </section>
      <section remap="h3">
        <title>24.3.2 <anchor xml:id="dbdoclet.50438212_36037" xreflabel=""/>Testing Network Performance</title>
        <para>The obdfilter_survey script can only be run automatically against a network; no manual test is provided.</para>
        <para>To run the network test, a specific Lustre setup is needed. Make sure that these configuration requirements have been met.</para>
        <para><emphasis role="bold">To perform an automatic run:</emphasis></para>
    <orderedlist><listitem>
        <para> 1. Start the Lustre OSTs.</para>
        <para>The Lustre OSTs should be mounted on the OSS node(s) to be tested. The Lustre client is not required to be mounted at this time.</para>
    </listitem><listitem>
        <para> 2. Verify that the obdecho module is loaded. Run:</para>
        <screen>modprobe obdecho</screen>
    </listitem><listitem>
        <para> 3. Start lctl and check the device list, which must be empty. Run:</para>
        <screen>lctl dl
</screen>
    </listitem><listitem>
        <para> 4. Run the obdfilter_survey script with the parameters case=network and <emphasis role="bold">targets=</emphasis><emphasis>&lt;hostname</emphasis>|<emphasis>ip_of_server&gt;</emphasis>. For example:</para>
        <screen>$ nobjhi=2 thrhi=2 size=1024 targets='oss1 oss2' case=network sh obdfilte\
r-survey
</screen>
    </listitem><listitem>
        <para> 5. On the server side, view the statistics at:</para>
        <screen>/proc/fs/lustre/obdecho/<emphasis>&lt;echo_srv&gt;</emphasis>/stats
</screen>
        <para>where <emphasis>&lt;echo_srv&gt;</emphasis> is the obdecho server created by the script.</para>
    </listitem></orderedlist>
      </section>
      <section remap="h3">
        <title>24.3.3 <anchor xml:id="dbdoclet.50438212_62662" xreflabel=""/>Testing Remote Disk Performance</title>
        <para>The obdfilter_survey script can be run automatically or manually against a network disk. To run the network disk test, start with a standard Lustre configuration. No special setup is needed.</para>
        <para><emphasis role="bold">To perform an automatic run:</emphasis></para>
    <orderedlist><listitem>
        <para> 1. Start the Lustre OSTs.</para>
        <para>The Lustre OSTs should be mounted on the OSS node(s) to be tested. The Lustre client is not required to be mounted at this time.</para>
    </listitem><listitem>
        <para> 2. Verify that the obdecho module is loaded. Run:</para>
        <screen>modprobe obdecho</screen>
    </listitem><listitem>
        <para> 3. Run the obdfilter_survey script with the parameter case=netdisk. For example:</para>
        <screen>$ nobjhi=2 thrhi=2 size=1024 case=netdisk sh obdfilter-survey
</screen>
    </listitem></orderedlist>
        <para><emphasis role="bold">To perform a manual run:</emphasis></para>
    <orderedlist><listitem>
        <para> 1. Start the Lustre OSTs.</para>
        <para>The Lustre OSTs should be mounted on the OSS node(s) to be tested. The Lustre client is not required to be mounted at this time.</para>
    </listitem><listitem>
        <para> 2. Verify that the obdecho module is loaded. Run:</para>
        <para>modprobe obdecho</para>
    </listitem><listitem>
        <para> 3. Determine the OSC names.</para>
        <para>On the OSS nodes to be tested, run the lctldl command. The OSC device names are listed in the fourth column of the output. For example:</para>
        <screen>$ lctl dl |grep obdfilter
3 UP osc lustre-OST0000-osc-ffff88007754bc00 54b91eab-0ea9-1516-b571-5e6df3\
49592e 5
4 UP osc lustre-OST0001-osc-ffff88007754bc00 54b91eab-0ea9-1516-b571-5e6df3\
49592e 5
...
</screen>
    </listitem><listitem>
        <para> 4. List all OSCs you want to test.</para>
        <para>Use the target= parameter to list the OSCs separated by spaces. List the individual OSCs by name seperated by spaces using the format <emphasis>&lt;fsname&gt;-&lt;OST_name&gt;</emphasis>-osc-<emphasis>&lt;OSC_number&gt;</emphasis> (for example, lustre-OST0000-osc-ffff88007754bc00). You <emphasis role="bold">do not have to specify an MDS or LOV.</emphasis></para>
    </listitem><listitem>
        <para> 5. Run the <emphasis role="bold">o</emphasis>bdfilter_survey script with the target= parameter and case=netdisk.</para>
        <para>An example of a local test run with up to two objects (nobjhi), up to two threads (thrhi), and 1024 Mb (size) transfer size is shown below:</para>
        <screen>$ nobjhi=2 thrhi=2 size=1024 \
targets=&quot;lustre-OST0000-osc-ffff88007754bc00 \
lustre-OST0001-osc-ffff88007754bc00&quot; \ 
sh obdfilter-survey
</screen>
    </listitem></orderedlist>
      </section>
      <section remap="h3">
        <title>24.3.4 Output Files</title>
        <para>When the obdfilter_survey script runs, it creates a number of working files and a pair of result files. All files start with the prefix defined in the variable ${rslt}.</para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50*"/>
            <colspec colname="c2" colwidth="50*"/>
            <thead>
              <row>
                <entry><para><emphasis role="bold">File</emphasis></para></entry>
                <entry><para><emphasis role="bold">Description</emphasis></para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><para> ${rslt}.summary</para></entry>
                <entry><para> Same as stdout</para></entry>
              </row>
              <row>
                <entry><para> ${rslt}.script_*</para></entry>
                <entry><para> Per-host test script files</para></entry>
              </row>
              <row>
                <entry><para> ${rslt}.detail_tmp*</para></entry>
                <entry><para> Per-OST result files</para></entry>
              </row>
              <row>
                <entry><para> ${rslt}.detail</para></entry>
                <entry><para> Collected result files for post-mortem</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>The obdfilter_survey script iterates over the given number of threads and objects performing the specified tests and checks that all test processes have completed successfully.</para>

                <note><para>The obdfilter_survey script may not clean up properly if it is aborted or if it encounters an unrecoverable error. In this case, a manual cleanup may be required, possibly including killing any running instances of lctl (local or remote), removing echo_client instances created by the script and unloading obdecho.</para></note>

        <section remap="h4">
          <title>24.3.4.1 Script Output</title>
          <para>The .summary file and stdout of the obdfilter_survey script contain lines like:</para>
          <screen>ost 8 sz 67108864K rsz 1024 obj 8 thr 8 write 613.54 [ 64.00, 82.00]
</screen>
          <para>Where:</para>
          <informaltable frame="all">
            <tgroup cols="2">
              <colspec colname="c1" colwidth="50*"/>
              <colspec colname="c2" colwidth="50*"/>
              <thead>
                <row>
                  <entry><para><emphasis role="bold">Parameter and value</emphasis></para></entry>
                  <entry><para><emphasis role="bold">Description</emphasis></para></entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><para> ost 8</para></entry>
                  <entry><para> Total number of OSTs being tested.</para></entry>
                </row>
                <row>
                  <entry><para> sz 67108864K</para></entry>
                  <entry><para> Total amount of data read or written (in KB).</para></entry>
                </row>
                <row>
                  <entry><para> rsz 1024</para></entry>
                  <entry><para> Record size (size of each echo_client I/O, in KB).</para></entry>
                </row>
                <row>
                  <entry><para> obj 8</para></entry>
                  <entry><para> Total number of objects over all OSTs.</para></entry>
                </row>
                <row>
                  <entry><para> thr 8</para></entry>
                  <entry><para> Total number of threads over all OSTs and objects.</para></entry>
                </row>
                <row>
                  <entry><para> write</para></entry>
                  <entry><para> Test name. If more tests have been specified, they all appear on the same line.</para></entry>
                </row>
                <row>
                  <entry><para> 613.54</para></entry>
                  <entry><para> Aggregate bandwidth over all OSTs (measured by dividing the total number of MB by the elapsed time).</para></entry>
                </row>
                <row>
                  <entry><para> [64, 82.00]</para></entry>
                  <entry><para> Minimum and maximum instantaneous bandwidths on an individual OST.</para></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <note><para>Although the numbers of threads and objects are specified per-OST in the customization section of the script, the reported results are aggregated over all OSTs.</para></note>
        </section>
        <section remap="h4">
          <title>24.3.4.2 Visualizing Results</title>
          <para>It is useful to import the obdfilter_survey script summary data (it is fixed width) into Excel (or any graphing package) and graph the bandwidth versus the number of threads for varying numbers of concurrent regions. This shows how the OSS performs for a given number of concurrently-accessed objects (files) with varying numbers of I/Os in flight.</para>
          <para>It is also useful to monitor and record average disk I/O sizes during each test using the 'disk io size' histogram in the file /proc/fs/lustre/obdfilter/ (see <link xl:href="LustreProc.html#50438271_55057">Watching the OST Block I/O Stream</link> for details). These numbers help identify problems in the system when full-sized I/Os are not submitted to the underlying disk. This may be caused by problems in the device driver or Linux block layer.</para>
          <para> */brw_stats</para>
          <para>The plot-obdfilter script included in the I/O toolkit is an example of processing output files to a .csv format and plotting a graph using gnuplot.</para>
        </section>
      </section>
    </section>
    <section xml:id="dbdoclet.50438212_85136">
      <title>24.4 Testing OST I/O Performance (ost_<anchor xml:id="dbdoclet.50438212_marker-1290067" xreflabel=""/>survey)</title>
      <para>The ost_survey tool is a shell script that uses lfs setstripe to perform I/O against a single OST. The script writes a file (currently using dd) to each OST in the Lustre file system, and compares read and write speeds. The ost_survey tool is used to detect anomalies between otherwise identical disk subsystems.</para>
              <note><para>We have frequently discovered wide performance variations across all LUNs in a cluster. This may be caused by faulty disks, RAID parity reconstruction during the test, or faulty network hardware.</para></note>

      <para>To run the ost_survey script, supply a file size (in KB) and the Lustre mount point. For example, run:</para>
      <screen>$ ./ost-survey.sh 10 /mnt/lustre
</screen>
      <para>Typical output is:</para>
      <screen>Average read Speed:                  6.73
Average write Speed:                       5.41
read - Worst OST indx 0                    5.84 MB/s
write - Worst OST indx 0           3.77 MB/s
read - Best OST indx 1                     7.38 MB/s
write - Best OST indx 1                    6.31 MB/s
3 OST devices found
Ost index 0 Read speed                     5.84            Write speed     \
        3.77
Ost index 0 Read time                      0.17            Write time      \
        0.27
Ost index 1 Read speed                     7.38            Write speed     \
        6.31
Ost index 1 Read time                      0.14            Write time      \
        0.16
Ost index 2 Read speed                     6.98            Write speed     \
        6.16
Ost index 2 Read time                      0.14            Write time      \
        0.16 
</screen>
    </section>
    <section xml:id="dbdoclet.50438212_58201">
      <title>24.5 Collecting Application Profiling Information (stats-collect)</title>
      <para>The stats-collect utility contains the following scripts used to collect application profiling information from Lustre clients and servers:</para>
      <itemizedlist><listitem>
          <para>lstat.sh  - Script for a single node that is run on each profile node.</para>
        </listitem>

<listitem>
          <para>gather_stats_everywhere.sh  - Script that collect statistics.</para>
        </listitem>

<listitem>
          <para>config.sh  - Script that contains customized configuration descriptions.</para>
        </listitem>

</itemizedlist>
      <para>The stats-collect utility requires:</para>
      <itemizedlist><listitem>
          <para> Lustre to be installed and set up on your cluster</para>
        </listitem>

<listitem>
          <para> SSH and SCP access to these nodes without requiring a password</para>
        </listitem>

</itemizedlist>
      <section remap="h3">
        <title>24.5.1 Using stats-collect</title>
        <para>The stats-collect utility is configured by including profiling configuration variables in the config.sh script. Each configuration variable takes the following form, where 0 indicates statistics are to be collected only when the script starts and stops and <emphasis>n</emphasis> indicates the interval in seconds at which statistics are to be collected:</para>
        <screen><emphasis>&lt;statistic&gt;</emphasis>_INTERVAL=<emphasis>[</emphasis>0<emphasis>|n]</emphasis></screen>
        <para>Statistics that can be collected include:</para>
        <itemizedlist><listitem>
            <para>VMSTAT  - Memory and CPU usage and aggregate read/write operations</para>
          </listitem>

<listitem>
            <para>SERVICE  - Lustre OST and MDT RPC service statistics</para>
          </listitem>

<listitem>
            <para>BRW  - OST block read/write statistics (brw_stats)</para>
          </listitem>

<listitem>
            <para>SDIO  - SCSI disk IO statistics (sd_iostats)</para>
          </listitem>

<listitem>
            <para>MBALLOC  - ldiskfs block allocation statistics</para>
          </listitem>

<listitem>
            <para>IO  - Lustre target operations statistics</para>
          </listitem>

<listitem>
            <para>JBD  - ldisfs journal statistics</para>
          </listitem>

<listitem>
            <para>CLIENT  - Lustre OSC request statistics</para>
          </listitem>

</itemizedlist>
        <para>To collect profile information:</para>
        <para> 1. Begin collecting statistics on each node specified in the config.sh script.</para>
        <para>Starting the collect profile daemon on each node by entering:</para>
        <screen>sh gather_stats_everywhere.sh config.sh start 
</screen>
        <para> 2. Run the test.</para>
        <para> 3. Stop collecting statistics on each node, clean up the temporary file, and create a profiling tarball.</para>
        <para>Enter:</para>
        <screen>sh gather_stats_everywhere.sh config.sh stop <emphasis>&lt;log_name.tgz&gt;</emphasis></screen>
        <para>When <emphasis>&lt;log_name.tgz&gt;</emphasis> is specified, a profile tarball /tmp/<emphasis>&lt;log_name.tgz&gt;</emphasis> is created.</para>
        <para> 4. Analyze the collected statistics and create a csv tarball for the specified profiling data.</para>
        <screen>sh gather_stats_everywhere.sh config.sh analyse log_tarball.tgz csv
</screen>
        <para>Â </para>
      </section>
  </section>
</chapter>
