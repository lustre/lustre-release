 fs/ext3/inode.c |   52 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 fs/ext3/super.c |    3 +++
 2 files changed, 55 insertions(+)

Index: linux-2.6.0/fs/ext3/inode.c
===================================================================
--- linux-2.6.0.orig/fs/ext3/inode.c	2003-12-31 00:33:49.000000000 +0300
+++ linux-2.6.0/fs/ext3/inode.c	2003-12-31 01:14:17.000000000 +0300
@@ -3136,3 +3136,62 @@
 		ret = ret2;
 	return ret;
 }
+
+int ext3_map_inode_page(struct inode *inode, struct page *page,
+                        unsigned long *blocks, int *created, int create)
+{
+        unsigned int blocksize, blocks_per_page;
+        unsigned long iblock;
+        struct buffer_head dummy;
+        void *handle;
+        int i, rc = 0, failed = 0, needed_blocks;
+
+        blocksize = inode->i_sb->s_blocksize;
+        blocks_per_page = PAGE_SIZE >> inode->i_sb->s_blocksize_bits;
+        iblock = page->index * blocks_per_page;
+
+        for (i = 0; i < blocks_per_page; i++, iblock++) {
+                blocks[i] = ext3_bmap(inode->i_mapping, iblock);
+                if (blocks[i] == 0) {
+                        failed++;
+			if (created)
+				created[i] = -1;
+		} else if (created) {
+                        created[i] = 0;
+                }
+        }
+
+        if (failed == 0 || create == 0)
+                return 0;
+
+        needed_blocks = ext3_writepage_trans_blocks(inode);
+        handle = ext3_journal_start(inode, needed_blocks);
+        if (IS_ERR(handle))
+                return PTR_ERR(handle);
+
+        iblock = page->index * blocks_per_page;
+        for (i = 0; i < blocks_per_page; i++, iblock++) {
+                if (blocks[i] != 0)
+                        continue;
+
+                rc = ext3_get_block_handle(handle, inode, iblock, &dummy, 1, 1);
+                if (rc) {
+                        printk(KERN_INFO "ext3_map_inode_page: error reading "
+                               "block %ld\n", iblock);
+                        goto out;
+                }
+		/* Unmap any metadata buffers from the block mapping, to avoid
+		 * data corruption due to direct-write from Lustre being
+		 * clobbered by a later flush of the blockdev metadata buffer.*/
+                if (buffer_new(&dummy))
+                        unmap_underlying_metadata(dummy.b_bdev,
+                                                      dummy.b_blocknr);
+                blocks[i] = dummy.b_blocknr;
+		if (created)
+			created[i] = 1;
+        }
+
+ out:
+	ext3_journal_stop(handle);
+        return rc;
+}
Index: linux-2.6.0/fs/ext3/super.c
===================================================================
--- linux-2.6.0.orig/fs/ext3/super.c	2003-12-31 00:33:49.000000000 +0300
+++ linux-2.6.0/fs/ext3/super.c	2003-12-31 01:10:40.000000000 +0300
@@ -2051,6 +2051,9 @@
 int ext3_prep_san_write(struct inode *inode, long *blocks,
                         int nblocks, loff_t newsize);
 EXPORT_SYMBOL(ext3_prep_san_write);
+int ext3_map_inode_page(struct inode *inode, struct page *page,
+                        unsigned long *blocks, int *created, int create);
+EXPORT_SYMBOL(ext3_map_inode_page);
 
 MODULE_AUTHOR("Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others");
 MODULE_DESCRIPTION("Second Extended Filesystem with journaling extensions");
