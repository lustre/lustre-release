Index: linux-stage/fs/ext4/mballoc.c
===================================================================
--- linux-stage.orig/fs/ext4/mballoc.c	2010-01-26 22:50:37.000000000 +0800
+++ linux-stage/fs/ext4/mballoc.c	2010-01-26 22:57:24.000000000 +0800
@@ -3892,6 +3892,7 @@
 	INIT_LIST_HEAD(&pa->pa_group_list);
 	pa->pa_deleted = 0;
	pa->pa_type = MB_INODE_PA;
+	pa->pa_error = 0;
 
 	mb_debug("new inode pa %p: %llu/%u for %u\n", pa,
 			pa->pa_pstart, pa->pa_len, pa->pa_lstart);
@@ -3956,6 +3957,7 @@
 	INIT_LIST_HEAD(&pa->pa_group_list);
 	pa->pa_deleted = 0;
	pa->pa_type = MB_GROUP_PA;
+	pa->pa_error = 0;
 
 	mb_debug("new group pa %p: %llu/%u for %u\n", pa,
 		 pa->pa_pstart, pa->pa_len, pa->pa_lstart);
@@ -4019,7 +4021,9 @@
 	int err = 0;
 	int free = 0;
 
+	assert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));
 	BUG_ON(pa->pa_deleted == 0);
+	BUG_ON(pa->pa_inode == NULL);
 	ext4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);
 	grp_blk_start = pa->pa_pstart - bit;
 	BUG_ON(group != e4b->bd_group && pa->pa_len != 0);
@@ -4059,11 +4064,18 @@
 		mb_free_blocks(pa->pa_inode, e4b, bit, next - bit);
 		bit = next + 1;
 	}
-	if (free != pa->pa_free) {
-		printk(KERN_CRIT "pa %p: logic %lu, phys. %lu, len %lu\n",
-			pa, (unsigned long) pa->pa_lstart,
-			(unsigned long) pa->pa_pstart,
-			(unsigned long) pa->pa_len);
+
+        /* "free < pa->pa_free" means we maybe double alloc the same blocks,
+         * otherwise maybe leave some free blocks unavailable, no need to BUG.*/
+        if ((free > pa->pa_free && !pa->pa_error) || (free < pa->pa_free)) {
+                ext4_error(sb,"pa free mismatch: [pa %p] "
+                              "[phy %lu] [logic %lu] [len %u] [free %u] "
+                              "[error %u] [inode %lu] [freed %u]", pa,
+                              (unsigned long)pa->pa_pstart,
+                              (unsigned long)pa->pa_lstart,
+                              (unsigned)pa->pa_len, (unsigned)pa->pa_free,
+                              (unsigned)pa->pa_error, pa->pa_inode->i_ino,
+                              free);
 		ext4_grp_locked_error(sb, group,
 					__func__, "free %u, pa_free %u",
 					free, pa->pa_free);
@@ -4072,6 +4084,7 @@
 		 * from the bitmap and continue.
 		 */
 	}
+        BUG_ON(pa->pa_free != free);
 	atomic_add(free, &sbi->s_mb_discarded);
 
 	return err;
@@ -4800,6 +4813,24 @@
		}
	}
 
+
+        if (dev_check_rdonly(sb->s_bdev)) {
+                struct block_device *bdev = sb->s_bdev;
+
+                printk(KERN_WARNING "Alloc from readonly device %s (%#x): "
+                       "[inode %lu] [logic %llu] [goal %llu] [ll %llu] "
+		       "[pl %llu] [lr %llu] [pr %llu] [len %u] [flags %u]\n",
+                       bdev->bd_disk ? bdev->bd_disk->disk_name : "",
+                       bdev->bd_dev, ar->inode->i_ino,
+		       (unsigned long long)ar->logical, 
+		       (unsigned long long)ar->goal,
+                       (unsigned long long)ar->lleft,
+		       (unsigned long long)ar->pleft,
+		       (unsigned long long)ar->lright,
+		       (unsigned long long)ar->pright,
+		       ar->len, ar->flags);
+        }
+
	ac = kmem_cache_alloc(ext4_ac_cachep, GFP_NOFS);
	if (!ac) {
		ar->len = 0;
@@ -4850,6 +4881,25 @@
 			ac->ac_b_ex.fe_len = 0;
 			ar->len = 0;
 			ext4_mb_show_ac(ac);
+                        if (ac->ac_pa) {
+                        	struct ext4_prealloc_space *pa = ac->ac_pa;
+
+                              	/* We can not make sure whether the bitmap has
+                               	 * been updated or not when fail case. So can
+                                 * not revert pa_free back, just mark pa_error*/
+                                pa->pa_error++;
+                                ext4_error(sb,
+                                            "Updating bitmap error: [err %d] "
+                                            "[pa %p] [phy %lu] [logic %lu] "
+                                            "[len %u] [free %u] [error %u] "
+                                            "[inode %lu]", *errp, pa,
+                                            (unsigned long)pa->pa_pstart,
+                                            (unsigned long)pa->pa_lstart,
+                                            (unsigned)pa->pa_len,
+                                            (unsigned)pa->pa_free,
+                                            (unsigned)pa->pa_error,
+                			pa->pa_inode ? pa->pa_inode->i_ino : 0);
+                        }
 		} else {
 			block = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);
 			ar->len = ac->ac_b_ex.fe_len;
@@ -5025,6 +5075,15 @@
 		goto error_return;
 	}
 
+        if (dev_check_rdonly(sb->s_bdev)) {
+                struct block_device *bdev = sb->s_bdev;
+
+                printk(KERN_WARNING "Release to readonly device %s (%#x): "
+                       "[inode %lu] [block %lu] [count %lu] [is_meta %d]\n",
+                       bdev->bd_disk ? bdev->bd_disk->disk_name : "",
+                       bdev->bd_dev, inode->i_ino, (unsigned long)block, count, metadata);
+        }
+
 	ext4_debug("freeing block %llu\n", block);
 	trace_mark(ext4_free_blocks,
 		   "dev %s block %llu count %lu metadata %d ino %lu",
Index: linux-stage/fs/ext4/mballoc.h
===================================================================
--- linux-stage.orig/fs/ext4/mballoc.h	2010-01-26 22:50:36.000000000 +0800
+++ linux-stage/fs/ext4/mballoc.h	2010-01-26 22:52:58.000000000 +0800
@@ -21,6 +21,7 @@
 #include <linux/blkdev.h>
 #include <linux/marker.h>
 #include <linux/mutex.h>
+#include <linux/genhd.h>
 #include "ext4_jbd2.h"
 #include "ext4.h"
 #include "group.h"
@@ -134,6 +135,7 @@
	ext4_grpblk_t		pa_len;		/* len of preallocated chunk */
	ext4_grpblk_t		pa_free;	/* how many blocks are free */
	unsigned short		pa_type;	/* pa type. inode or group */
+	unsigned short          pa_error;
 	spinlock_t		*pa_obj_lock;
 	struct inode		*pa_inode;	/* hack, for history only */
 };
