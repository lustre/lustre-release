Index: libgm/gm_register.c
===================================================================
RCS file: /repository/gm/libgm/gm_register.c,v
retrieving revision 1.9.16.3
diff -u -r1.9.16.3 gm_register.c
--- libgm/gm_register.c	9 Aug 2005 14:37:02 -0000	1.9.16.3
+++ libgm/gm_register.c	25 Aug 2005 21:35:58 -0000
@@ -77,20 +77,14 @@
  
 */
 
-GM_ENTRY_POINT
-gm_status_t
-gm_register_memory_ex (gm_port_t *p, void *_ptr, gm_size_t length, void *_pvma)
+static gm_status_t
+_gm_register_memory (gm_port_t *p, int is_physical, gm_u64_t ptr, gm_size_t length, gm_up_t pvma)
 {
   gm_status_t status;
-  gm_up_t ptr;
-  gm_up_t pvma;
 
   GM_CALLED_WITH_ARGS (("%p,%p,"GM_U64_TMPL",%p",
 			p, _ptr, GM_U64_ARG (length), _pvma));
     
-  ptr = GM_PTR_TO_UP (_ptr);
-  pvma = GM_PTR_TO_UP (_pvma);
-  
 #if !GM_KERNEL && !GM_CAN_REGISTER_MEMORY
   GM_PARAMETER_MAY_BE_UNUSED (p);
   GM_PARAMETER_MAY_BE_UNUSED (ptr);
@@ -160,7 +154,7 @@
 	status = gm_add_mapping_to_page_table (ps,
 					       ptr + offset,
 					       pvma + offset,
-					       GM_INVALID_DMA_PAGE);
+					       is_physical ? ptr + offset : GM_INVALID_DMA_PAGE);
 	if (status != GM_SUCCESS)
 	  {
 	    status = GM_INVALID_PARAMETER;
@@ -317,13 +311,31 @@
  
 */
 
+#if GM_KERNEL && (GM_CPU_x86 || GM_CPU_x86_64 || GM_CPU_ia64)
+/* only architecture where pci bus addr == physical address can use
+   such a simple scheme */
+GM_ENTRY_POINT gm_status_t
+gm_register_memory_ex_phys (struct gm_port *p,
+			    gm_u64_t phys, gm_size_t length,
+			    gm_up_t pvma)
+{
+  return _gm_register_memory(p, 1, phys, length, (gm_size_t)pvma);
+}
+#endif
+
+GM_ENTRY_POINT gm_status_t
+gm_register_memory_ex (gm_port_t *p, void *ptr, gm_size_t length, void *pvma)
+{
+  return _gm_register_memory(p, 0, (gm_size_t)ptr, length, (gm_size_t)pvma);
+}
+
 GM_ENTRY_POINT gm_status_t
 gm_register_memory (gm_port_t *p, void *ptr, gm_size_t length)
 {
   gm_status_t status;
   
   GM_CALLED_WITH_ARGS (("%p,%p,"GM_U64_TMPL, p, ptr, GM_U64_ARG (length)));
-  status = gm_register_memory_ex (p, ptr, length, ptr);
+  status = _gm_register_memory(p, 0, (gm_size_t)ptr, length, (gm_size_t)ptr);
   GM_RETURN_STATUS (status);
 }
 
Index: include/gm.h
===================================================================
RCS file: /repository/gm/include/gm.h,v
retrieving revision 1.25.10.11
diff -u -r1.25.10.11 gm.h
--- include/gm.h	14 Mar 2005 21:42:41 -0000	1.25.10.11
+++ include/gm.h	25 Aug 2005 21:35:58 -0000
@@ -2676,6 +2676,10 @@
 GM_ENTRY_POINT gm_status_t gm_register_memory_ex (struct gm_port *p,
 						  void *ptr, gm_size_t length,
 						  void *pvma);
+
+GM_ENTRY_POINT gm_status_t gm_register_memory_ex_phys (struct gm_port *p,
+						       gm_u64_t phys, gm_size_t length,
+						       gm_up_t pvma);
 #endif /* GM_API_VERSION >= GM_API_VERSION_2_0_6 */
 
 #if GM_API_VERSION >= GM_API_VERSION_2_1_0
Index: libgm/gm_reference_api.c
===================================================================
RCS file: /repository/gm/libgm/gm_reference_api.c,v
retrieving revision 1.3.14.1
diff -u -r1.3.14.1 gm_reference_api.c
--- libgm/gm_reference_api.c	23 Apr 2004 20:27:29 -0000	1.3.14.1
+++ libgm/gm_reference_api.c	25 Aug 2005 22:39:20 -0000
@@ -154,6 +154,9 @@
 GM_REF (gm_register_buffer);
 GM_REF (gm_register_memory);
 GM_REF (gm_register_memory_ex);
+#if GM_KERNEL && (GM_CPU_x86 || GM_CPU_x86_64 || GM_CPU_ia64)
+GM_REF (gm_register_memory_ex_phys);
+#endif
 GM_REF (gm_resume_sending);
 GM_REF (gm_send);
 GM_REF (gm_send_to_peer);
