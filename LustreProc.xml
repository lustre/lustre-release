<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. -->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0"
  xml:lang="en-US" xml:id="lustreproc">
  <title xml:id="lustreproc.title">LustreProc</title>
  <para>The <literal>/proc</literal> file system acts as an interface to internal data structures in
    the kernel. This chapter describes entries in <literal>/proc</literal> that are useful for
    tuning and monitoring aspects of a Lustre file system. It includes these sections:</para>
  <itemizedlist>
    <listitem>
      <para><xref linkend="dbdoclet.50438271_90999"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438271_78950"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438271_83523"/></para>
      <para>The <literal>/proc</literal> directory provides a file-system like interface to internal
        data structures in the kernel. These data structures include settings and metrics for
        components such as memory, networking, file systems, and kernel housekeeping routines, which
        are available throughout the hierarchical file layout in <literal>/proc.</literal>
        Typically, metrics are accessed by reading from <literal>/proc</literal> files and settings
        are changed by writing to <literal>/proc</literal> files. </para>
      <para>The <literal>/proc</literal> directory contains files that allow an operator to
        interface with the Lustre file system to tune and monitor many aspects of system and
        application performance.</para>
    </listitem>
  </itemizedlist>
  <section xml:id="dbdoclet.50438271_90999">
    <title><indexterm>
        <primary>proc</primary>
      </indexterm> Lustre Entries in /proc</title>
    <para>This section describes <literal>/proc</literal> entries for Lustre.</para>
    <section remap="h3">
      <title>Locating Lustre File Systems and Servers</title>
      <para>Use the <literal>/proc</literal> files on the MGS to locate the following:</para>
      <itemizedlist>
        <listitem>
          <para> All known file systems</para>
          <screen>mgs# cat /proc/fs/lustre/mgs/MGS/filesystems
testfs
lustre</screen>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para> The names of the servers in a file system (for a file system that has at least one
            server running)</para>
          <screen>mgs# cat /proc/fs/lustre/mgs/MGS/live/testfs
fsname: testfs
flags: 0x0         gen: 7
testfs-MDT0000
testfs-OST0000</screen>
        </listitem>
      </itemizedlist>
      <para>All servers are named according to the convention
            <literal><replaceable>fsname</replaceable>-<replaceable>MDT|OSTnumber</replaceable></literal>.
        Server names for live servers are listed under
        <literal>/proc/fs/lustre/devices</literal>:</para>
      <screen>mds# cat /proc/fs/lustre/devices 
0 UP mgs MGS MGS 11
1 UP mgc MGC192.168.10.34@tcp 1f45bb57-d9be-2ddb-c0b0-5431a49226705
2 UP mdt MDS MDS_uuid 3
3 UP lov lustre-mdtlov lustre-mdtlov_UUID 4
4 UP mds lustre-MDT0000 lustre-MDT0000_UUID 7
5 UP osc lustre-OST0000-osc lustre-mdtlov_UUID 5
6 UP osc lustre-OST0001-osc lustre-mdtlov_UUID 5
7 UP lov lustre-clilov-ce63ca00 08ac6584-6c4a-3536-2c6d-b36cf9cbdaa04
8 UP mdc lustre-MDT0000-mdc-ce63ca00 08ac6584-6c4a-3536-2c6d-b36cf9cbdaa05
9 UP osc lustre-OST0000-osc-ce63ca00 08ac6584-6c4a-3536-2c6d-b36cf9cbdaa05
10 UP osc lustre-OST0001-osc-ce63ca00 08ac6584-6c4a-3536-2c6d-b36cf9cbdaa05</screen>
      <para>A server name can also be displayed by viewing the device label at any time.</para>
      <screen>mds# e2label /dev/sda
lustre-MDT0000</screen>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>timeouts</secondary>
        </indexterm>Timeouts in a Lustre File System</title>
      <para>Two types of timeouts are used in a Lustre file system.</para>
      <itemizedlist>
        <listitem>
          <para><emphasis role="italic">LND timeouts</emphasis> - LND timeouts ensure that
            point-to-point communications complete in a finite time in the presence of failures.
            These timeouts are logged with the <literal>S_LND</literal> flag set. They are not
            printed as console messages, so you should check the Lustre log for
              <literal>D_NETERROR</literal> messages or enable printing of
              <literal>D_NETERROR</literal> messages to the console (<literal>lctl set_param
              printk=+neterror</literal>).</para>
          <para>Congested routers can be a source of spurious LND timeouts. To avoid this situation,
            increase the number of LNET router buffers to reduce back-pressure and/or increase LND
            timeouts on all nodes on all connected networks. Also consider increasing the total
            number of LNET router nodes in the system so that the aggregate router bandwidth matches
            the aggregate server bandwidth.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><emphasis role="italic">Lustre timeouts </emphasis>- Lustre timeouts ensure that
            Lustre RPCs complete in a finite time in the presence of failures. These timeouts are
            always printed as console messages. If Lustre timeouts are not accompanied by LNET
            timeouts, then increase the Lustre timeout on both servers and clients.</para>
        </listitem>
      </itemizedlist>
      <para>Specific Lustre timeouts include:</para>
      <itemizedlist>
        <listitem>
          <para><literal>/proc/sys/lustre/timeout</literal> - The time period that a client waits
            for a server to complete an RPC (default is 100s). Servers wait half of this time for a
            normal client RPC to complete and a quarter of this time for a single bulk request (read
            or write of up to 4 MB) to complete. The client pings recoverable targets (MDS and OSTs)
            at one quarter of the timeout, and the server waits one and a half times the timeout
            before evicting a client for being &quot;stale.&quot;</para>
          <note>
            <para>A Lustre client sends periodic &apos;ping&apos; messages to servers with which it
              has had no communication for a specified period of time. Any network activity between
              a client and a server in the file system also serves as a ping.</para>
          </note>
        </listitem>
        <listitem>
          <para><literal>/proc/sys/lustre/ldlm_timeout</literal> - The time period for which a
            server will wait for a client to reply to an initial AST (lock cancellation request),
            where the default is 20s for an OST and 6s for an MDS. If the client replies to the AST,
            the server will give it a normal timeout (half the client timeout) to flush any dirty
            data and release the lock.</para>
        </listitem>
        <listitem>
          <para><literal>/proc/sys/lustre/fail_loc</literal> - The internal debugging failure hook.
            See <literal>lustre/include/linux/obd_support.h</literal> for the definitions of
            individual failure locations. The default value is 0 (zero).</para>
        </listitem>
        <listitem>
          <para><literal>/proc/sys/lustre/dump_on_timeout</literal> - Triggers dumps of the Lustre
            debug log when timeouts occur. The default value is 0 (zero).</para>
        </listitem>
        <listitem>
          <para><literal>/proc/sys/lustre/dump_on_eviction</literal> - Triggers dumps of the Lustre
            debug log when an eviction occurs. The default value is 0 (zero). </para>
        </listitem>
      </itemizedlist>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>adaptive timeouts</secondary>
        </indexterm>Adaptive Timeouts</title>
      <para>In a Lustre file system, an adaptive mechanism is used to set RPC timeouts. The adaptive
        timeouts feature (enabled, by default) causes servers to track actual RPC completion times
        and to report estimated completion times for future RPCs back to clients. The clients use
        these estimates to set their future RPC timeout values. If server request processing slows
        down for any reason, the RPC completion estimates increase, and the clients allow more time
        for RPC completion.</para>
      <para>If RPCs queued on the server approach their timeouts, then the server sends an early
        reply to the client, telling the client to allow more time. In this manner, clients avoid
        RPC timeouts and disconnect/reconnect cycles. Conversely, as a server speeds up, RPC timeout
        values decrease, allowing faster detection of non-responsive servers and faster attempts to
        reconnect to the failover partner of the server.</para>
      <para>Adaptive timeouts were introduced in the Lustre 1.8.0.1 release. Prior to this release,
        the static <literal>obd_timeout</literal> (<literal>/proc/sys/lustre/timeout</literal>)
        value was used as the maximum completion time for all RPCs; this value also affected the
        client-server ping interval and initial recovery timer. With adaptive timeouts,
          <literal>obd_timeout</literal> is only used for the ping interval and initial recovery
        estimate. When a client reconnects during recovery, the server uses the client&apos;s
        timeout value to reset the recovery wait period; i.e., the server learns how long the client
        had been willing to wait, and takes this into account when adjusting the recovery
        period.</para>
      <section remap="h4">
        <title><indexterm>
            <primary>proc</primary>
            <secondary>configuring adaptive timeouts</secondary>
          </indexterm><indexterm>
            <primary>configuring</primary>
            <secondary>adaptive timeouts</secondary>
          </indexterm>Configuring Adaptive Timeouts</title>
        <para>A goal of adaptive timeouts is to relieve users from having to tune the
            <literal>obd_timeout</literal> value. In general, <literal>obd_timeout</literal> should
          no longer need to be changed. However, several parameters related to adaptive timeouts can
          be set by users. In most situations, the default values should be used.</para>
        <para>The following parameters can be set persistently system-wide using <literal>lctl
            conf_param</literal> on the MGS. For example, <literal>lctl conf_param
            testfs.sys.at_max=1500</literal> sets the <literal>at_max</literal> value for all
          servers and clients using the testfs file system.</para>
        <note>
          <para>Nodes using multiple Lustre file systems must use the same <literal>at_*</literal>
            values for all file systems.)</para>
        </note>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="30*"/>
            <colspec colname="c2" colwidth="80*"/>
            <thead>
              <row>
                <entry>
                  <para><emphasis role="bold">Parameter</emphasis></para>
                </entry>
                <entry>
                  <para><emphasis role="bold">Description</emphasis></para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>
                    <literal> at_min </literal></para>
                </entry>
                <entry>
                  <para>Sets the minimum adaptive timeout (in seconds). Default value is 0. The
                      <literal>at_min</literal> parameter is the minimum processing time that a
                    server will report. Clients base their timeouts on this value, but they do not
                    use this value directly. If you experience cases in which, for unknown reasons,
                    the adaptive timeout value is too short and clients time out their RPCs (usually
                    due to temporary network outages), then you can increase the
                      <literal>at_min</literal> value to compensate for this. Ideally, users should
                    leave <literal>at_min</literal> set to its default.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> at_max </literal></para>
                </entry>
                <entry>
                  <para>Sets the maximum adaptive timeout (in seconds). The
                      <literal>at_max</literal> parameter is an upper-limit on the service time
                    estimate and is used as a &apos;failsafe&apos; in case of rogue/bad/buggy code
                    that would lead to never-ending estimate increases. If <literal>at_max</literal>
                    is reached, an RPC request is considered &apos;broken&apos; and will time
                    out.</para>
                  <para>Setting <literal>at_max</literal> to 0 causes adaptive timeouts to be
                    disabled and the static fixed-timeout method (<literal>obd_timeout</literal>) to
                    be used.</para>
                  <note>
                    <para>It is possible that slow hardware might validly cause the service estimate
                      to increase beyond the default value of <literal>at_max</literal>. In this
                      case, you should increase <literal>at_max</literal> to the maximum time you
                      are willing to wait for an RPC completion.</para>
                  </note>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> at_history </literal></para>
                </entry>
                <entry>
                  <para>Sets a time period (in seconds) within which adaptive timeouts remember the
                    slowest event that occurred. Default value is 600.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> at_early_margin </literal></para>
                </entry>
                <entry>
                  <para>Sets how far before the deadline the Lustre client sends an early reply.
                    Default value is 5<footnote>
                      <para>This default was chosen as a reasonable time in which to send a reply
                        from the point at which it was sent.</para>
                    </footnote>.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> at_extra </literal></para>
                </entry>
                <entry>
                  <para>Sets the incremental amount of time that a server asks for, with each early
                    reply. The server does not know how much time the RPC will take, so it asks for
                    a fixed value. Default value is 30<footnote>
                      <para>This default was chosen as a balance between sending too many early
                        replies for the same RPC and overestimating the actual completion
                        time.</para>
                    </footnote>. When a server finds a queued request about to time out (and needs
                    to send an early reply out), the server adds the <literal>at_extra</literal>
                    value. If the time expires, the Lustre client enters recovery status and
                    reconnects to restore it to normal status.</para>
                  <para>If you see multiple early replies for the same RPC asking for multiple
                    30-second increases, change the <literal>at_extra</literal> value to a larger
                    number to cut down on early replies sent and, therefore, network load.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> ldlm_enqueue_min </literal></para>
                </entry>
                <entry>
                  <para>Sets the minimum lock enqueue time. Default value is 100. The
                      <literal>ldlm_enqueue</literal> time is the maximum of the measured enqueue
                    estimate (influenced by <literal>at_min</literal> and <literal>at_max</literal>
                    parameters), multiplied by a weighting factor, and the
                      <literal>ldlm_enqueue_min</literal> setting. LDLM lock enqueues were based on
                    the <literal>obd_timeout</literal> value; now they have a dedicated minimum
                    value. Lock enqueues increase as the measured enqueue times increase (similar to
                    adaptive timeouts).</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>Adaptive timeouts are enabled by default. To disable adaptive timeouts, at run time,
          set <literal>at_max</literal> to 0. On the MGS, run:</para>
        <screen>$ lctl conf_param <replaceable>fsname</replaceable>.sys.at_max=0</screen>
        <note>
          <para>Changing the status of adaptive timeouts at runtime may cause a transient client
            timeout, recovery, and reconnection.</para>
        </note>
      </section>
      <section remap="h4">
        <title><indexterm>
            <primary>proc</primary>
            <secondary>interpreting adaptive timeouts</secondary>
          </indexterm>Interpreting Adaptive Timeout Information</title>
        <para>Adaptive timeout information can be read from the timeouts files in
            <literal>/proc/fs/lustre/*/</literal> for each server and client or by using the
            <literal>lctl</literal> command.</para>
        <para>To read information from timeouts file, enter a command similar to:</para>
        <screen>cfs21:~# cat /proc/fs/lustre/ost/OSS/ost_io/timeouts</screen>
        <para>To use the <literal>lctl</literal> command, enter a command similar to:</para>
        <screen>$ lctl get_param -n ost.*.ost_io.timeouts</screen>
        <para>Example output:</para>
        <screen>service : cur 33  worst 34 (at 1193427052, 0d0h26m40s ago) 1 1 33 2</screen>
        <para>In this example, the <literal>ost_io</literal> service on this node is currently
          reporting an estimate of 33 seconds. The worst RPC service time was 34 seconds, and it
          happened 26 minutes ago.</para>
        <para>The output also provides a history of service times. In this example, four
          &quot;bins&quot; of <literal>adaptive_timeout_history</literal> are shown, with the
          maximum RPC time in each bin reported. In 0-150 seconds, the maximum RPC time was 1, with
          the same result in 150-300 seconds. From 300-450 seconds, the worst (maximum) RPC time was
          33 seconds, and from 450-600s the worst time was 2 seconds. The current estimated service
          time is the maximum value of the four bins (33 seconds in this example).</para>
        <para>Service times (as reported by the servers) are also tracked in the client OBDs:</para>
        <screen>cfs21:# lctl get_param osc.*.timeouts
last reply : 1193428639, 0d0h00m00s ago
network    : cur  1 worst  2 (at 1193427053, 0d0h26m26s ago)  1  1  1  1
portal 6   : cur 33 worst 34 (at 1193427052, 0d0h26m27s ago) 33 33 33  2
portal 28  : cur  1 worst  1 (at 1193426141, 0d0h41m38s ago)  1  1  1  1
portal 7   : cur  1 worst  1 (at 1193426141, 0d0h41m38s ago)  1  0  1  1
portal 17  : cur  1 worst  1 (at 1193426177, 0d0h41m02s ago)  1  0  0  1
</screen>
        <para>In this case, RPCs to portal 6, the <literal>OST_IO_PORTAL</literal> (see
            <literal>lustre/include/lustre/lustre_idl.h</literal>), shows the history of what the
            <literal>ost_io</literal> portal has reported as the service estimate.</para>
        <para>Server statistic files also show the range of estimates in the order
          min/max/sum/sumsq.</para>
        <screen>cfs21:~# lctl get_param mdt.*.mdt.stats
...
req_timeout               6 samples [sec] 1 10 15 105
...
</screen>
      </section>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>LNET</secondary>
        </indexterm><indexterm>
          <primary>LNET</primary>
          <secondary>proc</secondary>
        </indexterm>LNET Information</title>
      <para>This section describes <literal>/proc</literal> entries containing LNET information.
        These entries include:<itemizedlist>
          <listitem>
            <para><literal>/proc/sys/lnet/peers</literal> - Shows all NIDs known to this node and
              provides information on the queue state.</para>
            <para>Example:</para>
            <screen># cat /proc/sys/lnet/peers
nid                refs   state  max  rtr  min   tx    min   queue
0@lo               1      ~rtr   0    0    0     0     0     0
192.168.10.35@tcp  1      ~rtr   8    8    8     8     6     0
192.168.10.36@tcp  1      ~rtr   8    8    8     8     6     0
192.168.10.37@tcp  1      ~rtr   8    8    8     8     6     0</screen>
            <para>The fields are explained in the table below:</para>
            <informaltable frame="all">
              <tgroup cols="2">
                <colspec colname="c1" colwidth="30*"/>
                <colspec colname="c2" colwidth="80*"/>
                <thead>
                  <row>
                    <entry>
                      <para><emphasis role="bold">Field</emphasis></para>
                    </entry>
                    <entry>
                      <para><emphasis role="bold">Description</emphasis></para>
                    </entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>
                      <para>
                        <literal>
                          <replaceable>refs</replaceable>
                        </literal>
                      </para>
                    </entry>
                    <entry>
                      <para>A reference count (principally used for debugging).</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal>
                          <replaceable>state</replaceable>
                        </literal>
                      </para>
                    </entry>
                    <entry>
                      <para>Only valid to refer to routers. Possible values:</para>
                      <itemizedlist>
                        <listitem>
                          <para><literal>~rtr</literal> (indicates this node is not a router)</para>
                        </listitem>
                        <listitem>
                          <para><literal>up/down</literal> (indicates this node is a router)</para>
                        </listitem>
                        <listitem>
                          <para><literal>auto_fail</literal> (if enabled)</para>
                        </listitem>
                      </itemizedlist>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> max </literal></para>
                    </entry>
                    <entry>
                      <para>Maximum number of concurrent sends from this peer.</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> rtr </literal></para>
                    </entry>
                    <entry>
                      <para>Routing buffer credits.</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> min </literal></para>
                    </entry>
                    <entry>
                      <para>Minimum routing buffer credits seen.</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> tx </literal></para>
                    </entry>
                    <entry>
                      <para>Send credits.</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> min </literal></para>
                    </entry>
                    <entry>
                      <para>Minimum send credits seen.</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> queue </literal></para>
                    </entry>
                    <entry>
                      <para>Total bytes in active/queued sends.</para>
                    </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
            <para>Credits work like a semaphore. They are initialized to allow a certain number of
              operations (8 in the example above). LNET keeps a track of the minimum value so that
              you can see how congested a resource is.</para>
            <para>A value of <literal>rtr/tx</literal> less than <literal>max</literal> indicates
              operations are in progress. The number of operations is equal to
                <literal>rtr</literal> or <literal>tx</literal> subtracted from
                <literal>max</literal>.</para>
            <para>A value of <literal>rtr/tx</literal> greater that <literal>max</literal> indicates
              operations are blocking.</para>
            <para>LNET also limits concurrent sends and router buffers allocated to a single peer so
              that no peer can occupy all these resources.</para>
          </listitem>
        </itemizedlist><itemizedlist>
          <listitem>
            <para><literal>/proc/sys/lnet/nis</literal> - Shows the current queue health on this
              node.</para>
            <para>Example:</para>
            <screen># cat /proc/sys/lnet/nis
nid                    refs   peer    max   tx    min
0@lo                   3      0       0     0     0
192.168.10.34@tcp      4      8       256   256   252
</screen>
            <para> The fields are explained below:</para>
            <informaltable frame="all">
              <tgroup cols="2">
                <colspec colname="c1" colwidth="30*"/>
                <colspec colname="c2" colwidth="80*"/>
                <thead>
                  <row>
                    <entry>
                      <para><emphasis role="bold">Field</emphasis></para>
                    </entry>
                    <entry>
                      <para><emphasis role="bold">Description</emphasis></para>
                    </entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>
                      <para>
                        <literal> nid </literal></para>
                    </entry>
                    <entry>
                      <para>Network interface.</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> refs </literal></para>
                    </entry>
                    <entry>
                      <para>Internal reference counter.</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> peer </literal></para>
                    </entry>
                    <entry>
                      <para>Number of peer-to-peer send credits on this NID. Credits are used to
                        size buffer pools.</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> max </literal></para>
                    </entry>
                    <entry>
                      <para>Total number of send credits on this NID.</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> tx </literal></para>
                    </entry>
                    <entry>
                      <para>Current number of send credits available on this NID.</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> min </literal></para>
                    </entry>
                    <entry>
                      <para>Lowest number of send credits available on this NID.</para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <literal> queue </literal></para>
                    </entry>
                    <entry>
                      <para>Total bytes in active/queued sends.</para>
                    </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
            <para>Subtracting <literal>max</literal> - <literal>tx</literal> yields the number of
              sends currently active. A large or increasing number of active sends may indicate a
              problem.</para>
            <para>Example:</para>
            <screen># cat /proc/sys/lnet/nis
nid                   refs       peer       max        tx         min
0@lo                  2          0          0          0          0
10.67.73.173@tcp      4          8          256        256        253
</screen>
          </listitem>
        </itemizedlist></para>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>free space</secondary>
        </indexterm>Free Space Distribution</title>
      <para>Free-space stripe weighting, as set, gives a priority of &quot;0&quot; to free space
        (versus trying to place the stripes &quot;widely&quot; -- nicely distributed across OSSs and
        OSTs to maximize network balancing). To adjust this priority as a percentage, use the
          <literal>/proc</literal> tunable<literal>qos_prio_free</literal>:</para>
      <screen>$ cat /proc/fs/lustre/lov/<replaceable>fsname</replaceable>-mdtlov/qos_prio_free</screen>
      <para>The default is 90%. You can permanently set this value by running this command on the
        MGS:</para>
      <screen>$ lctl conf_param <replaceable>fsname</replaceable>-MDT0000.lov.qos_prio_free=90</screen>
      <para>Setting the priority to 100% means that OSS distribution does not count in the
        weighting, but the stripe assignment is still done via weighting. If OST 2 has twice as much
        free space as OST 1, it is twice as likely to be used, but it is NOT guaranteed to be
        used.</para>
      <para>Also note that free-space stripe weighting does not activate until two OSTs are
        imbalanced by more than 20%. Until then, a faster round-robin stripe allocator is used. (The
        round-robin order also maximizes network balancing.)</para>
      <section remap="h4">
        <title><indexterm>
            <primary>proc</primary>
            <secondary>striping</secondary>
          </indexterm>Managing Stripe Allocation</title>
        <para>The MDS uses two methods to manage stripe allocation and determine which OSTs to use
          for file object storage:</para>
        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">QOS</emphasis></para>
            <para>Quality of Service (QOS) considers an OST&apos;s available blocks, speed, and the
              number of existing objects, etc. Using these criteria, the MDS selects OSTs with more
              free space more often than OSTs with less free space.</para>
          </listitem>
        </itemizedlist>
        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">RR</emphasis></para>
            <para>Round-Robin (RR) allocates objects evenly across all OSTs. The RR stripe allocator
              is faster than QOS, and used often because it distributes space usage/load best in
              most situations, maximizing network balancing and improving performance.</para>
          </listitem>
        </itemizedlist>
        <para>Whether QOS or RR is used depends on the setting of the
            <literal>qos_threshold_rr</literal> proc tunable. The
            <literal>qos_threshold_rr</literal> variable specifies a percentage threshold where the
          use of QOS or RR becomes more/less likely. The <literal>qos_threshold_rr</literal> tunable
          can be set as an integer, from 0 to 100, and results in this stripe allocation
          behavior:</para>
        <itemizedlist>
          <listitem>
            <para> If <literal>qos_threshold_rr</literal> is set to 0, then QOS is always
              used</para>
          </listitem>
          <listitem>
            <para> If <literal>qos_threshold_rr</literal> is set to 100, then RR is always
              used</para>
          </listitem>
          <listitem>
            <para> The larger the <literal>qos_threshold_rr</literal> setting, the greater the
              possibility that RR is used instead of QOS</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>
  <section xml:id="dbdoclet.50438271_78950">
    <title><indexterm>
        <primary>proc</primary>
        <secondary>I/O tunables</secondary>
      </indexterm>Lustre I/O Tunables</title>
    <para>This section describes I/O tunables.</para>
    <para><literal> llite.<replaceable>fsname-instance</replaceable>/max_cache_mb</literal></para>
    <screen>client# lctl get_param llite.lustre-ce63ca00.max_cached_mb
128</screen>
    <para>This tunable is the maximum amount of inactive data cached by the client (default is 3/4
      of RAM).</para>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>RPC tunables</secondary>
        </indexterm>Client I/O RPC Stream Tunables</title>
      <para>The Lustre engine always attempts to pack an optimal amount of data into each I/O RPC
        and attempts to keep a consistent number of issued RPCs in progress at a time. Lustre
        exposes several tuning variables to adjust behavior according to network conditions and
        cluster size. Each OSC has its own tree of these tunables. For example:</para>
      <screen>$ ls -d /proc/fs/lustre/osc/OSC_client_ost1_MNT_client_2 /localhost
/proc/fs/lustre/osc/OSC_uml0_ost1_MNT_localhost
/proc/fs/lustre/osc/OSC_uml0_ost2_MNT_localhost
/proc/fs/lustre/osc/OSC_uml0_ost3_MNT_localhost
$ ls /proc/fs/lustre/osc/OSC_uml0_ost1_MNT_localhost
blocksizefilesfree max_dirty_mb ost_server_uuid stats</screen>
      <para>... and so on.</para>
      <para>RPC stream tunables are described below.</para>
      <para>
        <itemizedlist>
          <listitem xml:id="lustreproc.maxdirtymb">
            <para><literal>osc.<replaceable>osc_instance</replaceable>.max_dirty_mb</literal> - This
              tunable controls how many MBs of dirty data can be written and queued up in the
                <literal>OSC. POSIX</literal> file writes that are cached contribute to this count.
              When the limit is reached, additional writes stall until previously-cached writes are
              written to the server. This may be changed by writing a single ASCII integer to the
              file. Only values between 0 and 2048 or 1/4 of RAM are allowable. If 0 is given, no
              writes are cached. Performance suffers noticeably unless you use large writes (1 MB or
              more).</para>
          </listitem>
          <listitem>
            <para><literal>osc.<replaceable>osc_instance</replaceable>.cur_dirty_bytes</literal> -
              This tunable is a read-only value that returns the current amount of bytes written and
              cached on this OSC.</para>
          </listitem>
          <listitem>
            <para><literal>osc.<replaceable>osc_instance</replaceable>.max_pages_per_rpc</literal> -
              This tunable is the maximum number of pages that will undergo I/O in a single RPC to
              the OST. The minimum is a single page and the maximum for this setting is 1024 (for
              systems with 4kB <literal>PAGE_SIZE</literal>), with the default maximum of 1MB in the
              RPC. It is also possible to specify a units suffix (e.g. <literal>4M</literal>), so
              that the RPC size can be specified independently of the client
                <literal>PAGE_SIZE</literal>.</para>
          </listitem>
          <listitem>
            <para><literal>osc.<replaceable>osc_instance</replaceable>.max_rpcs_in_flight</literal>
              - This tunable is the maximum number of concurrent RPCs in flight from an OSC to its
              OST. If the OSC tries to initiate an RPC but finds that it already has the same number
              of RPCs outstanding, it will wait to issue further RPCs until some complete. The
              minimum setting is 1 and maximum setting is 256. If you are looking to improve small
              file I/O performance, increase the <literal>max_rpcs_in_flight</literal> value.</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>To maximize performance, the value for <literal>max_dirty_mb</literal> is recommended to
        be 4 * <literal>max_pages_per_rpc</literal> * <literal>max_rpcs_in_flight</literal>.</para>
      <note>
        <para>The <literal><replaceable>osc_instance</replaceable></literal> is typically
              <literal><replaceable>fsname</replaceable>-OST<replaceable>ost_index</replaceable>-osc-<replaceable>mountpoint_instance</replaceable></literal>.
          The <literal><replaceable>mountpoint_instance</replaceable></literal> is a unique value
          per mount point to allow associating osc, mdc, lov, lmv, and llite parameters for the same
          mount point. For <literal><replaceable>osc_instance</replaceable></literal> examples,
          refer to the sample command output.</para>
      </note>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>watching RPC</secondary>
        </indexterm>Watching the Client RPC Stream</title>
      <para>The same directory contains an <literal>rpc_stats</literal> file with a histogram
        showing the composition of previous RPCs. The histogram can be cleared by writing any value
        into the <literal>rpc_stats</literal> file.</para>
      <screen># cat /proc/fs/lustre/osc/testfs-OST0000-osc-c45f9c00/rpc_stats
snapshot_time:                       1174867307.156604 (secs.usecs)
read RPCs in flight:                 0
write RPCs in flight:                0
pending write pages:                 0
pending read pages:                  0
                read                                write
pages per rpc   rpcs  %   cum   %    |   rpcs   %   cum     %
1:              0     0   0          |   0          0       0
 
                read                                write
rpcs in flight  rpcs  %   cum   %    |   rpcs   %   cum     %
0:              0     0   0          |   0          0       0
 
                read                                write
offset          rpcs  %   cum   %    |   rpcs   %   cum     %
0:              0     0   0          |   0          0       0


# cat /proc/fs/lustre/osc/testfs-OST0000-osc-ffff810058d2f800/rpc_stats
snapshot_time:            1372786692.389858 (secs.usecs)
read RPCs in flight:      0
write RPCs in flight:     1
dio read RPCs in flight:  0
dio write RPCs in flight: 0
pending write pages:      256
pending read pages:       0

                     read                   write
pages per rpc   rpcs   % cum % |       rpcs   % cum %
1:                 0   0   0   |          0   0   0
2:                 0   0   0   |          1   0   0
4:                 0   0   0   |          0   0   0
8:                 0   0   0   |          0   0   0
16:                0   0   0   |          0   0   0
32:                0   0   0   |          2   0   0
64:                0   0   0   |          2   0   0
128:               0   0   0   |          5   0   0
256:             850 100 100   |      18346  99 100

                     read                   write
rpcs in flight  rpcs   % cum % |       rpcs   % cum %
0:               691  81  81   |       1740   9   9
1:                48   5  86   |        938   5  14
2:                29   3  90   |       1059   5  20
3:                17   2  92   |       1052   5  26
4:                13   1  93   |        920   5  31
5:                12   1  95   |        425   2  33
6:                10   1  96   |        389   2  35
7:                30   3 100   |      11373  61  97
8:                 0   0 100   |        460   2 100

                     read                   write
offset          rpcs   % cum % |       rpcs   % cum %
0:               850 100 100   |      18347  99  99
1:                 0   0 100   |          0   0  99
2:                 0   0 100   |          0   0  99
4:                 0   0 100   |          0   0  99
8:                 0   0 100   |          0   0  99
16:                0   0 100   |          1   0  99
32:                0   0 100   |          1   0  99
64:                0   0 100   |          3   0  99
128:               0   0 100   |          4   0 100

</screen>
      <para>Where:</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="40*"/>
          <colspec colname="c2" colwidth="60*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Field</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> {read,write} RPCs in flight</para>
              </entry>
              <entry>
                <para>Number of read/write RPCs issued by the OSC, but not complete at the time of
                  the snapshot. This value should always be less than or equal to
                    <literal>max_rpcs_in_flight</literal>.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> pending {read,write} pages</para>
              </entry>
              <entry>
                <para>Number of pending read/write pages that have been queued for I/O in the
                  OSC.</para>
              </entry>
            </row>
            <row>
              <entry>dio {read,write} RPCs in flight</entry>
              <entry>Direct I/O (as opposed to block I/O) read/write RPCs issued but not completed
                at the time of the snapshot.</entry>
            </row>
            <row>
              <entry>
                <para> pages per RPC</para>
              </entry>
              <entry>
                <para>When an RPC is sent, the number of pages it consists of is recorded (in
                  order). A single page RPC increments the <literal>0:</literal> row.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> RPCs in flight</para>
              </entry>
              <entry>
                <para>When an RPC is sent, the number of other RPCs that are pending is recorded.
                  When the first RPC is sent, the <literal>0:</literal> row is incremented. If the
                  first RPC is sent while another is pending, the <literal>1:</literal> row is
                  incremented and so on. As each RPC *completes*, the number of pending RPCs is not
                  tabulated.</para>
                <para>This table is a good way to visualize the concurrency of the RPC stream.
                  Ideally, you will see a large clump around the
                    <literal>max_rpcs_in_flight</literal> value, which shows that the network is
                  being kept busy.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> offset</para>
              </entry>
              <entry>
                <para> </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Each row in the table shows the number of reads or writes occurring for the statistic
        (ios), the relative percentage of total reads or writes (%), and the cumulative percentage
        to that point in the table for the statistic (cum %).</para>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>read/write survey</secondary>
        </indexterm>Client Read-Write Offset Survey</title>
      <para>The <literal>offset_stats</literal> parameter maintains statistics for occurrences where
        a series of read or write calls from a process did not access the next sequential location.
        The offset field is reset to 0 (zero) whenever a different file is read/written.</para>
      <para>Read/write offset statistics are off by default. The statistics can be activated by
        writing anything into the <literal>offset_stats</literal> file.</para>
      <para>Example:</para>
      <screen># cat /proc/fs/lustre/llite/lustre-f57dee00/rw_offset_stats
snapshot_time: 1155748884.591028 (secs.usecs)
             RANGE   RANGE    SMALLEST   LARGEST   
R/W   PID    START   END      EXTENT     EXTENT    OFFSET
R     8385   0       128      128        128       0
R     8385   0       224      224        224       -128
W     8385   0       250      50         100       0
W     8385   100     1110     10         500       -150
W     8384   0       5233     5233       5233      0
R     8385   500     600      100        100       -610</screen>
      <para>Where:</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Field</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> R/W</para>
              </entry>
              <entry>
                <para>Whether the non-sequential call was a read or write</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> PID </para>
              </entry>
              <entry>
                <para>Process ID which made the read/write call.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> Range Start/Range End</para>
              </entry>
              <entry>
                <para>Range in which the read/write calls were sequential.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> Smallest Extent </para>
              </entry>
              <entry>
                <para>Smallest extent (single read/write) in the corresponding range.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> Largest Extent </para>
              </entry>
              <entry>
                <para>Largest extent (single read/write) in the corresponding range.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> Offset </para>
              </entry>
              <entry>
                <para>Difference between the previous range end and the current range start.</para>
                <para>For example, Smallest-Extent indicates that the writes in the range 100 to
                  1110 were sequential, with a minimum write of 10 and a maximum write of 500. This
                  range was started with an offset of -150. That means this is the difference
                  between the last entry&apos;s range-end and this entry&apos;s range-start for the
                  same file.</para>
                <para>The <literal>rw_offset_stats</literal> file can be cleared by writing to
                  it:</para>
                <para><literal>lctl set_param llite.*.rw_offset_stats=0</literal></para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section xml:id="lustreproc.clientstats" remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>client stats</secondary>
        </indexterm>Client Statistics </title>
      <para>The <literal>stats</literal> parameter maintains statistics of activity across the VFS
        interface of the Lustre file system. Only non-zero parameters are displayed in the file.
        This section describes the statistics that accumulate during typical operation of a
        client.</para>
      <para>Client statistics are enabled by default. The statistics can be cleared by echoing an
        empty string into the <literal>stats</literal> file or by using the command: <literal>lctl
          set_param llite.*.stats=0</literal>. Statistics for an individual file system can be
        displayed, for example, as shown below:</para>
      <screen>client# lctl get_param llite.*.stats
snapshot_time          1308343279.169704 secs.usecs
dirty_pages_hits       14819716 samples [regs]
dirty_pages_misses     81473472 samples [regs]
read_bytes             36502963 samples [bytes] 1 26843582 55488794
write_bytes            22985001 samples [bytes] 0 125912 3379002
brw_read               2279 samples [pages] 1 1 2270
ioctl                  186749 samples [regs]
open                   3304805 samples [regs]
close                  3331323 samples [regs]
seek                   48222475 samples [regs]
fsync                  963 samples [regs]
truncate               9073 samples [regs]
setxattr               19059 samples [regs]
getxattr               61169 samples [regs]
</screen>
      <note>
        <para>Statistics for all mounted file systems can be discovered by issuing the
            <literal>lctl</literal> command <literal>lctl get_param llite.*.stats</literal></para>
      </note>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="3*"/>
          <colspec colname="c2" colwidth="7*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Field</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <literal>snapshot_time</literal></para>
              </entry>
              <entry>
                <para>UNIX* epoch instant the stats file was read.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>dirty_page_hits</literal></para>
              </entry>
              <entry>
                <para>A count of the number of write operations that have been satisfied by the
                  dirty page cache. See <xref xmlns:xlink="http://www.w3.org/1999/xlink"
                    linkend="lustreproc.maxdirtymb"/> for dirty cache behavior in a Lustre file
                  system.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>dirty_page_misses</literal></para>
              </entry>
              <entry>
                <para>A count of the number of write operations that were not satisfied by the dirty
                  page cache.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>read_bytes</literal></para>
              </entry>
              <entry>
                <para>A count of the number of read operations that have occurred (samples). Three
                  additional parameters are given:</para>
                <variablelist>
                  <varlistentry>
                    <term>min</term>
                    <listitem>
                      <para>The minimum number of bytes read in a single request since the counter
                        was reset.</para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>max</term>
                    <listitem>
                      <para>The maximum number of bytes read in a single request since the counter
                        was reset.</para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>sum</term>
                    <listitem>
                      <para>The accumulated sum of bytes of all read requests since the counter was
                        reset.</para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>write_bytes</literal></para>
              </entry>
              <entry>
                <para>A count of the number of write operations that have occurred (samples). Three
                  additional parameters are given:</para>
                <variablelist>
                  <varlistentry>
                    <term>min</term>
                    <listitem>
                      <para>The minimum number of bytes written in a single request since the
                        counter was reset.</para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>max</term>
                    <listitem>
                      <para>The maximum number of bytes written in a single request since the
                        counter was reset.</para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>sum</term>
                    <listitem>
                      <para>The accumulated sum of bytes of all write requests since the counter was
                        reset.</para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>brw_read</literal></para>
              </entry>
              <entry>
                <para>A count of the number of pages that have been read.</para>
                <warning>
                  <para><literal>brw_</literal> stats are only tallied when the lloop device driver
                    is present. lloop device is not currently supported.</para>
                </warning>
                <para>Three additional parameters are given:</para>
                <variablelist>
                  <varlistentry>
                    <term>min</term>
                    <listitem>
                      <para>The minimum number of bytes read in a single brw read requests since the
                        counter was reset.</para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>max</term>
                    <listitem>
                      <para>The maximum number of bytes read in a single brw read requests since the
                        counter was reset.</para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>sum</term>
                    <listitem>
                      <para>The accumulated sum of bytes of all brw read requests since the counter
                        was reset.</para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>ioctl</literal></para>
              </entry>
              <entry>
                <para>A count of the number of the combined file and directory ioctl
                  operations.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>open</literal></para>
              </entry>
              <entry>
                <para>A count of the number of open operations that have succeeded.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>close</literal></para>
              </entry>
              <entry>
                <para>A count of the number of close operations that have succeeded.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>seek</literal></para>
              </entry>
              <entry>
                <para>A count of the number of times <literal>seek</literal> has been called.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>fsync</literal></para>
              </entry>
              <entry>
                <para>A count of the number of times <literal>fsync</literal> has been
                  called.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>truncate</literal></para>
              </entry>
              <entry>
                <para>A count of the total number of calls to both locked and lockless
                  truncate.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>setxattr</literal></para>
              </entry>
              <entry>
                <para>A count of the number of times <literal>ll_setxattr</literal> has been
                  called.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>getxattr</literal></para>
              </entry>
              <entry>
                <para>A count of the number of times <literal>ll_getxattr</literal> has been
                  called.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>read/write survey</secondary>
        </indexterm>Client Read-Write Extents Survey</title>
      <para><emphasis role="bold">Client-Based I/O Extent Size Survey</emphasis></para>
      <para>The <literal>rw_extent_stats</literal> histogram in the <literal>llite</literal>
        directory shows you the statistics for the sizes of the read-write I/O extents. This file
        does not maintain the per-process statistics.</para>
      <para>Example:</para>
      <screen>client# lctl get_param llite.testfs-*.extents_stats
snapshot_time:                     1213828728.348516 (secs.usecs)
                       read           |            write
extents          calls  %      cum%   |     calls  %     cum%
 
0K - 4K :        0      0      0      |     2      2     2
4K - 8K :        0      0      0      |     0      0     2
8K - 16K :       0      0      0      |     0      0     2
16K - 32K :      0      0      0      |     20     23    26
32K - 64K :      0      0      0      |     0      0     26
64K - 128K :     0      0      0      |     51     60    86
128K - 256K :    0      0      0      |     0      0     86
256K - 512K :    0      0      0      |     0      0     86
512K - 1024K :   0      0      0      |     0      0     86
1M - 2M :        0      0      0      |     11     13    100</screen>
      <para>The file can be cleared by issuing the following command:</para>
      <screen>client# lctl set_param llite.testfs-*.extents_stats=0</screen>
      <para><emphasis role="bold">Per-Process Client I/O Statistics</emphasis></para>
      <para>The <literal>extents_stats_per_process</literal> file maintains the I/O extent size
        statistics on a per-process basis. So you can track the per-process statistics for the last
          <literal>MAX_PER_PROCESS_HIST</literal> processes.</para>
      <para>Example:</para>
      <screen>lctl get_param llite.testfs-*.extents_stats_per_process
snapshot_time:                     1213828762.204440 (secs.usecs)
                          read            |             write
extents            calls   %      cum%    |      calls   %       cum%
 
PID: 11488
   0K - 4K :       0       0       0      |      0       0       0
   4K - 8K :       0       0       0      |      0       0       0
   8K - 16K :      0       0       0      |      0       0       0
   16K - 32K :     0       0       0      |      0       0       0
   32K - 64K :     0       0       0      |      0       0       0
   64K - 128K :    0       0       0      |      0       0       0
   128K - 256K :   0       0       0      |      0       0       0
   256K - 512K :   0       0       0      |      0       0       0
   512K - 1024K :  0       0       0      |      0       0       0
   1M - 2M :       0       0       0      |      10      100     100
 
PID: 11491
   0K - 4K :       0       0       0      |      0       0       0
   4K - 8K :       0       0       0      |      0       0       0
   8K - 16K :      0       0       0      |      0       0       0
   16K - 32K :     0       0       0      |      20      100     100
   
PID: 11424
   0K - 4K :       0       0       0      |      0       0       0
   4K - 8K :       0       0       0      |      0       0       0
   8K - 16K :      0       0       0      |      0       0       0
   16K - 32K :     0       0       0      |      0       0       0
   32K - 64K :     0       0       0      |      0       0       0
   64K - 128K :    0       0       0      |      16      100     100
 
PID: 11426
   0K - 4K :       0       0       0      |      1       100     100
 
PID: 11429
   0K - 4K :       0       0       0      |      1       100     100
 
</screen>
      <para>Each row in the table shows the number of reads or writes occurring for the statistic
        (ios), the relative percentage of total reads or writes (%), and the cumulative percentage
        to that point in the table for the statistic (cum %).</para>
    </section>
    <section xml:id="dbdoclet.50438271_55057">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>block I/O</secondary>
        </indexterm>Watching the OST Block I/O Stream</title>
      <para>Similarly, a <literal>brw_stats</literal> histogram in the obdfilter directory shows the
        statistics for number of I/O requests sent to the disk, their size, and whether they are
        contiguous on the disk or not.</para>
      <screen>oss# lctl get_param obdfilter.testfs-OST0000.brw_stats 
snapshot_time:                     1174875636.764630 (secs:usecs)
                   read                         write
pages per brw      brws    %      cum %   |     rpcs    %      cum %
1:                 0       0      0       |     0       0      0
                   read                         write
discont pages      rpcs    %      cum %   |     rpcs    %      cum %
1:                 0       0      0       |     0       0      0
                   read                         write
discont blocks     rpcs    %      cum %   |     rpcs    %      cum %
1:                 0       0      0       |     0       0      0
                   read                         write
dio frags          rpcs    %      cum %   |     rpcs    %      cum %
1:                 0       0      0       |     0       0      0
                   read                         write
disk ios in flight rpcs    %      cum %   |     rpcs    %      cum %
1:                 0       0      0       |     0       0      0
                   read                         write
io time (1/1000s)  rpcs    %      cum %   |     rpcs    %      cum %
1:                 0       0      0       |     0       0      0
                   read                         write
disk io size       rpcs    %      cum %   |     rpcs    %      cum %
1:                 0       0      0       |     0       0      0
                   read                         write

# cat ./obdfilter/testfs-OST0000/brw_stats
snapshot_time:         1372775039.769045 (secs.usecs)

                           read      |      write
pages per bulk r/w     rpcs  % cum % |  rpcs   % cum %
1:                     108 100 100   |    39   0   0
2:                       0   0 100   |     6   0   0
4:                       0   0 100   |     1   0   0
8:                       0   0 100   |     0   0   0
16:                      0   0 100   |     4   0   0
32:                      0   0 100   |    17   0   0
64:                      0   0 100   |    12   0   0
128:                     0   0 100   |    24   0   0
256:                     0   0 100   | 23142  99 100

                           read      |      write
discontiguous pages    rpcs  % cum % |  rpcs   % cum %
0:                     108 100 100   | 23245 100 100

                           read      |      write
discontiguous blocks   rpcs  % cum % |  rpcs   % cum %
0:                     108 100 100   | 23243  99  99
1:                       0   0 100   |     2   0 100

                           read      |      write
disk fragmented I/Os   ios   % cum % |   ios   % cum %
0:                      94  87  87   |     0   0   0
1:                      14  12 100   | 23243  99  99
2:                       0   0 100   |     2   0 100

                           read      |      write
disk I/Os in flight    ios   % cum % |   ios   % cum %
1:                      14 100 100   | 20896  89  89
2:                       0   0 100   |  1071   4  94
3:                       0   0 100   |   573   2  96
4:                       0   0 100   |   300   1  98
5:                       0   0 100   |   166   0  98
6:                       0   0 100   |   108   0  99
7:                       0   0 100   |    81   0  99
8:                       0   0 100   |    47   0  99
9:                       0   0 100   |     5   0 100

                           read      |      write
I/O time (1/1000s)     ios   % cum % |   ios   % cum %
1:                      94  87  87   |     0   0   0
2:                       0   0  87   |     7   0   0
4:                      14  12 100   |    27   0   0
8:                       0   0 100   |    14   0   0
16:                      0   0 100   |    31   0   0
32:                      0   0 100   |    38   0   0
64:                      0   0 100   | 18979  81  82
128:                     0   0 100   |   943   4  86
256:                     0   0 100   |  1233   5  91
512:                     0   0 100   |  1825   7  99
1K:                      0   0 100   |   99   0  99
2K:                      0   0 100   |     0   0  99
4K:                      0   0 100   |     0   0  99
8K:                      0   0 100   |    49   0 100

                           read      |      write
disk I/O size          ios   % cum % |   ios   % cum %
4K:                     14 100 100   |    41   0   0
8K:                      0   0 100   |     6   0   0
16K:                     0   0 100   |     1   0   0
32K:                     0   0 100   |     0   0   0
64K:                     0   0 100   |     4   0   0
128K:                    0   0 100   |    17   0   0
256K:                    0   0 100   |    12   0   0
512K:                    0   0 100   |    24   0   0
1M:                      0   0 100   | 23142  99 100
</screen>
      <para>The fields are explained below:</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Field</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <literal>pages per bulk r/w</literal></para>
              </entry>
              <entry>
                <para>Number of pages per RPC request, which should match aggregate client
                    <literal>rpc_stats</literal>.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>discontiguous pages</literal></para>
              </entry>
              <entry>
                <para>Number of discontinuities in the logical file offset of each page in a single
                  RPC.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>discontiguous blocks</literal></para>
              </entry>
              <entry>
                <para>Number of discontinuities in the physical block allocation in the file system
                  for a single RPC.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para><literal>disk fragmented I/Os</literal></para>
              </entry>
              <entry>
                <para>Number of I/Os that were not written entirely sequentially.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para><literal>disk I/Os in flight</literal></para>
              </entry>
              <entry>
                <para>Number of disk I/Os currently pending.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para><literal>I/O time (1/1000s)</literal></para>
              </entry>
              <entry>
                <para>Amount of time for each I/O operation to complete.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para><literal>disk I/O size</literal></para>
              </entry>
              <entry>
                <para>Size of each I/O operation.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Each row in the table shows the number of reads or writes occurring for the statistic
        (ios), the relative percentage of total reads or writes (%), and the cumulative percentage
        to that point in the table for the statistic (cum %).</para>
      <para>For each Lustre service, the following information is provided:</para>
      <itemizedlist>
        <listitem>
          <para>Number of requests</para>
        </listitem>
        <listitem>
          <para>Request wait time (avg, min, max and std dev)</para>
        </listitem>
        <listitem>
          <para>Service idle time (% of elapsed time)</para>
        </listitem>
      </itemizedlist>
      <para>Additionally, data on each Lustre service is provided by service type:</para>
      <itemizedlist>
        <listitem>
          <para>Number of requests of this type</para>
        </listitem>
        <listitem>
          <para>Request service time (avg, min, max and std dev)</para>
        </listitem>
      </itemizedlist>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>readahead</secondary>
        </indexterm>Using File Readahead and Directory Statahead</title>
      <para>Lustre 1.6.5.1 introduced file readahead and directory statahead functionality that read
        data into memory in anticipation of a process actually requesting the data. File readahead
        functionality reads file content data into memory. Directory statahead functionality reads
        metadata into memory. When readahead and/or statahead work well, a data-consuming process
        finds that the information it needs is available when requested, and it is unnecessary to
        wait for network I/O.</para>
      <para>Since Lustre 2.2.0, the directory statahead feature has been improved to enhance
        directory traversal performance. The improvements have concentrated on two main
        issues:</para>
      <orderedlist>
        <listitem>
          <para>A race condition between statahead thread and other VFS operations while processing
            asynchronous getattr RPC replies.</para>
        </listitem>
        <listitem>
          <para>There is no file size/block attributes pre-fetching and the traversing thread has to
            send synchronous glimpse size RPCs to OST(s).</para>
        </listitem>
      </orderedlist>
      <para>The first issue is resolved by using statahead local dcache, and the second one is
        resolved by using asynchronous glimpse lock (AGL) RPCs for pre-fetching file size/block
        attributes from OST(s).</para>
      <section remap="h4">
        <title>Tuning File Readahead</title>
        <para>File readahead is triggered when two or more sequential reads by an application fail
          to be satisfied by the Linux buffer cache. The size of the initial readahead is 1 MB.
          Additional readaheads grow linearly, and increment until the readahead cache on the client
          is full at 40 MB.</para>
        <para><literal> llite.<replaceable>fsname-instance</replaceable>.max_read_ahead_mb
          </literal></para>
        <para>This tunable controls the maximum amount of data readahead on a file. Files are read
          ahead in RPC-sized chunks (1 MB or the size of read() call, if larger) after the second
          sequential read on a file descriptor. Random reads are done at the size of the read() call
          only (no readahead). Reads to non-contiguous regions of the file reset the readahead
          algorithm, and readahead is not triggered again until there are sequential reads again. To
          disable readahead, set this tunable to 0. The default value is 40 MB.</para>
        <para><literal> llite.<replaceable>fsname-instance</replaceable>.max_read_ahead_whole_mb
          </literal></para>
        <para>This tunable controls the maximum size of a file that is read in its entirety,
          regardless of the size of the <literal>read()</literal>.</para>
      </section>
      <section remap="h4">
        <title>Tuning Directory Statahead and AGL</title>
        <para>Many system commands, like <literal>ls l</literal>, <literal>du</literal>,
            <literal>find</literal>, etc., will traverse directory sequentially. To make these
          commands run efficiently, the directory statahead and AGL (asynchronous glimpse lock) can
          be enabled to improve the performance of traversing.</para>
        <para><literal> /proc/fs/lustre/llite/*/statahead_max </literal></para>
        <para>This proc interface controls whether directory statahead is enabled and the maximum
          statahead windows size (which means how many files can be pre-fetched by the statahead
          thread). By default, statahead is enabled and the value of
            <literal>statahead_max</literal> is 32.</para>
        <para>To disable statahead, run:</para>
        <screen>lctl set_param llite.*.statahead_max=0</screen>
        <para>To set the maximum statahead windows size (n), run:</para>
        <screen>lctl set_param llite.*.statahead_max=n</screen>
        <para>The maximum value of n is 8192.</para>
        <para>The AGL can be controlled as follows:</para>
        <screen>lctl set_param llite.*.statahead_agl=n</screen>
        <para>If &quot;n&quot; is 0, then the AGL is disabled, else the AGL is enabled.</para>
        <para><literal> /proc/fs/lustre/llite/*/statahead_stats </literal></para>
        <para>This is a read-only interface that indicates the current statahead and AGL
          status.</para>
        <note>
          <para>The AGL is affected by statahead because the inodes processed by AGL are built by
            the statahead thread, which means the statahead thread is the input of AGL pipeline. So
            if statahead is disabled, then the AGL is disabled by force.</para>
        </note>
      </section>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>read cache</secondary>
        </indexterm>OSS Read Cache</title>
      <para>The OSS read cache feature provides read-only caching of data on an OSS. This
        functionality uses the regular Linux page cache to store the data. Just like caching from a
        regular filesystem in Linux, OSS read cache uses as much physical memory as is
        allocated.</para>
      <para>OSS read cache improves Lustre performance in these situations:</para>
      <itemizedlist>
        <listitem>
          <para>Many clients are accessing the same data set (as in HPC applications and when
            diskless clients boot from Lustre)</para>
        </listitem>
        <listitem>
          <para>One client is storing data while another client is reading it (essentially
            exchanging data via the OST)</para>
        </listitem>
        <listitem>
          <para>A client has very limited caching of its own</para>
        </listitem>
      </itemizedlist>
      <para>OSS read cache offers these benefits:</para>
      <itemizedlist>
        <listitem>
          <para>Allows OSTs to cache read data more frequently</para>
        </listitem>
        <listitem>
          <para>Improves repeated reads to match network speeds instead of disk speeds</para>
        </listitem>
        <listitem>
          <para>Provides the building blocks for OST write cache (small-write aggregation)</para>
        </listitem>
      </itemizedlist>
      <section remap="h4">
        <title>Using OSS Read Cache</title>
        <para>OSS read cache is implemented on the OSS, and does not require any special support on
          the client side. Since OSS read cache uses the memory available in the Linux page cache,
          you should use I/O patterns to determine the appropriate amount of memory for the cache;
          if the data is mostly reads, then more cache is required than for writes.</para>
        <para>OSS read cache is enabled, by default, and managed by the following tunables:</para>
        <itemizedlist>
          <listitem>
            <para><literal>read_cache_enable</literal> controls whether data read from disk during a
              read request is kept in memory and available for later read requests for the same
              data, without having to re-read it from disk. By default, read cache is enabled
                (<literal>read_cache_enable = 1</literal>).</para>
          </listitem>
        </itemizedlist>
        <para>When the OSS receives a read request from a client, it reads data from disk into its
          memory and sends the data as a reply to the requests. If read cache is enabled, this data
          stays in memory after the client&apos;s request is finished, and the OSS skips reading
          data from disk when subsequent read requests for the same are received. The read cache is
          managed by the Linux kernel globally across all OSTs on that OSS, and the least recently
          used cache pages will be dropped from memory when the amount of free memory is running
          low.</para>
        <para>If read cache is disabled (<literal>read_cache_enable = 0</literal>), then the OSS
          will discard the data after the client&apos;s read requests are serviced and, for
          subsequent read requests, the OSS must read the data from disk.</para>
        <para>To disable read cache on all OSTs of an OSS, run:</para>
        <screen>root@oss1# lctl set_param obdfilter.*.read_cache_enable=0</screen>
        <para>To re-enable read cache on one OST, run:</para>
        <screen>root@oss1# lctl set_param obdfilter.{OST_name}.read_cache_enable=1</screen>
        <para>To check if read cache is enabled on all OSTs on an OSS, run:</para>
        <screen>root@oss1# lctl get_param obdfilter.*.read_cache_enable</screen>
        <itemizedlist>
          <listitem>
            <para><literal>writethrough_cache_enable</literal> controls whether data sent to the OSS
              as a write request is kept in the read cache and available for later reads, or if it
              is discarded from cache when the write is completed. By default, writethrough cache is
              enabled (<literal>writethrough_cache_enable = 1</literal>).</para>
          </listitem>
        </itemizedlist>
        <para>When the OSS receives write requests from a client, it receives data from the client
          into its memory and writes the data to disk. If writethrough cache is enabled, this data
          stays in memory after the write request is completed, allowing the OSS to skip reading
          this data from disk if a later read request, or partial-page write request, for the same
          data is received.</para>
        <para>If writethrough cache is disabled (<literal>writethrough_cache_enabled = 0</literal>),
          then the OSS discards the data after the client&apos;s write request is completed, and for
          subsequent read request, or partial-page write request, the OSS must re-read the data from
          disk.</para>
        <para>Enabling writethrough cache is advisable if clients are doing small or unaligned
          writes that would cause partial-page updates, or if the files written by one node are
          immediately being accessed by other nodes. Some examples where this might be useful
          include producer-consumer I/O models or shared-file writes with a different node doing I/O
          not aligned on 4096-byte boundaries. Disabling writethrough cache is advisable in the case
          where files are mostly written to the file system but are not re-read within a short time
          period, or files are only written and re-read by the same node, regardless of whether the
          I/O is aligned or not.</para>
        <para>To disable writethrough cache on all OSTs of an OSS, run:</para>
        <screen>root@oss1# lctl set_param obdfilter.*.writethrough_cache_enable=0</screen>
        <para>To re-enable writethrough cache on one OST, run:</para>
        <screen>root@oss1# lctl set_param obdfilter.{OST_name}.writethrough_cache_enable=1</screen>
        <para>To check if writethrough cache is</para>
        <screen>root@oss1# lctl set_param obdfilter.*.writethrough_cache_enable=1</screen>
        <itemizedlist>
          <listitem>
            <para><literal>readcache_max_filesize</literal> controls the maximum size of a file that
              both the read cache and writethrough cache will try to keep in memory. Files larger
              than <literal>readcache_max_filesize</literal> will not be kept in cache for either
              reads or writes.</para>
          </listitem>
        </itemizedlist>
        <para>This can be very useful for workloads where relatively small files are repeatedly
          accessed by many clients, such as job startup files, executables, log files, etc., but
          large files are read or written only once. By not putting the larger files into the cache,
          it is much more likely that more of the smaller files will remain in cache for a longer
          time.</para>
        <para>When setting <literal>readcache_max_filesize</literal>, the input value can be
          specified in bytes, or can have a suffix to indicate other binary units such as <emphasis
            role="bold">K</emphasis>ilobytes, <emphasis role="bold">M</emphasis>egabytes, <emphasis
            role="bold">G</emphasis>igabytes, <emphasis role="bold">T</emphasis>erabytes, or
            <emphasis role="bold">P</emphasis>etabytes.</para>
        <para>To limit the maximum cached file size to 32MB on all OSTs of an OSS, run:</para>
        <screen>root@oss1# lctl set_param obdfilter.*.readcache_max_filesize=32M</screen>
        <para>To disable the maximum cached file size on an OST, run:</para>
        <screen>root@oss1# lctl set_param obdfilter.{OST_name}.readcache_max_filesize=-1</screen>
        <para>To check the current maximum cached file size on all OSTs of an OSS, run:</para>
        <screen>root@oss1# lctl get_param obdfilter.*.readcache_max_filesize</screen>
      </section>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>OSS journal</secondary>
        </indexterm>OSS Asynchronous Journal Commit</title>
      <para>The OSS asynchronous journal commit feature synchronously writes data to disk without
        forcing a journal flush. This reduces the number of seeks and significantly improves
        performance on some hardware.</para>
      <note>
        <para>Asynchronous journal commit cannot work with O_DIRECT writes, a journal flush is still
          forced.</para>
      </note>
      <para>When asynchronous journal commit is enabled, client nodes keep data in the page cache (a
        page reference). Lustre clients monitor the last committed transaction number (transno) in
        messages sent from the OSS to the clients. When a client sees that the last committed
        transno reported by the OSS is at least the bulk write transno, it releases the reference on
        the corresponding pages. To avoid page references being held for too long on clients after a
        bulk write, a 7 second ping request is scheduled (jbd commit time is 5 seconds) after the
        bulk write reply is received, so the OSS has an opportunity to report the last committed
        transno.</para>
      <para>If the OSS crashes before the journal commit occurs, then the intermediate data is lost.
        However, new OSS recovery functionality (introduced in the asynchronous journal commit
        feature), causes clients to replay their write requests and compensate for the missing disk
        updates by restoring the state of the file system.</para>
      <para>To enable asynchronous journal commit, set the <literal>sync_journal parameter</literal>
        to zero (<literal>sync_journal=0</literal>):</para>
      <screen>$ lctl set_param obdfilter.*.sync_journal=0 
obdfilter.lol-OST0001.sync_journal=0</screen>
      <para>By default, <literal>sync_journal</literal> is disabled
          (<literal>sync_journal=1</literal>), which forces a journal flush after every bulk
        write.</para>
      <para>When asynchronous journal commit is used, clients keep a page reference until the
        journal transaction commits. This can cause problems when a client receives a blocking
        callback, because pages need to be removed from the page cache, but they cannot be removed
        because of the extra page reference.</para>
      <para>This problem is solved by forcing a journal flush on lock cancellation. When this
        happens, the client is granted the metadata blocks that have hit the disk, and it can safely
        release the page reference before processing the blocking callback. The parameter which
        controls this action is <literal>sync_on_lock_cancel</literal>, which can be set to the
        following values:</para>
      <itemizedlist>
        <listitem>
          <para><literal>always</literal>: Always force a journal flush on lock cancellation</para>
        </listitem>
        <listitem>
          <para><literal>blocking</literal>: Force a journal flush only when the local cancellation
            is due to a blocking callback</para>
        </listitem>
        <listitem>
          <para><literal>never</literal>: Do not force any journal flush</para>
        </listitem>
      </itemizedlist>
      <para>Here is an example of <literal>sync_on_lock_cancel</literal> being set not to force a
        journal flush:</para>
      <screen>$ lctl get_param obdfilter.*.sync_on_lock_cancel
obdfilter.lol-OST0001.sync_on_lock_cancel=never</screen>
      <para>By default, <literal>sync_on_lock_cancel</literal> is set to never, because asynchronous
        journal commit is disabled by default.</para>
      <para>When asynchronous journal commit is enabled (<literal>sync_journal=0</literal>),
          <literal>sync_on_lock_cancel</literal> is automatically set to always, if it was
        previously set to never.</para>
      <para>Similarly, when asynchronous journal commit is disabled,
          (<literal>sync_journal=1</literal>), <literal>sync_on_lock_cancel</literal> is enforced to
        never.</para>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>mballoc history</secondary>
        </indexterm><literal>mballoc</literal> History</title>
      <para><literal> /proc/fs/ldiskfs/sda/mb_history </literal></para>
      <para>Multi-Block-Allocate (<literal>mballoc</literal>), enables Lustre to ask
          <literal>ldiskfs</literal> to allocate multiple blocks with a single request to the block
        allocator. Typically, an <literal>ldiskfs</literal> file system allocates only one block per
        time. Each <literal>mballoc</literal>-enabled partition has this file. This is sample
        output:</para>
      <screen>pid  inode  goal       result      found grps cr   merge tail broken
2838 139267 17/12288/1 17/12288/1  1     0    0    M     1    8192
2838 139267 17/12289/1 17/12289/1  1     0    0    M     0    0
2838 139267 17/12290/1 17/12290/1  1     0    0    M     1    2
2838 24577  3/12288/1  3/12288/1   1     0    0    M     1    8192
2838 24578  3/12288/1  3/771/1     1     1    1          0    0
2838 32769  4/12288/1  4/12288/1   1     0    0    M     1    8192
2838 32770  4/12288/1  4/12289/1   13    1    1          0    0
2838 32771  4/12288/1  5/771/1     26    2    1          0    0
2838 32772  4/12288/1  5/896/1     31    2    1          1    128
2838 32773  4/12288/1  5/897/1     31    2    1          0    0
2828 32774  4/12288/1  5/898/1     31    2    1          1    2
2838 32775  4/12288/1  5/899/1     31    2    1          0    0
2838 32776  4/12288/1  5/900/1     31    2    1          1    4
2838 32777  4/12288/1  5/901/1     31    2    1          0    0
2838 32778  4/12288/1  5/902/1     31    2    1          1    2</screen>
      <para>The parameters are described below:</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Parameter</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">
                    <literal>pid</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Process that made the allocation.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">
                    <literal>inode</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>inode number allocated blocks</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">
                    <literal>goal</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Initial request that came to <literal>mballoc</literal>
                  (group/block-in-group/number-of-blocks)</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">
                    <literal>result</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>What <literal>mballoc</literal> actually found for this request.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">
                    <literal>found</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Number of free chunks <literal>mballoc</literal> found and measured before the
                  final decision.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">
                    <literal>grps</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Number of groups <literal>mballoc</literal> scanned to satisfy the
                  request.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">
                    <literal>cr</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Stage at which <literal>mballoc</literal> found the result:</para>
                <para><emphasis role="bold">0</emphasis> - best in terms of resource allocation. The
                  request was 1MB or larger and was satisfied directly via the kernel buddy
                  allocator.</para>
                <para><emphasis role="bold">1</emphasis> - regular stage (good at resource
                  consumption)</para>
                <para><emphasis role="bold">2</emphasis> - fs is quite fragmented (not that bad at
                  resource consumption)</para>
                <para><emphasis role="bold">3</emphasis> - fs is very fragmented (worst at resource
                  consumption)</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">
                    <literal>queue</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Total bytes in active/queued sends.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">
                    <literal>merge</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Whether the request hit the goal. This is good as extents code can now merge
                  new blocks to existing extent, eliminating the need for extents tree
                  growth.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">
                    <literal>tail</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Number of blocks left free after the allocation breaks large free
                  chunks.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">
                    <literal>broken</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>How large the broken chunk was.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Most users are probably interested in found/cr. If cr is 0 1 and found is less than 100,
        then <literal>mballoc</literal> is doing quite well.</para>
      <para>Also, number-of-blocks-in-request (third number in the goal triple) can tell the number
        of blocks requested by the <literal>obdfilter</literal>. If the <literal>obdfilter</literal>
        is doing a lot of small requests (just few blocks), then either the client is processing
        input/output to a lot of small files, or something may be wrong with the client (because it
        is better if client sends large input/output requests). This can be investigated with the
        OSC <literal>rpc_stats</literal> or OST <literal>brw_stats</literal> mentioned above.</para>
      <para>Number of groups scanned (<literal>grps</literal> column) should be small. If it reaches
        a few dozen often, then either your disk file system is pretty fragmented or
          <literal>mballoc</literal> is doing something wrong in the group selection part.</para>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>mballoc tunables</secondary>
        </indexterm><literal>mballoc</literal> Tunables</title>
      <para>Lustre ldiskfs includes a multi-block allocation for ldiskfs to improve the efficiency
        of space allocation in the OST storage. Multi-block allocation adds the following
        features:</para>
      <itemizedlist>
        <listitem>
          <para> Pre-allocation for single files (helps to resist fragmentation)</para>
        </listitem>
        <listitem>
          <para> Pre-allocation for a group of files (helps to pack small files into large,
            contiguous chunks)</para>
        </listitem>
        <listitem>
          <para> Stream allocation (helps to decrease the seek rate)</para>
        </listitem>
      </itemizedlist>
      <para>The following <literal>mballoc</literal> tunables are available:</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Field</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <literal>mb_max_to_scan</literal></para>
              </entry>
              <entry>
                <para>Maximum number of free chunks that <literal>mballoc</literal> finds before a
                  final decision to avoid livelock.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>mb_min_to_scan</literal></para>
              </entry>
              <entry>
                <para>Minimum number of free chunks that <literal>mballoc</literal> searches before
                  picking the best chunk for allocation. This is useful for a very small request, to
                  resist fragmentation of big free chunks.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>mb_order2_req</literal></para>
              </entry>
              <entry>
                <para>For requests equal to 2^N (where N &gt;= <literal>order2_req</literal>), a
                  very fast search via buddy structures is used.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>mb_small_req</literal></para>
              </entry>
              <entry morerows="1">
                <para>All requests are divided into 3 categories:</para>
                <para>&lt; small_req (packed together to form large, aggregated requests)</para>
                <para>&lt; large_req (allocated mostly in linearly)</para>
                <para>&gt; large_req (very large requests so the arm seek does not matter)</para>
                <para>The idea is that we try to pack small requests to form large requests, and
                  then place all large requests (including compound from the small ones) close to
                  one another, causing as few arm seeks as possible.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>mb_large_req</literal></para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>mb_prealloc_table</literal></para>
              </entry>
              <entry>
                <para>The amount of space to preallocate depends on the current file size. The idea
                  is that for small files we do not need 1 MB preallocations and for large files, 1
                  MB preallocations are not large enough; it is better to preallocate 4 MB.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal>mb_group_prealloc</literal></para>
              </entry>
              <entry>
                <para>The amount of space (in kilobytes) preallocated for groups of small
                  requests.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section remap="h3">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>locking</secondary>
        </indexterm>Locking</title>
      <para><literal> ldlm.namespaces.<replaceable>osc_name|mdc_name</replaceable>.lru_size
        </literal></para>
      <para>The <literal>lru_size</literal> parameter is used to control the number of client-side
        locks in an LRU queue. LRU size is dynamic, based on load. This optimizes the number of
        locks available to nodes that have different workloads (e.g., login/build nodes vs. compute
        nodes vs. backup nodes).</para>
      <para>The total number of locks available is a function of the server&apos;s RAM. The default
        limit is 50 locks/1 MB of RAM. If there is too much memory pressure, then the LRU size is
        shrunk. The number of locks on the server is limited to
          <replaceable>targets_on_server</replaceable> * <replaceable>client_count</replaceable> *
          <replaceable>client_lru_size</replaceable>.</para>
      <itemizedlist>
        <listitem>
          <para>To enable automatic LRU sizing, set the <literal>lru_size</literal> parameter to 0.
            In this case, the <literal>lru_size</literal> parameter shows the current number of
            locks being used on the export. LRU sizing is enabled by default starting with Lustre
            1.6.5.1.</para>
        </listitem>
        <listitem>
          <para>To specify a maximum number of locks, set the lru_size parameter to a value other
            than 0 (former numbers are okay, 100 * <replaceable>core_count</replaceable>). We
            recommend that you only increase the LRU size on a few login nodes where users access
            the file system interactively.</para>
        </listitem>
      </itemizedlist>
      <para>To clear the LRU on a single client, and as a result flush client cache, without
        changing the <literal>lru_size</literal> value:</para>
      <screen>$ lctl set_param ldlm.namespaces.<replaceable>osc_name|mdc_name</replaceable>.lru_size=clear</screen>
      <para>If you shrink the LRU size below the number of existing unused locks, then the unused
        locks are canceled immediately. Use echo clear to cancel all locks without changing the
        value.</para>
      <note>
        <para>Currently, the lru_size parameter can only be set temporarily with <literal>lctl
            set_param</literal>; it cannot be set permanently.</para>
      </note>
      <para>To disable LRU sizing, run this command on the Lustre clients:</para>
      <screen>$ lctl set_param ldlm.namespaces.*osc*.lru_size=$((NR_CPU*100))</screen>
      <para>Replace <literal>NR_CPU</literal> value with the number of CPUs on the node.</para>
      <para>To determine the number of locks being granted:</para>
      <screen>$ lctl get_param ldlm.namespaces.*.pool.limit</screen>
    </section>
    <section xml:id="dbdoclet.50438271_87260">
      <title><indexterm>
          <primary>proc</primary>
          <secondary>thread counts</secondary>
        </indexterm>Setting MDS and OSS Thread Counts</title>
      <para>MDS and OSS thread counts (minimum and maximum) can be set via the
          <literal>{min,max}_thread_count tunable</literal>. For each service, a new
          <literal>/proc/fs/lustre/{service}/*/thread_{min,max,started}</literal> entry is created.
        The tunable, <literal>{service}.thread_{min,max,started}</literal>, can be used to set the
        minimum and maximum thread counts or get the current number of running threads for the
        following services.</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <tbody>
            <row>
              <entry>
                <para>
                  <emphasis role="bold">Service</emphasis></para>
              </entry>
              <entry>
                <para>
                  <emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
            <row>
              <entry>
                <literal> mdt.MDS.mds </literal>
              </entry>
              <entry>
                <para>normal metadata ops</para>
              </entry>
            </row>
            <row>
              <entry>
                <literal> mdt.MDS.mds_readpage </literal>
              </entry>
              <entry>
                <para>metadata readdir</para>
              </entry>
            </row>
            <row>
              <entry>
                <literal> mdt.MDS.mds_setattr </literal>
              </entry>
              <entry>
                <para>metadata setattr</para>
              </entry>
            </row>
            <row>
              <entry>
                <literal> ost.OSS.ost </literal>
              </entry>
              <entry>
                <para>normal data</para>
              </entry>
            </row>
            <row>
              <entry>
                <literal> ost.OSS.ost_io </literal>
              </entry>
              <entry>
                <para>bulk data IO</para>
              </entry>
            </row>
            <row>
              <entry>
                <literal> ost.OSS.ost_create </literal>
              </entry>
              <entry>
                <para>OST object pre-creation service</para>
              </entry>
            </row>
            <row>
              <entry>
                <literal> ldlm.services.ldlm_canceld </literal>
              </entry>
              <entry>
                <para>DLM lock cancel</para>
              </entry>
            </row>
            <row>
              <entry>
                <literal> ldlm.services.ldlm_cbd </literal>
              </entry>
              <entry>
                <para>DLM lock grant</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <itemizedlist>
        <listitem>
          <para>To temporarily set this tunable, run:</para>
          <screen># lctl {get,set}_param {service}.thread_{min,max,started} </screen>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>To permanently set this tunable, run:</para>
          <screen># lctl conf_param {service}.thread_{min,max,started} </screen>
          <para>The following examples show how to set thread counts and get the number of running
            threads for the ost_io service.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>To get the number of running threads, run:</para>
          <screen># lctl get_param ost.OSS.ost_io.threads_started</screen>
          <para>The command output will be similar to this:</para>
          <screen>ost.OSS.ost_io.threads_started=128</screen>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>To set the maximum number of threads (512), run:</para>
          <screen># lctl get_param ost.OSS.ost_io.threads_max</screen>
          <para>The command output will be:</para>
          <screen>ost.OSS.ost_io.threads_max=512</screen>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para> To set the maximum thread count to 256 instead of 512 (to avoid overloading the
            storage or for an array with requests), run:</para>
          <screen># lctl set_param ost.OSS.ost_io.threads_max=256</screen>
          <para>The command output will be:</para>
          <screen>ost.OSS.ost_io.threads_max=256</screen>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para> To check if the new <literal>threads_max</literal> setting is active, run:</para>
          <screen># lctl get_param ost.OSS.ost_io.threads_max</screen>
          <para>The command output will be similar to this:</para>
          <screen>ost.OSS.ost_io.threads_max=256</screen>
        </listitem>
      </itemizedlist>
      <note>
        <para>Currently, the maximum thread count setting is advisory because Lustre does not reduce
          the number of service threads in use, even if that number exceeds the
            <literal>threads_max</literal> value. Lustre does not stop service threads once they are
          started.</para>
      </note>
    </section>
  </section>
  <section xml:id="dbdoclet.50438271_83523">
    <title><indexterm>
        <primary>proc</primary>
        <secondary>debug</secondary>
      </indexterm>Debug</title>
    <para><literal> /proc/sys/lnet/debug </literal></para>
    <para>By default, Lustre generates a detailed log of all operations to aid in debugging. The
      level of debugging can affect the performance or speed you achieve with Lustre. Therefore, it
      is useful to reduce this overhead by turning down the debug level<footnote>
        <para>This controls the level of Lustre debugging kept in the internal log buffer. It does
          not alter the level of debugging that goes to syslog.</para>
      </footnote> to improve performance. Raise the debug level when you need to collect the logs
      for debugging problems. The debugging mask can be set with &quot;symbolic names&quot; instead
      of the numerical values that were used in prior releases. The new symbolic format is shown in
      the examples below.</para>
    <note>
      <para>All of the commands below must be run as root; note the <literal>#</literal>
        nomenclature.</para>
    </note>
    <para>To verify the debug level used by examining the <literal>sysctl</literal> that controls
      debugging, run:</para>
    <screen># sysctl lnet.debug 
lnet.debug = ioctl neterror warning error emerg ha config console</screen>
    <para>To turn off debugging (except for network error debugging), run this command on all
      concerned nodes:</para>
    <screen># sysctl -w lnet.debug=&quot;neterror&quot; 
lnet.debug = neterror</screen>
    <para>To turn off debugging completely, run this command on all concerned nodes:</para>
    <screen># sysctl -w lnet.debug=0 
lnet.debug = 0</screen>
    <para>To set an appropriate debug level for a production environment, run:</para>
    <screen># sysctl -w lnet.debug=&quot;warning dlmtrace error emerg ha rpctrace vfstrace&quot; 
lnet.debug = warning dlmtrace error emerg ha rpctrace vfstrace</screen>
    <para>The flags above collect enough high-level information to aid debugging, but they do not
      cause any serious performance impact.</para>
    <para>To clear all flags and set new ones, run:</para>
    <screen># sysctl -w lnet.debug=&quot;warning&quot; 
lnet.debug = warning</screen>
    <para>To add new flags to existing ones, prefix them with a
      &quot;<literal>+</literal>&quot;:</para>
    <screen># sysctl -w lnet.debug=&quot;+neterror +ha&quot; 
lnet.debug = +neterror +ha
# sysctl lnet.debug 
lnet.debug = neterror warning ha</screen>
    <para>To remove flags, prefix them with a &quot;<literal>-</literal>&quot;:</para>
    <screen># sysctl -w lnet.debug=&quot;-ha&quot; 
lnet.debug = -ha
# sysctl lnet.debug 
lnet.debug = neterror warning</screen>
    <para>You can verify and change the debug level using the <literal>/proc</literal> interface in
      Lustre. To use the flags with <literal>/proc</literal>, run:</para>
    <screen># lctl get_param debug
debug=
neterror warning
# lctl set_param debug=+ha
# lctl get_param debug
debug=
neterror warning ha
# lctl set_param debug=-warning
# lctl get_param debug
debug=
neterror ha</screen>
    <para><literal> /proc/sys/lnet/subsystem_debug </literal></para>
    <para>This controls the debug logs for subsystems (see <literal>S_*</literal>
      definitions).</para>
    <para><literal> /proc/sys/lnet/debug_path </literal></para>
    <para>This indicates the location where debugging symbols should be stored for
        <literal>gdb</literal>. The default is set to
        <literal>/r/tmp/lustre-log-localhost.localdomain</literal>.</para>
    <para>These values can also be set via <literal>sysctl -w lnet.debug={value}</literal></para>
    <note>
      <para>The above entries only exist when Lustre has already been loaded.</para>
    </note>
    <para><literal> /proc/sys/lnet/panic_on_lbug </literal></para>
    <para>This causes Lustre to call &apos;&apos;panic&apos;&apos; when it detects an internal
      problem (an <literal>LBUG</literal>); panic crashes the node. This is particularly useful when
      a kernel crash dump utility is configured. The crash dump is triggered when the internal
      inconsistency is detected by Lustre.</para>
    <para><literal> /proc/sys/lnet/upcall </literal></para>
    <para>This allows you to specify the path to the binary which will be invoked when an
        <literal>LBUG</literal> is encountered. This binary is called with four parameters. The
      first one is the string &apos;&apos;<literal>LBUG</literal>&apos;&apos;. The second one is the
      file where the <literal>LBUG</literal> occurred. The third one is the function name. The
      fourth one is the line number in the file.</para>
    <section remap="h3">
      <title>RPC Information for Other OBD Devices</title>
      <para>Some OBD devices maintain a count of the number of RPC events that they process.
        Sometimes these events are more specific to operations of the device, like llite, than
        actual raw RPC counts.</para>
      <screen>$ find /proc/fs/lustre/ -name stats
/proc/fs/lustre/osc/lustre-OST0001-osc-ce63ca00/stats
/proc/fs/lustre/osc/lustre-OST0000-osc-ce63ca00/stats
/proc/fs/lustre/osc/lustre-OST0001-osc/stats
/proc/fs/lustre/osc/lustre-OST0000-osc/stats
/proc/fs/lustre/mdt/MDS/mds_readpage/stats
/proc/fs/lustre/mdt/MDS/mds_setattr/stats
/proc/fs/lustre/mdt/MDS/mds/stats
/proc/fs/lustre/mds/lustre-MDT0000/exports/
       ab206805-0630-6647-8543-d24265c91a3d/stats
/proc/fs/lustre/mds/lustre-MDT0000/exports/
       08ac6584-6c4a-3536-2c6d-b36cf9cbdaa0/stats
/proc/fs/lustre/mds/lustre-MDT0000/stats
/proc/fs/lustre/ldlm/services/ldlm_canceld/stats
/proc/fs/lustre/ldlm/services/ldlm_cbd/stats
/proc/fs/lustre/llite/lustre-ce63ca00/stats
</screen>
      <section remap="h4">
        <title><indexterm>
            <primary>proc</primary>
            <secondary>statistics</secondary>
          </indexterm>Interpreting OST Statistics</title>
        <note>
          <para>See also <xref linkend="dbdoclet.50438219_84890"/> (<literal>llobdstat</literal>)
            and <xref linkend="dbdoclet.50438273_80593"/> (<literal>collectl</literal>).</para>
        </note>
        <para>The OST <literal>.../stats</literal> files can be used to track client statistics
          (client activity) for each OST. It is possible to get a periodic dump of values from these
          file (for example, every 10 seconds), that show the RPC rates (similar to
            <literal>iostat</literal>) by using the <literal>llstat</literal> tool:</para>
        <screen># llstat /proc/fs/lustre/osc/lustre-OST0000-osc/stats 
/usr/bin/llstat: STATS on 09/14/07 
       /proc/fs/lustre/osc/lustre-OST0000-osc/ stats on 192.168.10.34@tcp                             
snapshot_time                      1189732762.835363
ost_create                 1
ost_get_info               1
ost_connect                1
ost_set_info               1
obd_ping                   212</screen>
        <para>To clear the statistics, give the <literal>-c</literal> option to
            <literal>llstat</literal>. To specify how frequently the statistics should be cleared
          (in seconds), use an integer for the <literal>-i</literal> option. This is sample output
          with <literal>-c</literal> and <literal>-i10</literal> options used, providing statistics
          every 10s):</para>
        <screen role="smaller">$ llstat -c -i10 /proc/fs/lustre/ost/OSS/ost_io/stats
 
/usr/bin/llstat: STATS on 06/06/07 
        /proc/fs/lustre/ost/OSS/ost_io/ stats on 192.168.16.35@tcp
snapshot_time                              1181074093.276072
 
/proc/fs/lustre/ost/OSS/ost_io/stats @ 1181074103.284895
Name         Cur.  Cur. #
             Count Rate Events Unit   last   min    avg       max    stddev
req_waittime 8     0    8     [usec]  2078   34     259.75    868    317.49
req_qdepth   8     0    8     [reqs]  1      0      0.12      1      0.35
req_active   8     0    8     [reqs]  11     1      1.38      2      0.52
reqbuf_avail 8     0    8     [bufs]  511    63     63.88     64     0.35
ost_write    8     0    8     [bytes] 169767 72914  212209.62 387579 91874.29
 
/proc/fs/lustre/ost/OSS/ost_io/stats @ 1181074113.290180
Name         Cur.  Cur. #
             Count Rate Events Unit   last    min   avg       max    stddev
req_waittime 31    3    39    [usec]  30011   34    822.79    12245  2047.71
req_qdepth   31    3    39    [reqs]  0       0     0.03      1      0.16
req_active   31    3    39    [reqs]  58      1     1.77      3      0.74
reqbuf_avail 31    3    39    [bufs]  1977    63    63.79     64     0.41
ost_write    30    3    38    [bytes] 1028467 15019 315325.16 910694 197776.51
 
/proc/fs/lustre/ost/OSS/ost_io/stats @ 1181074123.325560
Name         Cur.  Cur. #
             Count Rate Events Unit   last    min    avg       max    stddev
req_waittime 21    2    60    [usec]  14970   34     784.32    12245  1878.66
req_qdepth   21    2    60    [reqs]  0       0      0.02      1      0.13
req_active   21    2    60    [reqs]  33      1      1.70      3      0.70
reqbuf_avail 21    2    60    [bufs]  1341    63     63.82     64     0.39
ost_write    21    2    59    [bytes] 7648424 15019  332725.08 910694 180397.87
</screen>
        <para>Where:</para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50*"/>
            <colspec colname="c2" colwidth="50*"/>
            <thead>
              <row>
                <entry>
                  <para><emphasis role="bold">Parameter</emphasis></para>
                </entry>
                <entry>
                  <para><emphasis role="bold">Description</emphasis></para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>
                    <literal> Cur. Count </literal></para>
                </entry>
                <entry>
                  <para>Number of events of each type sent in the last interval (in this example,
                    10s)</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> Cur. Rate </literal></para>
                </entry>
                <entry>
                  <para>Number of events per second in the last interval</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> #Events </literal></para>
                </entry>
                <entry>
                  <para>Total number of such events since the system started</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> Unit </literal></para>
                </entry>
                <entry>
                  <para>Unit of measurement for that statistic (microseconds, requests,
                    buffers)</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> last </literal></para>
                </entry>
                <entry>
                  <para>Average rate of these events (in units/event) for the last interval during
                    which they arrived. For instance, in the above mentioned case of
                      <literal>ost_destroy</literal> it took an average of 736 microseconds per
                    destroy for the 400 object destroys in the previous 10 seconds.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> min </literal></para>
                </entry>
                <entry>
                  <para>Minimum rate (in units/events) since the service started</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> avg </literal></para>
                </entry>
                <entry>
                  <para>Average rate</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> max </literal></para>
                </entry>
                <entry>
                  <para>Maximum rate</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> stddev </literal></para>
                </entry>
                <entry>
                  <para>Standard deviation (not measured in all cases)</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>The events common to all services are:</para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50*"/>
            <colspec colname="c2" colwidth="50*"/>
            <thead>
              <row>
                <entry>
                  <para><emphasis role="bold">Parameter</emphasis></para>
                </entry>
                <entry>
                  <para><emphasis role="bold">Description</emphasis></para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>
                    <literal> req_waittime </literal></para>
                </entry>
                <entry>
                  <para>Amount of time a request waited in the queue before being handled by an
                    available server thread.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> req_qdepth </literal></para>
                </entry>
                <entry>
                  <para>Number of requests waiting to be handled in the queue for this
                    service.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> req_active </literal></para>
                </entry>
                <entry>
                  <para>Number of requests currently being handled.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> reqbuf_avail </literal></para>
                </entry>
                <entry>
                  <para>Number of unsolicited lnet request buffers for this service.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>Some service-specific events of interest are:</para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50*"/>
            <colspec colname="c2" colwidth="50*"/>
            <thead>
              <row>
                <entry>
                  <para><emphasis role="bold">Parameter</emphasis></para>
                </entry>
                <entry>
                  <para><emphasis role="bold">Description</emphasis></para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>
                    <literal> ldlm_enqueue </literal></para>
                </entry>
                <entry>
                  <para>Time it takes to enqueue a lock (this includes file open on the MDS)</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal> mds_reint </literal></para>
                </entry>
                <entry>
                  <para>Time it takes to process an MDS modification record (includes create,
                      <literal>mkdir</literal>, <literal>unlink</literal>, <literal>rename</literal>
                    and <literal>setattr</literal>)</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
      <section remap="h4">
        <title><indexterm>
            <primary>proc</primary>
            <secondary>statistics</secondary>
          </indexterm>Interpreting MDT Statistics</title>
        <note>
          <para>See also <xref linkend="dbdoclet.50438219_84890"/> (llobdstat) and <xref
              linkend="dbdoclet.50438273_80593"/> (CollectL).</para>
        </note>
        <para>The MDT .../stats files can be used to track MDT statistics for the MDS. Here is
          sample output for an MDT stats file:</para>
        <screen># cat /proc/fs/lustre/mds/*-MDT0000/stats 
snapshot_time                   1244832003.676892 secs.usecs 
open                            2 samples [reqs] 
close                           1 samples [reqs] 
getxattr                        3 samples [reqs] 
process_config                  1 samples [reqs] 
connect                         2 samples [reqs] 
disconnect                      2 samples [reqs] 
statfs                          3 samples [reqs] 
setattr                         1 samples [reqs] 
getattr                         3 samples [reqs] 
llog_init                       6 samples [reqs] 
notify                          16 samples [reqs]</screen>
      </section>
    </section>
  </section>
</chapter>
