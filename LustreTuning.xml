<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><chapter xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en-US" xml:id="lustretuning">
  <title xml:id="lustretuning.title">Lustre Tuning</title>
  <para>This chapter contains information about tuning Lustre for better performance and includes the following sections:</para>
  <itemizedlist>
    <listitem>
      <para><xref linkend="dbdoclet.50438272_55226"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438272_73839"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438272_25884"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438272_80545"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438272_45406"/></para>
    </listitem>
  </itemizedlist>
  <note>
    <para>Many options in Lustre are set by means of kernel module parameters. These parameters are contained in the <literal>modprobe.conf</literal> file.</para>
  </note>
  <section xml:id="dbdoclet.50438272_55226">
      <title>
          <indexterm><primary>tuning</primary></indexterm>
<indexterm><primary>tuning</primary><secondary>service threads</secondary></indexterm>
          Optimizing the Number of Service Threads</title>
    <para>An OSS can have a minimum of 2 service threads and a maximum of 512 service threads. The number of service threads is a function of how much RAM and how many CPUs are on each OSS node (1 thread / 128MB * num_cpus). If the load on the OSS node is high, new service threads will be started in order to process more requests concurrently, up to 4x the initial number of threads (subject to the maximum of 512). For a 2GB 2-CPU system, the default thread count is 32 and the maximum thread count is 128.</para>
    <para>Increasing the size of the thread pool may help when:</para>
    <itemizedlist>
      <listitem>
        <para>Several OSTs are exported from a single OSS</para>
      </listitem>
      <listitem>
        <para>Back-end storage is running synchronously</para>
      </listitem>
      <listitem>
        <para>I/O completions take excessive time due to slow storage</para>
      </listitem>
    </itemizedlist>
    <para>Decreasing the size of the thread pool may help if:</para>
    <itemizedlist>
      <listitem>
        <para>Clients are overwhelming the storage capacity</para>
      </listitem>
      <listitem>
        <para>There are lots of &quot;slow I/O&quot; or similar messages</para>
      </listitem>
    </itemizedlist>
    <para>Increasing the number of I/O threads allows the kernel and storage to aggregate many writes together for more efficient disk I/O. The OSS thread pool is shared--each thread allocates approximately 1.5 MB (maximum RPC size + 0.5 MB) for internal I/O buffers.</para>
    <para>It is very important to consider memory consumption when increasing the thread pool size. Drives are only able to sustain a certain amount of parallel I/O activity before performance is degraded, due to the high number of seeks and the OST threads just waiting for I/O. In this situation, it may be advisable to decrease the load by decreasing the number of OST threads.</para>
    <para>Determining the optimum number of OST threads is a process of trial and error, and varies for each particular configuration. Variables include the number of OSTs on each OSS, number and speed of disks, RAID configuration, and available RAM. You may want to start with a number of OST threads equal to the number of actual disk spindles on the node. If you use RAID, subtract any dead spindles not used for actual data (e.g., 1 of N of spindles for RAID5, 2 of N spindles for RAID6), and monitor the performance of clients during usual workloads. If performance is degraded, increase the thread count and see how that works until performance is degraded again or you reach satisfactory performance.</para>
    <note>
      <para>If there are too many threads, the latency for individual I/O requests can become very high and should be avoided. Set the desired maximum thread count permanently using the method described above.</para>
    </note>
    <section remap="h3">
      <title><indexterm><primary>tuning</primary><secondary>OSS threads</secondary></indexterm>Specifying the OSS Service Thread Count</title>
      <para>The <literal>oss_num_threads</literal> parameter enables the number of OST service threads to be specified at module load time on the OSS nodes:</para>
      <screen>options ost oss_num_threads={N}</screen>
      <para>After startup, the minimum and maximum number of OSS thread counts can be set via the <literal>{service}.thread_{min,max,started}</literal> tunable. To change the tunable at runtime, run:</para>
      <para><screen>lctl {get,set}_param {service}.thread_{min,max,started}</screen></para>
      <para>For details, see <xref linkend="dbdoclet.50438271_87260"/>.</para>
    </section>
    <section remap="h3">
      <title><indexterm><primary>tuning</primary><secondary>MDS threads</secondary></indexterm>Specifying the MDS Service Thread Count</title>
      <para>The <literal>mds_num_threads</literal> parameter enables the number of MDS service threads to be specified at module load time on the MDS node:</para>
      <screen>options mds mds_num_threads={N}</screen>
      <para>After startup, the minimum and maximum number of MDS thread counts can be set via the <literal>{service}.thread_{min,max,started}</literal> tunable. To change the tunable at runtime, run:</para>
      <para><screen>lctl {get,set}_param {service}.thread_{min,max,started}</screen></para>
      <para>For details, see <xref linkend="dbdoclet.50438271_87260"/>.</para>
      <para>At this time, no testing has been done to determine the optimal number of MDS threads. The default value varies, based on server size, up to a maximum of 32. The maximum number of threads (<literal>MDS_MAX_THREADS</literal>) is 512.</para>
      <note>
        <para>The OSS and MDS automatically start new service threads dynamically, in response to server load within a factor of 4. The default value is calculated the same way as before. Setting the <literal>_mu_threads</literal> module parameter disables automatic thread creation behavior.</para>
      </note>
    </section>
  </section>
  <section xml:id="dbdoclet.50438272_73839">
      <title>
          <indexterm><primary>LNET</primary><secondary>tuning</secondary>
      </indexterm><indexterm><primary>tuning</primary><secondary>LNET</secondary></indexterm>
      Tuning LNET Parameters</title>
    <para>This section describes LNET tunables. that may be necessary on some systems to improve performance. To test the performance of your Lustre network, see <link xl:href="LNETSelfTest.html#50438223_71556">Chapter 23</link>: <link xl:href="LNETSelfTest.html#50438223_21832">Testing Lustre Network Performance (LNET Self-Test)</link>.</para>
    <section remap="h3">
      <title>Transmit and Receive Buffer Size</title>
      <para>The kernel allocates buffers for sending and receiving messages on a network.</para>
      <para><literal>ksocklnd</literal> has separate parameters for the transmit and receive buffers.</para>
      <screen>options ksocklnd tx_buffer_size=0 rx_buffer_size=0
</screen>
      <para>If these parameters are left at the default value (0), the system automatically tunes the transmit and receive buffer size. In almost every case, this default produces the best performance. Do not attempt to tune these parameters unless you are a network expert.</para>
    </section>
    <section remap="h3">
      <title>Hardware Interrupts (<literal>enable_irq_affinity</literal>)</title>
      <para>The hardware interrupts that are generated by network adapters may be handled by any CPU in the system. In some cases, we would like network traffic to remain local to a single CPU to help keep the processor cache warm and minimize the impact of context switches. This is helpful when an SMP system has more than one network interface and ideal when the number of interfaces equals the number of CPUs. To enable the <literal>enable_irq_affinity</literal> parameter, enter:</para>
      <screen>options ksocklnd enable_irq_affinity=1</screen>
      <para>In other cases, if you have an SMP platform with a single fast interface such as 10Gb Ethernet and more than two CPUs, you may see performance improve by turning this parameter off.</para>
      <screen>options ksocklnd enable_irq_affinity=0</screen>
      <para>By default, this parameter is off. As always, you should test the performance to compare the impact of changing this parameter.</para>
    </section>
  </section>
  <section xml:id="dbdoclet.50438272_25884">
      <title><indexterm><primary>tuning</primary><secondary>lockless I/O</secondary></indexterm>Lockless I/O Tunables</title>
    <para>The lockless I/O tunable feature allows servers to ask clients to do lockless I/O (liblustre-style where the server does the locking) on contended files.</para>
    <para>The lockless I/O patch introduces these tunables:</para>
    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">OST-side:</emphasis></para>
        <screen>/proc/fs/lustre/ldlm/namespaces/filter-lustre-*
</screen>
        <para><literal>contended_locks</literal> - If the number of lock conflicts in the scan of granted and waiting queues at contended_locks is exceeded, the resource is considered to be contended.</para>
        <para><literal>contention_seconds</literal> - The resource keeps itself in a contended state as set in the parameter.</para>
        <para><literal>max_nolock_bytes</literal> - Server-side locking set only for requests less than the blocks set in the <literal>max_nolock_bytes</literal> parameter. If this tunable is set to zero (0), it disables server-side locking for read/write requests.</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Client-side:</emphasis></para>
        <screen>/proc/fs/lustre/llite/lustre-*</screen>
        <para><literal>contention_seconds</literal> - <literal>llite</literal> inode remembers its contended state for the time specified in this parameter.</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Client-side statistics:</emphasis></para>
        <para>The <literal>/proc/fs/lustre/llite/lustre-*/stats</literal> file has new rows for lockless I/O statistics.</para>
        <para><literal>lockless_read_bytes</literal> and <literal>lockless_write_bytes</literal> - To count the total bytes read or written, the client makes its own decisions based on the request size. The client does not communicate with the server if the request size is smaller than the <literal>min_nolock_size</literal>, without acquiring locks by the client.</para>
      </listitem>
    </itemizedlist>
  </section>
  <section xml:id="dbdoclet.50438272_80545">
    <title><indexterm><primary>tuning</primary><secondary>for small files</secondary></indexterm>Improving Lustre Performance When Working with Small Files</title>
    <para>A Lustre environment where an application writes small file chunks from many clients to a single file will result in bad I/O performance. To improve Lustre&apos;â„¢s performance with small files:</para>
    <itemizedlist>
      <listitem>
        <para>Have the application aggregate writes some amount before submitting them to Lustre. By default, Lustre enforces POSIX coherency semantics, so it results in lock ping-pong between client nodes if they are all writing to the same file at one time.</para>
      </listitem>
      <listitem>
        <para>Have the application do 4kB <literal>O_DIRECT</literal> sized I/O to the file and disable locking on the output file. This avoids partial-page IO submissions and, by disabling locking, you avoid contention between clients.</para>
      </listitem>
      <listitem>
        <para>Have the application write contiguous data.</para>
      </listitem>
      <listitem>
        <para>Add more disks or use SSD disks for the OSTs. This dramatically improves the IOPS rate. Consider creating larger OSTs rather than many smaller OSTs due to less overhead (journal, connections, etc).</para>
      </listitem>
      <listitem>
        <para>Use RAID-1+0 OSTs instead of RAID-5/6. There is RAID parity overhead for writing small chunks of data to disk.</para>
      </listitem>
    </itemizedlist>
  </section>
  <section xml:id="dbdoclet.50438272_45406">
    <title><indexterm><primary>tuning</primary><secondary>write performance</secondary></indexterm>Understanding Why Write Performance is Better Than Read Performance</title>
    <para>Typically, the performance of write operations on a Lustre cluster is better than read operations. When doing writes, all clients are sending write RPCs asynchronously. The RPCs are allocated, and written to disk in the order they arrive. In many cases, this allows the back-end storage to aggregate writes efficiently.</para>
    <para>In the case of read operations, the reads from clients may come in a different order and need a lot of seeking to get read from the disk. This noticeably hampers the read throughput.</para>
    <para>Currently, there is no readahead on the OSTs themselves, though the clients do readahead. If there are lots of clients doing reads it would not be possible to do any readahead in any case because of memory consumption (consider that even a single RPC (1 MB) readahead for 1000 clients would consume 1 GB of RAM).</para>
    <para>For file systems that use socklnd (TCP, Ethernet) as interconnect, there is also additional CPU overhead because the client cannot receive data without copying it from the network buffers. In the write case, the client CAN send data without the additional data copy. This means that the client is more likely to become CPU-bound during reads than writes.</para>
  </section>
</chapter>
