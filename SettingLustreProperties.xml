<?xml version='1.0' encoding='UTF-8'?><chapter xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en-US" xml:id="settinglustreproperties">
  <title xml:id="settinglustreproperties.title">Setting Lustre Properties in a C Program (<literal>llapi</literal>)</title>
  <para>This chapter describes the <literal>llapi</literal> library of commands used for setting Lustre file properties within a C program running in a cluster environment, such as a data processing or MPI application. The commands described in this chapter are:</para>
  <itemizedlist>
    <listitem>
      <para><xref linkend="dbdoclet.50438215_30970"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438215_50149"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438215_86607"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438215_12433"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438215_15718"/></para>
    </listitem>
  </itemizedlist>
  <note>
    <para>Lustre programming interface man pages are found in the <literal>lustre/doc</literal> folder.</para>
  </note>
  <section xml:id="dbdoclet.50438215_30970">
    <title>
      <literal>llapi_file_create</literal>
    </title>
    <para>Use <literal>llapi_file_create</literal> to set Lustre properties for a new file.</para>
    <section remap="h5">
      <title>Synopsis</title>
      <screen>#include &lt;lustre/lustreapi.h&gt;

int llapi_file_create(char *name, long stripe_size, int stripe_offset, int stripe_count, int stripe_pattern);
</screen>
    </section>
    <section remap="h5">
      <title>Description</title>
      <para>The <literal>llapi_file_create()</literal> function sets a file descriptor&apos;s Lustre
        file system striping information. The file descriptor is then accessed with
          <literal>open()</literal>.</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Option</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <literal>llapi_file_create()</literal></para>
              </entry>
              <entry>
                <para>If the file already exists, this parameter returns to &apos;<literal>EEXIST</literal>&apos;. If the stripe parameters are invalid, this parameter returns to &apos;<literal>EINVAL</literal>&apos;.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>stripe_size</literal></para>
              </entry>
              <entry>
                <para>This value must be an even multiple of system page size, as shown by <literal>getpagesize()</literal>. The default Lustre stripe size is 4MB.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>stripe_offset</literal></para>
              </entry>
              <entry>
                <para>Indicates the starting OST for this file.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>stripe_count</literal></para>
              </entry>
              <entry>
                <para>Indicates the number of OSTs that this file will be striped across.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>stripe_pattern</literal></para>
              </entry>
              <entry>
                <para>Indicates the RAID pattern.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <note>
        <para>Currently, only RAID 0 is supported. To use the system defaults, set these values: <literal>stripe_size</literal> = 0, <literal>stripe_offset</literal> = -1, <literal>stripe_count</literal> = 0, <literal>stripe_pattern</literal> = 0</para>
      </note>
    </section>
    <section remap="h5">
      <title>Examples</title>
      <para>System default size is 4 MB.</para>
      <screen>char *tfile = TESTFILE;
int stripe_size = 65536</screen>
      <para>To start at default, run:</para>
      <screen>int stripe_offset = -1</screen>
      <para>To start at the default, run:</para>
      <screen>int stripe_count = 1</screen>
      <para>To set a single stripe for this example, run:</para>
      <screen>int stripe_pattern = 0</screen>
      <para>Currently, only RAID 0 is supported.</para>
      <screen>int stripe_pattern = 0; 
int rc, fd; 
rc = llapi_file_create(tfile, stripe_size,stripe_offset, stripe_count,stripe_pattern);</screen>
      <para>Result code is inverted, you may return with &apos;<literal>EINVAL</literal>&apos; or an ioctl error.</para>
      <screen>if (rc) {
fprintf(stderr,&quot;llapi_file_create failed: %d (%s) 0, rc, strerror(-rc));return -1; }</screen>
      <para><literal>llapi_file_create</literal> closes the file descriptor. You must re-open the descriptor. To do this, run:</para>
      <screen>fd = open(tfile, O_CREAT | O_RDWR | O_LOV_DELAY_CREATE, 0644); if (fd &lt; 0) \ { 
fprintf(stderr, &quot;Can&apos;t open %s file: %s0, tfile,
str-
error(errno));
return -1;
}</screen>
    </section>
  </section>
  <section xml:id="dbdoclet.50438215_50149">
    <title>llapi_file_get_stripe</title>
    <para>Use <literal>llapi_file_get_stripe</literal> to get striping information for a file or directory on a Lustre file system.</para>
    <section remap="h5">
      <title>Synopsis</title>
      <screen>
#include &lt;lustre/lustreapi.h&gt;
 
int llapi_file_get_stripe(const char *<emphasis>path</emphasis>, void *<emphasis>lum</emphasis>);</screen>
    </section>
    <section remap="h5">
      <title>Description</title>
      <para>The <literal>llapi_file_get_stripe()</literal> function returns striping information for a file or directory <emphasis>path</emphasis> in <emphasis>lum</emphasis> (which should point to a large enough memory region) in one of the following formats:</para>
      <screen>struct lov_user_md_v1 {
__u32 lmm_magic;
__u32 lmm_pattern;
__u64 lmm_object_id;
__u64 lmm_object_seq;
__u32 lmm_stripe_size;
__u16 lmm_stripe_count;
__u16 lmm_stripe_offset;
struct lov_user_ost_data_v1 lmm_objects[0];
} __attribute__((packed));
struct lov_user_md_v3 {
__u32 lmm_magic;
__u32 lmm_pattern;
__u64 lmm_object_id;
__u64 lmm_object_seq;
__u32 lmm_stripe_size;
__u16 lmm_stripe_count;
__u16 lmm_stripe_offset;
char lmm_pool_name[LOV_MAXPOOLNAME];
struct lov_user_ost_data_v1 lmm_objects[0];
} __attribute__((packed));</screen>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Option</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <literal>lmm_magic</literal></para>
              </entry>
              <entry>
                <para>Specifies the format of the returned striping information. <literal>LOV_MAGIC_V1</literal> is used for lov_user_md_v1. LOV_MAGIC_V3 is used for <literal>lov_user_md_v3</literal>.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>lmm_pattern</literal></para>
              </entry>
              <entry>
                <para>Holds the striping pattern. Only <literal>LOV_PATTERN_RAID0</literal> is
                  possible in this Lustre software release.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>lmm_object_id</literal></para>
              </entry>
              <entry>
                <para>Holds the MDS object ID.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>lmm_object_gr</literal></para>
              </entry>
              <entry>
                <para>Holds the MDS object group.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>lmm_stripe_size</literal></para>
              </entry>
              <entry>
                <para>Holds the stripe size in bytes.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>lmm_stripe_count</literal></para>
              </entry>
              <entry>
                <para>Holds the number of OSTs over which the file is striped.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>lmm_stripe_offset</literal></para>
              </entry>
              <entry>
                <para>Holds the OST index from which the file starts.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>lmm_pool_name</literal></para>
              </entry>
              <entry>
                <para>Holds the OST pool name to which the file belongs.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>lmm_objects</literal></para>
              </entry>
              <entry>
                <para>An array of <literal>lmm_stripe_count</literal> members containing per OST file information in</para>
                <para>the following format:</para>
                <screen>struct lov_user_ost_data_v1 {
                __u64 l_object_id;
                __u64 l_object_seq;
                __u32 l_ost_gen;
                __u32 l_ost_idx;
                } __attribute__((packed));</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>l_object_id</literal></para>
              </entry>
              <entry>
                <para>Holds the OST&apos;s object ID.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>l_object_seq</literal></para>
              </entry>
              <entry>
                <para>Holds the OST&apos;s object group.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>l_ost_gen</literal></para>
              </entry>
              <entry>
                <para>Holds the OST&apos;s index generation.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>l_ost_idx</literal></para>
              </entry>
              <entry>
                <para>Holds the OST&apos;s index in LOV.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section remap="h5">
      <title>Return Values</title>
      <para><literal>llapi_file_get_stripe()</literal> returns:</para>
      <para><literal>0</literal> On success</para>
      <para><literal>!= 0</literal> On failure, <literal>errno</literal> is set appropriately</para>
    </section>
    <section remap="h5">
      <title>Errors</title>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Errors</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <literal>ENOMEM</literal></para>
              </entry>
              <entry>
                <para>Failed to allocate memory</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>ENAMETOOLONG</literal></para>
              </entry>
              <entry>
                <para>Path was too long</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>ENOENT</literal></para>
              </entry>
              <entry>
                <para>Path does not point to a file or directory</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>ENOTTY</literal></para>
              </entry>
              <entry>
                <para>Path does not point to a Lustre file system</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>EFAULT</literal></para>
              </entry>
              <entry>
                <para>Memory region pointed by lum is not properly mapped</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section remap="h5">
      <title>Examples</title>
      <programlisting>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;lustre/lustreapi.h&gt;

static inline int maxint(int a, int b)
{
	return a &gt; b ? a : b;
}
static void *alloc_lum()
{
	int v1, v3, join;
	v1 = sizeof(struct lov_user_md_v1) +
		LOV_MAX_STRIPE_COUNT * sizeof(struct lov_user_ost_data_v1);
	v3 = sizeof(struct lov_user_md_v3) +
		LOV_MAX_STRIPE_COUNT * sizeof(struct lov_user_ost_data_v1);
	return malloc(maxint(v1, v3));
}
int main(int argc, char** argv)
{
	struct lov_user_md *lum_file = NULL;
	int rc;
	int lum_size;
	if (argc != 2) {
		fprintf(stderr, &quot;Usage: %s &lt;filename&gt;\n&quot;, argv[0]);
		return 1;
	}
	lum_file = alloc_lum();
	if (lum_file == NULL) {
		rc = ENOMEM;
		goto cleanup;
	}
	rc = llapi_file_get_stripe(argv[1], lum_file);
	if (rc) {
		rc = errno;
		goto cleanup;
	}
	/* stripe_size stripe_count */
	printf(&quot;%d %d\n&quot;,
			lum_file-&gt;lmm_stripe_size,
			lum_file-&gt;lmm_stripe_count);
cleanup:
	if (lum_file != NULL)
		free(lum_file);
	return rc;
}
</programlisting>
    </section>
  </section>
  <section xml:id="dbdoclet.50438215_86607">
    <title>
      <literal>llapi_file_open</literal>
    </title>
    <para>The <literal>llapi_file_open</literal> command opens (or creates) a file or device on a
      Lustre file system.</para>
    <section remap="h5">
      <title>Synopsis</title>
      <screen>#include &lt;lustre/lustreapi.h&gt;
int llapi_file_open(const char *<emphasis>name</emphasis>, int <emphasis>flags</emphasis>, int <emphasis>mode</emphasis>, 
   unsigned long long <emphasis>stripe_size</emphasis>, int <emphasis>stripe_offset</emphasis>, 
   int <emphasis>stripe_count</emphasis>, int <emphasis>stripe_pattern</emphasis>);
int llapi_file_create(const char *<emphasis>name</emphasis>, unsigned long long <emphasis>stripe_size</emphasis>, 
   int <emphasis>stripe_offset</emphasis>, int <emphasis>stripe_count</emphasis>, 
   int <emphasis>stripe_pattern</emphasis>);
</screen>
    </section>
    <section remap="h5">
      <title>Description</title>
      <para>The <literal>llapi_file_create()</literal> call is equivalent to the <literal>llapi_file_open</literal> call with <emphasis>flags</emphasis> equal to <literal>O_CREAT|O_WRONLY</literal> and <emphasis>mode</emphasis> equal to <literal>0644</literal>, followed by file close.</para>
      <para><literal>llapi_file_open()</literal> opens a file with a given name on a Lustre file
        system.</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Option</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <literal>flags</literal></para>
              </entry>
              <entry>
                <para>Can be a combination of <literal>O_RDONLY</literal>, <literal>O_WRONLY</literal>, <literal>O_RDWR</literal>, <literal>O_CREAT</literal>, <literal>O_EXCL</literal>, <literal>O_NOCTTY</literal>, <literal>O_TRUNC</literal>, <literal>O_APPEND</literal>, <literal>O_NONBLOCK</literal>, <literal>O_SYNC</literal>, <literal>FASYNC</literal>, <literal>O_DIRECT</literal>, <literal>O_LARGEFILE</literal>, <literal>O_DIRECTORY</literal>, <literal>O_NOFOLLOW</literal>, <literal>O_NOATIME</literal>.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>mode</literal></para>
              </entry>
              <entry>
                <para>Specifies the permission bits to be used for a new file when <literal>O_CREAT</literal> is used.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>stripe_size</literal></para>
              </entry>
              <entry>
                <para>Specifies stripe size (in bytes). Should be multiple of 64 KB, not exceeding 4 GB.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>stripe_offset</literal></para>
              </entry>
              <entry>
                <para>Specifies an OST index from which the file should start. The default value is -1.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>stripe_count</literal></para>
              </entry>
              <entry>
                <para>Specifies the number of OSTs to stripe the file across. The default value is -1.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>stripe_pattern</literal></para>
              </entry>
              <entry>
                <para>Specifies the striping pattern. In this release of the Lustre software, only
                    <literal>LOV_PATTERN_RAID0</literal> is available. The default value is
                  0.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section remap="h5">
      <title>Return Values</title>
      <para><literal>llapi_file_open()</literal> and <literal>llapi_file_create()</literal> return:</para>
      <para><literal>&gt;=0</literal> On success, for <literal>llapi_file_open</literal> the return value is a file descriptor</para>
      <para><literal>&lt;0</literal> On failure, the absolute value is an error code</para>
    </section>
    <section remap="h5">
      <title>Errors</title>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Errors</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <literal>EINVAL</literal></para>
              </entry>
              <entry>
                <para><literal>stripe_size</literal> or <literal>stripe_offset</literal> or <literal>stripe_count</literal> or <literal>stripe_pattern</literal> is invalid.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>EEXIST</literal></para>
              </entry>
              <entry>
                <para>Striping information has already been set and cannot be altered; <literal>name</literal> already exists.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>EALREADY</literal></para>
              </entry>
              <entry>
                <para>Striping information has already been set and cannot be altered</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>ENOTTY</literal></para>
              </entry>
              <entry>
                <para>
                  <literal>name</literal> may not point to a Lustre file system.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section remap="h5">
      <title>Example</title>
      <programlisting>
#include &lt;stdio.h&gt;
#include &lt;lustre/lustreapi.h&gt;

int main(int argc, char *argv[])
{
	int rc;
	if (argc != 2)
		return -1;
	rc = llapi_file_create(argv[1], 1048576, 0, 2, LOV_PATTERN_RAID0);
	if (rc &lt; 0) {
		fprintf(stderr, &quot;file creation has failed, %s\n&quot;,         strerror(-rc));
		return -1;
	}
	printf(&quot;%s with stripe size 1048576, striped across 2 OSTs,&quot;
			&quot; has been created!\n&quot;, argv[1]);
	return 0;
}
</programlisting>
    </section>
  </section>
  <section xml:id="dbdoclet.50438215_12433">
    <title>
      <literal>llapi_quotactl</literal>
    </title>
    <para>Use <literal>llapi_quotact</literal>l to manipulate disk quotas on a Lustre file system.</para>
    <section remap="h5">
      <title>Synopsis</title>
      <screen>#include &lt;lustre/lustreapi.h&gt;
int llapi_quotactl(char&quot; &quot; *mnt,&quot; &quot; struct if_quotactl&quot; &quot; *qctl)
 
struct if_quotactl {
        __u32                   qc_cmd;
        __u32                   qc_type;
        __u32                   qc_id;
        __u32                   qc_stat;
        struct obd_dqinfo       qc_dqinfo;
        struct obd_dqblk        qc_dqblk;
        char                    obd_type[16];
        struct obd_uuid         obd_uuid;
};
struct obd_dqblk {
        __u64 dqb_bhardlimit;
        __u64 dqb_bsoftlimit;
        __u64 dqb_curspace;
        __u64 dqb_ihardlimit;
        __u64 dqb_isoftlimit;
        __u64 dqb_curinodes;
        __u64 dqb_btime;
        __u64 dqb_itime;
        __u32 dqb_valid;
        __u32 padding;
};
struct obd_dqinfo {
        __u64 dqi_bgrace;
        __u64 dqi_igrace;
        __u32 dqi_flags;
        __u32 dqi_valid;
};
struct obd_uuid {
        char uuid[40];
};</screen>
    </section>
    <section remap="h5">
      <title>Description</title>
      <para>The <literal>llapi_quotactl()</literal> command manipulates disk quotas on a Lustre file system mount. qc_cmd indicates a command to be applied to UID <literal>qc_id</literal> or GID <literal>qc_id</literal>.</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Option</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <literal>LUSTRE_Q_QUOTAON</literal></para>
              </entry>
              <entry>
                <para>Turns on quotas for a Lustre file system. Deprecated as of 2.4.0.
                    <emphasis>qc_type</emphasis> is <literal>USRQUOTA</literal>,
                    <literal>GRPQUOTA</literal> or <literal>UGQUOTA</literal> (both user and group
                  quota). The quota files must exist. They are normally created with the
                    <literal>llapi_quotacheck</literal> call. This call is restricted to the super
                  user privilege. As of 2.4.0, quota is now enabled on a per file system basis via
                    <literal>lctl conf_param</literal> (see <xref linkend="enabling_disk_quotas"/>)
                  on the MGS node and quotacheck isn't needed any more.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>LUSTRE_Q_QUOTAOFF</literal></para>
              </entry>
              <entry>
                <para>Turns off quotas for a Lustre file system. Deprecated as of 2.4.0. <emphasis>qc_type</emphasis> is <literal>USRQUOTA</literal>, <literal>GRPQUOTA</literal> or <literal>UGQUOTA</literal> (both user and group quota). This call is restricted to the super user privilege. As of 2.4.0, quota is disabled via <literal>lctl conf_param</literal> (see <xref linkend="enabling_disk_quotas"/>).</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>LUSTRE_Q_GETQUOTA</literal></para>
              </entry>
              <entry>
                <para>Gets disk quota limits and current usage for user or group <emphasis>qc_id</emphasis>. <emphasis>qc_type</emphasis> is <literal>USRQUOTA</literal> or <literal>GRPQUOTA</literal>. <emphasis>uuid</emphasis> may be filled with <literal>OBD UUID</literal> string to query quota information from a specific node. <emphasis>dqb_valid</emphasis> may be set nonzero to query information only from MDS. If <emphasis>uuid</emphasis> is an empty string and <emphasis>dqb_valid</emphasis> is zero then cluster-wide limits and usage are returned. On return, <emphasis>obd_dqblk</emphasis> contains the requested information (block limits unit is kilobyte). Quotas must be turned on before using this command.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>LUSTRE_Q_SETQUOTA</literal></para>
              </entry>
              <entry>
                <para>Sets disk quota limits for user or group <emphasis>qc_id</emphasis>. <emphasis>qc_type</emphasis> is <literal>USRQUOTA</literal> or <literal>GRPQUOTA</literal>. <emphasis>dqb_valid</emphasis> must be set to <literal>QIF_ILIMITS</literal>, <literal>QIF_BLIMITS</literal> or <literal>QIF_LIMITS</literal> (both inode limits and block limits) dependent on updating limits. <emphasis>obd_dqblk</emphasis> must be filled with limits values (as set in <emphasis>dqb_valid</emphasis>, block limits unit is kilobyte). Quotas must be turned on before using this command.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>LUSTRE_Q_GETINFO</literal></para>
              </entry>
              <entry>
                <para>Gets information about quotas. <emphasis>qc_type</emphasis> is either
                    <literal>USRQUOTA</literal> or <literal>GRPQUOTA</literal>. On return,
                    <emphasis>dqi_igrace</emphasis> is inode grace time (in seconds),
                    <emphasis>dqi_bgrace</emphasis> is block grace time (in seconds),
                    <emphasis>dqi_flags</emphasis> is not used by the current release of the Lustre
                  software.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>LUSTRE_Q_SETINFO</literal></para>
              </entry>
              <entry>
                <para>Sets quota information (like grace times). <emphasis>qc_type</emphasis> is
                  either <literal>USRQUOTA</literal> or <literal>GRPQUOTA</literal>.
                    <emphasis>dqi_igrace</emphasis> is inode grace time (in seconds),
                    <emphasis>dqi_bgrace</emphasis> is block grace time (in seconds),
                    <emphasis>dqi_flags</emphasis> is not used by the current release of the Lustre
                  software and must be zeroed.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section remap="h5">
      <title>Return Values</title>
      <para><literal>llapi_quotactl()</literal> returns:</para>
      <para><literal>0</literal> On success</para>
      <para><literal> -1 </literal> On failure and sets error number (<literal>errno</literal>) to indicate the error</para>
    </section>
    <section remap="h5">
      <title>Errors</title>
      <para><literal>llapi_quotactl</literal> errors are described below.</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Errors</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <literal>EFAULT</literal></para>
              </entry>
              <entry>
                <para><emphasis>qctl</emphasis> is invalid.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>ENOSYS</literal></para>
              </entry>
              <entry>
                <para>Kernel or Lustre modules have not been compiled with the <literal>QUOTA</literal> option.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>ENOMEM</literal></para>
              </entry>
              <entry>
                <para>Insufficient memory to complete operation.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>ENOTTY</literal></para>
              </entry>
              <entry>
                <para> <emphasis>qc_cmd</emphasis> is invalid.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>EBUSY</literal></para>
              </entry>
              <entry>
                <para>Cannot process during quotacheck.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>ENOENT</literal></para>
              </entry>
              <entry>
                <para> <emphasis>uuid</emphasis> does not correspond to OBD or <emphasis>mnt</emphasis> does not exist.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>EPERM</literal></para>
              </entry>
              <entry>
                <para>The call is privileged and the caller is not the super user.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>ESRCH</literal></para>
              </entry>
              <entry>
                <para>No disk quota is found for the indicated user. Quotas have not been turned on for this file system.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
  </section>
  <section xml:id="dbdoclet.50438215_15718">
    <title>
      <literal>llapi_path2fid</literal>
    </title>
    <para>Use <literal>llapi_path2fid</literal> to get the FID from the pathname.</para>
    <section remap="h5">
      <title>Synopsis</title>
      <screen>#include &lt;lustre/lustreapi.h&gt;
 
int llapi_path2fid(const char *path, unsigned long long *seq, unsigned long *oid, unsigned long *ver)</screen>
    </section>
    <section remap="h5">
      <title>Description</title>
      <para>The <literal>llapi_path2fid</literal> function returns the FID (sequence : object ID : version) for the pathname.</para>
    </section>
    <section remap="h5">
      <title>Return Values</title>
      <para><literal>llapi_path2fid</literal> returns:</para>
      <para><literal>0</literal> On success</para>
      <para>non-zero value On failure</para>
    </section>
  </section>
  <section condition="l29">
      <title>
          <literal>llapi_ladvise</literal>
      </title>
      <para>Use <literal>llapi_ladvise</literal> to give IO advice/hints on a
      Lustre file to the server.</para>
      <section remap="h5">
          <title>Synopsis</title>
          <screen>
#include &lt;lustre/lustreapi.h&gt;
int llapi_ladvise(int fd, unsigned long long flags,
                  int num_advise, struct llapi_lu_ladvise *ladvise);
                                
struct llapi_lu_ladvise {
  __u16 lla_advice;       /* advice type */
  __u16 lla_value1;       /* values for different advice types */
  __u32 lla_value2;
  __u64 lla_start;        /* first byte of extent for advice */
  __u64 lla_end;          /* last byte of extent for advice */
  __u32 lla_value3;
  __u32 lla_value4;
};
          </screen>
      </section>
      <section remap="h5">
          <title>Description</title>
          <para>The <literal>llapi_ladvise</literal> function passes an array of
          <emphasis>num_advise</emphasis> I/O hints (up to a maximum of
          <emphasis>LAH_COUNT_MAX</emphasis> items) in ladvise for the file
          descriptor <emphasis>fd</emphasis> from an application to one or more
          Lustre servers.  Optionally, <emphasis>flags</emphasis> can modify how
          the advice will be processed via bitwise-or'd values:</para>
          <itemizedlist>
          <listitem>
          <para><literal>LF_ASYNC</literal>: Clients return to userspace
          immediately after submitting ladvise RPCs, leaving server threads to
          handle the advices asynchronously.</para>
          </listitem>
          <listitem>
          <para><literal>LF_UNSET</literal>: Unset/clear a previous advice
          (Currently only supports LU_ADVISE_LOCKNOEXPAND).</para>
          </listitem>
          </itemizedlist>
          <para>Each of the <emphasis>ladvise</emphasis> elements is an
          <emphasis>llapi_lu_ladvise</emphasis> structure, which contains the
          following fields:
          <informaltable frame="all">
            <tgroup cols="2">
              <colspec colname="c1" colwidth="50*"/>
              <colspec colname="c2" colwidth="50*"/>
              <thead>
                <row>
                  <entry>
                    <para><emphasis role="bold">Field</emphasis></para>
                  </entry>
                  <entry>
                    <para><emphasis role="bold">Description</emphasis></para>
                  </entry>
                </row>
              </thead>
              <tbody>
              <row>
              <entry>
                <para> <literal>lla_ladvice</literal></para>
              </entry>
              <entry>
                <para>Specifies the advice for the given file range, currently
                one of:</para>
                <para><literal>LU_LADVISE_WILLREAD</literal>:  Prefetch data
                into server cache using optimum I/O size for the server.</para>
                <para><literal>LU_LADVISE_DONTNEED</literal>:  Clean cached data
                for the specified file range(s) on the server.</para>
              </entry>
              </row>
              <row>
                <entry>
                  <para> <literal>lla_start</literal></para>
                </entry>
                <entry>
                  <para>The offset in bytes for the start of this advice.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <literal>lla_end</literal></para>
                </entry>
                <entry>
                  <para>The offset in bytes (non-inclusive) for the end of this
                  advice.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <literal>lla_value1</literal></para>
                  <para> <literal>lla_value2</literal></para>
                  <para> <literal>lla_value3</literal></para>
                  <para> <literal>lla_value4</literal></para>
                </entry>
                <entry>
                    <para>Additional arguments for future advice types and
                    should be set to zero if not explicitly required for a given
                    advice type.  Advice-specific names for these fields
                    follow.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <literal>lla_lockahead_mode</literal></para>
                </entry>
                <entry>
                  <para>When using LU_ADVISE_LOCKAHEAD, the 'lla_value1' field
                  is used to communicate the requested lock mode, and can be
                  referred to as lla_lockahead_mode.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <literal>lla_peradvice_flags</literal></para>
                </entry>
                <entry>
                  <para>When using advices which support them, the 'lla_value2'
                  field is used to communicate per-advice flags and can be
                  referred to as 'lla_peradvice_flags'. Both LF_ASYNC and
                  LF_UNSET are supported as peradvice flags.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <literal>lla_lockahead_result</literal></para>
                </entry>
                <entry>
                  <para>When using LU_ADVISE_LOCKAHEAD, the 'lla_value3' field
                  is used to communicate the result of the request, and can be
                  referred to as lla_lockahead_result.</para>
                </entry>
              </row>
              </tbody>
              </tgroup>
          </informaltable>
          </para>
          <para><literal>llapi_ladvise()</literal> forwards the advice to Lustre
          servers without guaranteeing how and when servers will react to the
          advice. Actions may or may not be triggered when the advices are
          received, depending on the type of the advice as well as the real-time
          decision of the affected server-side components.
          </para>
          <para> A typical usage of <literal>llapi_ladvise()</literal> is to
          enable applications and users (via <literal>lfs ladvise</literal>)
          with external knowledge about application I/O patterns to intervene in
          server-side I/O handling. For example, if a group of different clients
          are doing small random reads of a file, prefetching pages into OSS
          cache with big linear reads before the random IO is an overall net
          benefit.  Fetching that data into each client cache with
          <emphasis>fadvise()</emphasis> may not be beneficial, due to much more
          data being sent to the clients.
          </para>
          <para>
          LU_LADVISE_LOCKAHEAD merits a special comment.  While it is possible
          and encouraged to use it directly in your application to avoid lock
          contention (primarily for writing to a single file from multiple
          clients), it will also be available in the MPI-I/O / MPICH library
          from ANL for use with the i/o aggregation mode of that library.  This
          is intended (eventually) to be the primary way this feature is used.
          </para>
          <para>
          At the time of writing, this support is proposed as a patch but is
          not yet merged in to the public ANL code base.  Users are encouraged
          to check their MPICH documentation and/or check with their library
          provider about support.
          </para>
          <para>While conceptually similar to the
          <emphasis>posix_fadvise</emphasis> and Linux
          <emphasis>fadvise</emphasis> system calls, the main difference of
          <literal>llapi_ladvise()</literal> is that
          <emphasis>fadvise() / posix_fadvise()</emphasis> are client side
          mechanisms that do not pass advice to the filesystem, while
          <literal>llapi_ladvise()</literal> sends advice or hints to one or
          more Lustre servers on which the file is stored.  In some cases it may
          be desirable to use both interfaces.
          </para>
      </section>
      <section remap="h5">
          <title>Return Values</title>
          <para><literal>llapi_ladvise</literal> returns:</para>
          <para><literal>0</literal> On success</para>
          <para><literal>-1</literal> if an error occurred (in which case, errno
          is set appropriately).</para>
      </section>
      <section remap="h5">
          <title>Errors</title>
        <para>
          <informaltable frame="all">
            <tgroup cols="2">
              <colspec colname="c1" colwidth="50*"/>
              <colspec colname="c2" colwidth="50*"/>
              <thead>
                <row>
                  <entry>
                    <para><emphasis role="bold">Error</emphasis></para>
                  </entry>
                  <entry>
                    <para><emphasis role="bold">Description</emphasis></para>
                  </entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>
                    <para> <literal>ENOMEM</literal></para>
                  </entry>
                  <entry>
                    <para>Insufficient memory to complete operation.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para> <literal>EINVAL</literal></para>
                  </entry>
                  <entry>
                    <para>One or more invalid arguments are given.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para> <literal>EFAULT</literal></para>
                  </entry>
                  <entry>
                    <para>Memory region pointed by
                    <literal>ladvise</literal> is not properly mapped.
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para> <literal>ENOTSUPP</literal></para>
                  </entry>
                  <entry>
                    <para>Advice type is not supported.</para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          </para>
      </section>
  </section>
  <section xml:id="dbdoclet.50438215_marker-1297700">
    <title>Example Using the <literal>llapi</literal> Library</title>
    <para>Use <literal>llapi_file_create</literal> to set Lustre software properties for a new file.
      For a synopsis and description of <literal>llapi_file_create</literal> and examples of how to
      use it, see <xref linkend="configurationfilesmoduleparameters"/>.</para>
    <para>You can set striping from inside programs like <literal>ioctl</literal>. To compile the sample program, you need to install the Lustre client source RPM.</para>
    <para><emphasis role="bold">A simple C program to demonstrate striping API - libtest.c</emphasis></para>
    <programlisting>
/* -*- mode: c; c-basic-offset: 8; indent-tabs-mode: nil; -*-
 * vim:expandtab:shiftwidth=8:tabstop=8:
 *
 * lustredemo - a simple example of lustreapi functions
 */
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;dirent.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;lustre/lustreapi.h&gt;
#define MAX_OSTS 1024
#define LOV_EA_SIZE(lum, num) (sizeof(*lum) + num * sizeof(*lum-&gt;lmm_objects))
#define LOV_EA_MAX(lum) LOV_EA_SIZE(lum, MAX_OSTS)

/*
 * This program provides crude examples of using the lustreapi API functions
 */
/* Change these definitions to suit */

#define TESTDIR &quot;/tmp&quot;           /* Results directory */
#define TESTFILE &quot;lustre_dummy&quot;  /* Name for the file we create/destroy */
#define FILESIZE 262144                    /* Size of the file in words */
#define DUMWORD &quot;DEADBEEF&quot;       /* Dummy word used to fill files */
#define MY_STRIPE_WIDTH 2                  /* Set this to the number of OST required */
#define MY_LUSTRE_DIR &quot;/mnt/lustre/ftest&quot;

int close_file(int fd)
{
        if (close(fd) &lt; 0) {
                fprintf(stderr, &quot;File close failed: %d (%s)\n&quot;, errno, strerror(errno));
                return -1;
        }
        return 0;
}

int write_file(int fd)
{
        char *stng =  DUMWORD;
        int cnt = 0;

        for( cnt = 0; cnt &lt; FILESIZE; cnt++) {
                write(fd, stng, sizeof(stng));
        }
        return 0;
}
/* Open a file, set a specific stripe count, size and starting OST
 *    Adjust the parameters to suit */
int open_stripe_file()
{
        char *tfile = TESTFILE;
        int stripe_size = 65536;    /* System default is 4M */
        int stripe_offset = -1;     /* Start at default */
        int stripe_count = MY_STRIPE_WIDTH;  /*Single stripe for this demo*/
        int stripe_pattern = 0;     /* only RAID 0 at this time */
        int rc, fd;

        rc = llapi_file_create(tfile,
                        stripe_size,stripe_offset,stripe_count,stripe_pattern);
        /* result code is inverted, we may return -EINVAL or an ioctl error.
         * We borrow an error message from sanity.c
         */
        if (rc) {
                fprintf(stderr,&quot;llapi_file_create failed: %d (%s) \n&quot;, rc, strerror(-rc));
                return -1;
        }
        /* llapi_file_create closes the file descriptor, we must re-open */
        fd = open(tfile, O_CREAT | O_RDWR | O_LOV_DELAY_CREATE, 0644);
        if (fd &lt; 0) {
                fprintf(stderr, &quot;Can't open %s file: %d (%s)\n&quot;, tfile, errno, strerror(errno));
                return -1;
        }
        return fd;
}

/* output a list of uuids for this file */
int get_my_uuids(int fd)
{
        struct obd_uuid uuids[1024], *uuidp;        /* Output var */
        int obdcount = 1024;
        int rc,i;

        rc = llapi_lov_get_uuids(fd, uuids, &amp;obdcount);
        if (rc != 0) {
                fprintf(stderr, &quot;get uuids failed: %d (%s)\n&quot;,errno, strerror(errno));
        }
        printf(&quot;This file system has %d obds\n&quot;, obdcount);
        for (i = 0, uuidp = uuids; i &lt; obdcount; i++, uuidp++) {
                printf(&quot;UUID %d is %s\n&quot;,i, uuidp-&gt;uuid);
        }
        return 0;
}

/* Print out some LOV attributes. List our objects */
int get_file_info(char *path)
{

        struct lov_user_md *lump;
        int rc;
        int i;

        lump = malloc(LOV_EA_MAX(lump));
        if (lump == NULL) {
                return -1;
        }

        rc = llapi_file_get_stripe(path, lump);

        if (rc != 0) {
                fprintf(stderr, &quot;get_stripe failed: %d (%s)\n&quot;,errno, strerror(errno));
                return -1;
        }

        printf(&quot;Lov magic %u\n&quot;, lump-&gt;lmm_magic);
        printf(&quot;Lov pattern %u\n&quot;, lump-&gt;lmm_pattern);
        printf(&quot;Lov object id %llu\n&quot;, lump-&gt;lmm_object_id);
        printf(&quot;Lov stripe size %u\n&quot;, lump-&gt;lmm_stripe_size);
        printf(&quot;Lov stripe count %hu\n&quot;, lump-&gt;lmm_stripe_count);
        printf(&quot;Lov stripe offset %u\n&quot;, lump-&gt;lmm_stripe_offset);
        for (i = 0; i &lt; lump-&gt;lmm_stripe_count; i++) {
                printf(&quot;Object index %d Objid %llu\n&quot;, lump-&gt;lmm_objects[i].l_ost_idx, lump-&gt;lmm_objects[i].l_object_id);
        }

        free(lump);
        return rc;

}

/* Ping all OSTs that belong to this filesystem */
int ping_osts()
{
        DIR *dir;
        struct dirent *d;
        char osc_dir[100];
        int rc;

        sprintf(osc_dir, &quot;/proc/fs/lustre/osc&quot;);
        dir = opendir(osc_dir);
        if (dir == NULL) {
                printf(&quot;Can't open dir\n&quot;);
                return -1;
        }
        while((d = readdir(dir)) != NULL) {
                if ( d-&gt;d_type == DT_DIR ) {
                        if (! strncmp(d-&gt;d_name, &quot;OSC&quot;, 3)) {
                                printf(&quot;Pinging OSC %s &quot;, d-&gt;d_name);
                                rc = llapi_ping(&quot;osc&quot;, d-&gt;d_name);
                                if (rc) {
                                        printf(&quot;  bad\n&quot;);
                                } else {
                                        printf(&quot;  good\n&quot;);
                                }
                        }
                }
        }
        return 0;

}

int main()
{
        int file;
        int rc;
        char filename[100];
        char sys_cmd[100];

        sprintf(filename, &quot;%s/%s&quot;,MY_LUSTRE_DIR, TESTFILE);

        printf(&quot;Open a file with striping\n&quot;);
        file = open_stripe_file();
        if ( file &lt; 0 ) {
                printf(&quot;Exiting\n&quot;);
                exit(1);
        }
        printf(&quot;Getting uuid list\n&quot;);
        rc = get_my_uuids(file);
        printf(&quot;Write to the file\n&quot;);
        rc = write_file(file);
        rc = close_file(file);
        printf(&quot;Listing LOV data\n&quot;);
        rc = get_file_info(filename);
        printf(&quot;Ping our OSTs\n&quot;);
        rc = ping_osts();

        /* the results should match lfs getstripe */
        printf(&quot;Confirming our results with lfs getstripe\n&quot;);
        sprintf(sys_cmd, &quot;/usr/bin/lfs getstripe %s/%s&quot;, MY_LUSTRE_DIR, TESTFILE);
        system(sys_cmd);

        printf(&quot;All done\n&quot;);
        exit(rc);
}
</programlisting>
    <para><emphasis role="bold">Makefile for sample application:</emphasis></para>
    <screen> 
gcc -g -O2 -Wall -o lustredemo libtest.c -llustreapi
clean:
rm -f core lustredemo *.o
run: 
make
rm -f /mnt/lustre/ftest/lustredemo
rm -f /mnt/lustre/ftest/lustre_dummy
cp lustredemo /mnt/lustre/ftest/
</screen>
    <section remap="h5">
      <title>See Also</title>
      <itemizedlist>
        <listitem>
          <para>
            <xref linkend="dbdoclet.50438215_30970"/>
    </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="dbdoclet.50438215_50149"/>
    </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="dbdoclet.50438215_86607"/>
    </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="dbdoclet.50438215_12433"/>
    </para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
</chapter>
