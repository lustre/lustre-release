<?xml version='1.0' encoding='UTF-8'?><chapter xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en-US" xml:id="lustredebugging">
  <title xml:id="lustredebugging.title">Debugging a Lustre File System</title>
  <para>This chapter describes tips and information to debug a Lustre file system, and includes the
    following sections:</para>
  <itemizedlist>
    <listitem>
      <para><xref linkend="dbdoclet.50438274_15874"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438274_23607"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438274_80443"/></para>
    </listitem>
  </itemizedlist>
  <section xml:id="dbdoclet.50438274_15874">
    <title><indexterm><primary>debugging</primary></indexterm>
Diagnostic and Debugging Tools</title>
    <para>A variety of diagnostic and analysis tools are available to debug issues with the Lustre software. Some of these are provided in Linux distributions, while others have been developed and are made available by the Lustre project.</para>
    <section remap="h3" xml:id="section_dms_q21_kk">
      <title><indexterm>
          <primary>debugging</primary>
          <secondary>tools</secondary>
        </indexterm> Lustre Debugging Tools</title>
      <para>The following in-kernel debug mechanisms are incorporated into the Lustre
        software:</para>
      <itemizedlist>
        <listitem>
          <para xml:id="para_fkj_rld_hk"><emphasis role="bold">Debug logs</emphasis> - A circular
            debug buffer to which Lustre internal debug messages are written (in contrast to error
            messages, which are printed to the syslog or console). Entries to the Lustre debug log
            are controlled by the mask set by <literal>/proc/sys/lnet/debug</literal>. The log size
            defaults to 5 MB per CPU but can be increased as a busy system will quickly overwrite 5
            MB. When the buffer fills, the oldest information is discarded.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Debug daemon</emphasis> - The debug daemon controls logging of
            debug messages.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">
              <literal>/proc/sys/lnet/debug</literal>
            </emphasis> - This file contains a mask that can be used to delimit the debugging
            information written out to the kernel debug logs.</para>
        </listitem>
      </itemizedlist>
      <para>The following tools are also provided with the Lustre software:</para>
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">
              <literal>lctl</literal>
            </emphasis> - This tool is used with the debug_kernel option to manually dump the Lustre
            debugging log or post-process debugging logs that are dumped automatically. For more
            information about the lctl tool, see <xref linkend="dbdoclet.50438274_62472"/> and <xref
              linkend="dbdoclet.50438219_38274"/>.</para>
        </listitem>
        <listitem>
          <para>Lustre subsystem asserts - A panic-style assertion (LBUG) in the kernel causes the
            Lustre file system to dump the debug log to the file
                <literal>/tmp/lustre-log.<replaceable>timestamp</replaceable></literal> where it can
            be retrieved after a reboot. For more information, see <xref
              linkend="dbdoclet.50438198_40669"/>.</para>
        </listitem>
        <listitem>
          <para>
            <literal>
              <replaceable>lfs</replaceable>
            </literal> - This utility provides access to the extended attributes (EAs) of a Lustre
            file (along with other information). For more information about lfs, see <xref
              linkend="dbdoclet.50438206_94597"/>.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section remap="h3">
      <title><indexterm><primary>debugging</primary><secondary>external tools</secondary></indexterm>External Debugging Tools</title>
      <para>The tools described in this section are provided in the Linux kernel or are available at an external website. For information about using some of these tools for Lustre debugging, see <xref linkend="dbdoclet.50438274_23607"/> and <xref linkend="dbdoclet.50438274_80443"/>.</para>
      <section remap="h4">
        <title><indexterm><primary>debugging</primary><secondary>admin tools</secondary></indexterm>Tools for Administrators and Developers</title>
        <para>Some general debugging tools provided as a part of the standard Linux distribution
          are:</para>
        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">
                <literal>strace</literal>
              </emphasis> . This tool allows a system call to be traced.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">
                <literal>/var/log/messages</literal>
              </emphasis> . <literal>syslogd</literal> prints fatal or serious messages at this log.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">Crash dumps</emphasis> . On crash-dump enabled kernels,
              sysrq c produces a crash dump. The Lustre software enhances this crash dump with a log
              dump (the last 64 KB of the log) to the console.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">
                <literal>debugfs</literal>
              </emphasis>. Interactive file system debugger.</para>
          </listitem>
        </itemizedlist>
        <para>The following logging and data collection tools can be used to collect information for debugging Lustre kernel issues:</para>
        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">
                <literal>kdump</literal>
              </emphasis> . A Linux kernel crash utility useful for debugging a system running Red Hat Enterprise Linux. For more information about <literal>kdump</literal>, see the Red Hat knowledge base article <link xl:href="http://kbase.redhat.com/faq/docs/DOC-6039">How do I configure kexec/kdump on Red Hat Enterprise Linux 5?</link>. To download <literal>kdump</literal>, go to the <link xl:href="http://fedoraproject.org/wiki/SystemConfig/kdump#Download">Fedora Project Download</link> site.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">
                <literal>netconsole</literal>
              </emphasis>. Enables kernel-level network logging over UDP. A system requires (SysRq) allows users to collect relevant data through <literal>netconsole</literal>.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">
                <literal>netdump</literal>
              </emphasis>. A crash dump utility from Red Hat that allows memory images to be dumped
              over a network to a central server for analysis. The <literal>netdump</literal>
              utility was replaced by <literal>kdump</literal> in Red Hat Enterprise Linux 5. For
              more information about <literal>netdump</literal>, see <link
                xl:href="http://www.redhat.com/support/wpapers/redhat/netdump/">Red Hat, Inc.&apos;s
                Network Console and Crash Dump Facility</link>.</para>
          </listitem>
	  <listitem>
	    <para><emphasis><literal>wireshark</literal> </emphasis> . A network
	    packet inspection tool that allows debugging of information that was
	    sent between the various Lustre nodes. This tool is built on top of
	    <literal>tcpdump</literal> and can read packet dumps generated by
	    it.  There are plug-ins available to dissassemble the LNet and
	    Lustre protocols.  They are located within the <link
	    xl:href="http://git.whamcloud.com/">Lustre git repository</link>
	    under <literal>lustre/contrib/wireshark/</literal>.  Installation
	    instruction are included in that directory. See also <link
	    xl:href="http://www.wireshark.org/">Wireshark Website</link> for
	    more details.</para>
	  </listitem>
        </itemizedlist>
      </section>
      <section remap="h4">
        <title><indexterm><primary>debugging</primary><secondary>developer tools</secondary></indexterm>Tools for Developers</title>
        <para>The tools described in this section may be useful for debugging a Lustre file system
          in a development environment.</para>
        <para>Of general interest is:</para>
        <itemizedlist>
          <listitem>
            <para><literal>
                <replaceable>leak_finder.pl</replaceable>
              </literal> . This program provided with the Lustre software is useful for finding
              memory leaks in the code.</para>
          </listitem>
        </itemizedlist>
        <para>A virtual machine is often used to create an isolated development and test environment. Some commonly-used virtual machines are:</para>
        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">VirtualBox Open Source Edition</emphasis> . Provides enterprise-class virtualization capability for all major platforms and is available free at <link xl:href="http://www.sun.com/software/products/virtualbox/get.jsp?intcmp=2945">Get Sun VirtualBox</link>.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">VMware Server</emphasis> . Virtualization platform available as free introductory software at <link xl:href="http://downloads.vmware.com/d/info/datacenter_downloads/vmware_server/2_0">Download VMware Server</link>.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">Xen</emphasis> . A para-virtualized environment with virtualization capabilities similar to VMware Server and Virtual Box. However, Xen allows the use of modified kernels to provide near-native performance and the ability to emulate shared storage. For more information, go to <link xl:href="http://xen.org/">xen.org</link>.</para>
          </listitem>
        </itemizedlist>
        <para>A variety of debuggers and analysis tools are available including:</para>
        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">
                <literal>kgdb</literal>
              </emphasis> . The Linux Kernel Source Level Debugger kgdb is used in conjunction with the GNU Debugger <literal>gdb</literal> for debugging the Linux kernel. For more information about using <literal>kgdb</literal> with <literal>gdb</literal>, see <link xl:href="http://www.linuxtopia.org/online_books/redhat_linux_debugging_with_gdb/running.html">Chapter 6. Running Programs Under gdb</link> in the <emphasis>Red Hat Linux 4 Debugging with GDB</emphasis> guide.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">
                <literal>crash</literal>
              </emphasis> . Used to analyze saved crash dump data when a system had panicked or locked up or appears unresponsive. For more information about using crash to analyze a crash dump, see:</para>
            <itemizedlist>
              <listitem>
                <para> Red Hat Magazine article: <link xl:href="http://magazine.redhat.com/2007/08/15/a-quick-overview-of-linux-kernel-crash-dump-analysis/">A quick overview of Linux kernel crash dump analysis</link></para>
              </listitem>
              <listitem>
                <para><link xl:href="http://people.redhat.com/anderson/crash_whitepaper/#EXAMPLES">Crash Usage: A Case Study</link>  from the white paper <emphasis>Red Hat Crash Utility</emphasis> by David Anderson</para>
              </listitem>
              <listitem>
                <para> Kernel Trap forum entry: <link xl:href="http://kerneltrap.org/node/5758">Linux: Kernel Crash Dumps</link></para>
              </listitem>
              <listitem>
                <para> White paper: <link xl:href="http://www.google.com/url?sa=t&amp;source=web&amp;ct=res&amp;cd=8&amp;ved=0CCUQFjAH&amp;url=http%3A%2F%2Fwww.kernel.sg%2Fpapers%2Fcrash-dump-analysis.pdf&amp;rct=j&amp;q=redhat+crash+dump&amp;ei=6aQBS-ifK4T8tAPcjdiHCw&amp;usg=AFQjCNEk03E3GDtAsawG3gfpwc1gGNELAg">A Quick Overview of Linux Kernel Crash Dump Analysis</link></para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>
  <section xml:id="dbdoclet.50438274_23607">
    <title><indexterm><primary>debugging</primary><secondary>procedure</secondary></indexterm>Lustre Debugging Procedures</title>
    <para>The procedures below may be useful to administrators or developers debugging a Lustre files system.</para>
    <section remap="h3">
      <title><indexterm><primary>debugging</primary><secondary>message format</secondary></indexterm>Understanding the Lustre Debug Messaging Format</title>
      <para>Lustre debug messages are categorized by originating subsystem, message type, and location in the source code. For a list of subsystems and message types, see <xref linkend="dbdoclet.50438274_57603"/>.</para>
      <note>
        <para>For a current list of subsystems and debug message types, see
            <literal>libcfs/include/libcfs/libcfs_debug.h</literal> in the Lustre software
          tree</para>
      </note>
      <para>The elements of a Lustre debug message are described in <xref linkend="dbdoclet.50438274_57177"/> Format of Lustre Debug Messages.</para>
      <section xml:id="dbdoclet.50438274_57603">
        <title>Lustre Debug Messages</title>
        <para>Each Lustre debug message has the tag of the subsystem it originated in, the message
          type, and the location in the source code. The subsystems and debug types used are as
          follows:</para>
        <itemizedlist>
          <listitem>
            <para>  Standard Subsystems:</para>
            <para> mdc, mds, osc, ost, obdclass, obdfilter, llite, ptlrpc, portals, lnd, ldlm, lov</para>
          </listitem>
        </itemizedlist>
        <itemizedlist>
          <listitem>
            <para>  Debug Types:</para>
          </listitem>
          <listitem>
            <para><informaltable frame="all">
                <tgroup cols="2">
                  <colspec colname="c1" colwidth="50*"/>
                  <colspec colname="c2" colwidth="50*"/>
                  <thead>
                    <row>
                      <entry>
                        <para><emphasis role="bold">Types</emphasis></para>
                      </entry>
                      <entry>
                        <para><emphasis role="bold">Description</emphasis></para>
                      </entry>
                    </row>
                  </thead>
                  <tbody>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">trace</emphasis></para>
                      </entry>
                      <entry>
                        <para> Entry/Exit markers</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">dlmtrace</emphasis></para>
                      </entry>
                      <entry>
                        <para> Locking-related information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">inode</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">super</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">ext2</emphasis></para>
                      </entry>
                      <entry>
                        <para> Anything from the ext2_debug</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">malloc</emphasis></para>
                      </entry>
                      <entry>
                        <para> Print malloc or free information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">cache</emphasis></para>
                      </entry>
                      <entry>
                        <para> Cache-related information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">info</emphasis></para>
                      </entry>
                      <entry>
                        <para> General information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">ioctl</emphasis></para>
                      </entry>
                      <entry>
                        <para> IOCTL-related information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">blocks</emphasis></para>
                      </entry>
                      <entry>
                        <para> Ext2 block allocation information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">net</emphasis></para>
                      </entry>
                      <entry>
                        <para> Networking</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">warning</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">buffs</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">other</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">dentry</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">portals</emphasis></para>
                      </entry>
                      <entry>
                        <para> Entry/Exit markers</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">page</emphasis></para>
                      </entry>
                      <entry>
                        <para> Bulk page handling</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">error</emphasis></para>
                      </entry>
                      <entry>
                        <para> Error messages</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">emerg</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">rpctrace</emphasis></para>
                      </entry>
                      <entry>
                        <para> For distributed debugging</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">ha</emphasis></para>
                      </entry>
                      <entry>
                        <para> Failover and recovery-related information</para>
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
</para>
          </listitem>
        </itemizedlist>
      </section>
      <section xml:id="dbdoclet.50438274_57177">
        <title>Format of Lustre Debug Messages</title>
        <para>The Lustre software uses the <literal>CDEBUG()</literal> and
            <literal>CERROR()</literal> macros to print the debug or error messages. To print the
          message, the <literal>CDEBUG()</literal> macro uses the function
            <literal>libcfs_debug_msg()</literal> (<literal>libcfs/libcfs/tracefile.c</literal>).
          The message format is described below, along with an example.</para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50*"/>
            <colspec colname="c2" colwidth="50*"/>
            <thead>
              <row>
                <entry>
                  <para><emphasis role="bold">Description</emphasis></para>
                </entry>
                <entry>
                  <para><emphasis role="bold">Parameter</emphasis></para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para> <emphasis role="bold">subsystem</emphasis></para>
                </entry>
                <entry>
                  <para> 800000</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">debug mask</emphasis></para>
                </entry>
                <entry>
                  <para> 000010</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">smp_processor_id</emphasis></para>
                </entry>
                <entry>
                  <para> 0</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">seconds.microseconds</emphasis></para>
                </entry>
                <entry>
                  <para> 1081880847.677302</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">stack size</emphasis></para>
                </entry>
                <entry>
                  <para> 1204</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">pid</emphasis></para>
                </entry>
                <entry>
                  <para> 2973</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">host pid (UML only) or zero</emphasis></para>
                </entry>
                <entry>
                  <para> 31070</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">(file:line #:function_name())</emphasis></para>
                </entry>
                <entry>
                  <para> (obd_mount.c:2089:lustre_fill_super())</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">debug message</emphasis></para>
                </entry>
                <entry>
                  <para> kmalloced &apos;*obj&apos;: 24 at a375571c (tot 17447717)</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
      <section remap="h4">
        <title>Lustre Debug Messages Buffer</title>
        <para>Lustre debug messages are maintained in a buffer, with the maximum buffer size specified (in MBs) by the <literal>debug_mb</literal> parameter (<literal>lctl get_param debug_mb</literal>). The buffer is circular, so debug messages are kept until the allocated buffer limit is reached, and then the first messages are overwritten.</para>
      </section>
    </section>
    <section xml:id="dbdoclet.50438274_62472">
      <title><indexterm><primary>debugging</primary><secondary>using lctl</secondary></indexterm>Using the lctl Tool to View Debug Messages</title>
      <para>The <literal>lctl</literal> tool allows debug messages to be filtered based on subsystems and message types to extract information useful for troubleshooting from a kernel debug log. For a command reference, see <xref linkend="dbdoclet.50438219_38274"/>.</para>
      <para>You can use <literal>lctl</literal> to:</para>
      <itemizedlist>
        <listitem>
          <para>Obtain a list of all the types and subsystems:</para>
          <screen>lctl &gt; debug_list <replaceable>subsystems|types</replaceable></screen>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>Filter the debug log:</para>
          <screen>lctl &gt; filter <replaceable>subsystem_name|debug_type</replaceable></screen>
        </listitem>
      </itemizedlist>
      <note>
        <para>When <literal>lctl</literal> filters, it removes unwanted lines from the displayed output. This does not affect the contents of the debug log in the kernel&apos;s memory. As a result, you can print the log many times with different filtering levels without worrying about losing data.</para>
      </note>
      <itemizedlist>
        <listitem>
          <para>Show debug messages belonging to certain subsystem or type:</para>
          <screen>lctl &gt; show <replaceable>subsystem_name|debug_type</replaceable></screen>
          <para><literal>debug_kernel</literal> pulls the data from the kernel logs, filters it appropriately, and displays or saves it as per the specified options</para>
          <screen>lctl &gt; debug_kernel [<replaceable>output filename</replaceable>]</screen>
          <para>If the debugging is being done on User Mode Linux (UML), it might be useful to save the logs on the host machine so that they can be used at a later time.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>Filter a log on disk, if you already have a debug log saved to disk (likely from a crash):</para>
          <screen>lctl &gt; debug_file <replaceable>input_file</replaceable> [<replaceable>output_file</replaceable>] </screen>
          <para>During the debug session, you can add markers or breaks to the log for any reason:</para>
          <screen>lctl &gt; mark [marker text] </screen>
          <para>The marker text defaults to the current date and time in the debug log (similar to the example shown below):</para>
          <screen>DEBUG MARKER: Tue Mar 5 16:06:44 EST 2002 
</screen>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>Completely flush the kernel debug buffer:</para>
          <screen>lctl &gt; clear
</screen>
        </listitem>
      </itemizedlist>
      <note>
        <para>Debug messages displayed with <literal>lctl</literal> are also subject to the kernel debug masks; the filters are additive.</para>
      </note>
      <section remap="h4">
        <title><indexterm><primary>debugging</primary><secondary>lctl example</secondary></indexterm>Sample <literal>lctl</literal> Run</title>
        <para>Below is a sample run using the <literal>lctl</literal> command.</para>
        <screen>bash-2.04# ./lctl 
lctl &gt; debug_kernel /tmp/lustre_logs/log_all 
Debug log: 324 lines, 324 kept, 0 dropped. 
lctl &gt; filter trace 
Disabling output of type &quot;trace&quot; 
lctl &gt; debug_kernel /tmp/lustre_logs/log_notrace 
Debug log: 324 lines, 282 kept, 42 dropped. 
lctl &gt; show trace 
Enabling output of type &quot;trace&quot; 
lctl &gt; filter portals 
Disabling output from subsystem &quot;portals&quot; 
lctl &gt; debug_kernel /tmp/lustre_logs/log_noportals 
Debug log: 324 lines, 258 kept, 66 dropped. 
</screen>
      </section>
    </section>
    <section remap="h3">
      <title>Dumping the Buffer to a File (<literal>debug_daemon</literal>)</title>
      <para>The <literal>lctl debug_daemon</literal> command is used to continuously dump the <literal>debug_kernel</literal> buffer to a user-specified file. This functionality uses a kernel thread to continuously dump the messages from the kernel debug log, so that much larger debug logs can be saved over a longer time than would fit in the kernel ringbuffer.</para>
      <para>The <literal>debug_daemon</literal> is highly dependent on file system write speed. File system write operations may not be fast enough to flush out all of the <literal>debug_buffer</literal> if the Lustre file system is under heavy system load and continues to log debug messages to the <literal>debug_buffer</literal>. The <literal>debug_daemon</literal> will write the message <literal>DEBUG MARKER: Trace buffer full</literal> into the <literal>debug_buffer</literal> to indicate the <literal>debug_buffer</literal> contents are overlapping before the <literal>debug_daemon</literal> flushes data to a file.</para>
      <para>Users can use the <literal>lctl debug_daemon</literal> command to start or stop the Lustre daemon from dumping the <literal>debug_buffer</literal> to a file.</para>
      <section remap="h4">
        <title><literal>lctl debug_daemon</literal> Commands</title>
        <para>To initiate the <literal>debug_daemon</literal> to start dumping the <literal>debug_buffer</literal> into a file, run as the root user:</para>
        <screen>lctl debug_daemon start <replaceable>filename</replaceable> [<replaceable>megabytes</replaceable>]</screen>
        <para>The debug log will be written to the specified filename from the kernel.  The file will be limited to the optionally specified number of megabytes.</para>
        <para>The daemon wraps around and dumps data to the beginning of the file when the output file size is over the limit of the user-specified file size. To decode the dumped file to ASCII and sort the log entries by time, run:</para>
        <screen>lctl debug_file <replaceable>filename</replaceable> &gt; <replaceable>newfile</replaceable></screen>
        <para>The output is internally sorted by the <literal>lctl</literal> command.</para>
        <para>To stop the <literal>debug_daemon</literal> operation and flush the file output, run:</para>
        <screen>lctl debug_daemon stop</screen>
        <para>Otherwise, <literal>debug_daemon</literal> is shut down as part of the Lustre file system shutdown process. Users can restart <literal>debug_daemon</literal> by using start command after each stop command issued.</para>
        <para>This is an example using <literal>debug_daemon</literal> with the interactive mode of <literal>lctl</literal> to dump debug logs to a 40 MB file.</para>
        <screen>lctl</screen>
        <screen>lctl &gt; debug_daemon start /var/log/lustre.40.bin 40 </screen>
        <screen><replaceable>run filesystem operations to debug</replaceable></screen>
        <screen>lctl &gt; debug_daemon stop </screen>
        <screen>lctl &gt; debug_file /var/log/lustre.bin /var/log/lustre.log</screen>
        <para>To start another daemon with an unlimited file size, run:</para>
        <screen>lctl &gt; debug_daemon start /var/log/lustre.bin </screen>
        <para>The text message <literal>*** End of debug_daemon trace log ***</literal> appears at the end of each output file.</para>
      </section>
    </section>
    <section remap="h3">
      <title><indexterm><primary>debugging</primary><secondary>kernel debug log</secondary></indexterm>Controlling Information Written to the Kernel Debug Log</title>
      <para>The <literal>lctl set_param subsystem_debug=<replaceable>subsystem_mask</replaceable></literal> and <literal>lctl set_param debug=<replaceable>debug_mask</replaceable></literal> are used to determine which information is written to the debug log. The subsystem_debug mask determines the information written to the log based on the functional area of the code (such as lnet, osc, or ldlm). The debug mask controls information based on the message type (such as info, error, trace, or malloc). For a complete list of possible debug masks use the <literal>lctl debug_list types</literal> command.</para>
      <para>To turn off Lustre debugging completely:</para>
      <screen>lctl set_param debug=0 </screen>
      <para>To turn on full Lustre debugging:</para>
      <screen>lctl set_param debug=-1 </screen>
      <para>To list all possible debug masks:</para>
      <screen>lctl debug_list types</screen>
      <para>To log only messages related to network communications:</para>
      <screen>lctl set_param debug=net </screen>
      <para>To turn on logging of messages related to network communications and existing debug flags:</para>
      <screen>lctl set_param debug=+net </screen>
      <para>To turn off network logging with changing existing flags:</para>
      <screen>lctl set_param debug=-net </screen>
      <para>The various options available to print to kernel debug logs are listed in <literal>libcfs/include/libcfs/libcfs.h</literal></para>
    </section>
    <section remap="h3">
      <title><indexterm><primary>debugging</primary><secondary>using strace</secondary></indexterm>Troubleshooting with <literal>strace</literal></title>
      <para>The <literal>strace</literal> utility provided with the Linux distribution enables system calls to be traced by intercepting all the system calls made by a process and recording the system call name, arguments, and return values.</para>
      <para>To invoke <literal>strace</literal> on a program, enter:</para>
      <screen>$ strace <replaceable>program</replaceable> <replaceable>[arguments]</replaceable> </screen>
      <para>Sometimes, a system call may fork child processes. In this situation, use the <literal>-f</literal> option of <literal>strace</literal> to trace the child processes:</para>
      <screen>$ strace -f <replaceable>program</replaceable> <replaceable>[arguments]</replaceable> </screen>
      <para>To redirect the <literal>strace</literal> output to a file, enter:</para>
      <screen>$ strace -o <replaceable>filename</replaceable> <replaceable>program</replaceable> <replaceable>[arguments]</replaceable> </screen>
      <para>Use the <literal>-ff</literal> option, along with <literal>-o</literal>, to save the trace output in <literal>filename.pid</literal>, where <literal>pid</literal> is the process ID of the process being traced. Use the <literal>-ttt</literal> option to timestamp all lines in the strace output, so they can be correlated to operations in the lustre kernel debug log.</para>
    </section>
    <section remap="h3">
      <title><indexterm><primary>debugging</primary><secondary>disk contents</secondary></indexterm>Looking at Disk Content</title>
      <para>In a Lustre file system, the inodes on the metadata server contain extended attributes
        (EAs) that store information about file striping. EAs contain a list of all object IDs and
        their locations (that is, the OST that stores them). The <literal>lfs</literal> tool can be
        used to obtain this information for a given file using the <literal>getstripe</literal>
        subcommand. Use a corresponding <literal>lfs setstripe</literal> command to specify striping
        attributes for a new file or directory.</para>
      <para>The <literal>lfs getstripe</literal> command takes a Lustre filename as input and lists
        all the objects that form a part of this file. To obtain this information for the file
          <literal>/mnt/testfs/frog</literal> in a Lustre file system, run:</para>
      <screen>$ lfs getstripe /mnt/testfs/frog
lmm_stripe_count:   2
lmm_stripe_size:    1048576
lmm_pattern:        1
lmm_layout_gen:     0
lmm_stripe_offset:  2
        obdidx           objid          objid           group
             2          818855        0xc7ea7               0
             0          873123        0xd52a3               0
        </screen>
      <para>The <literal>debugfs</literal> tool is provided in the
          <literal>e2fsprogs</literal> package. It can be used for interactive
          debugging of an <literal>ldiskfs</literal> file system. The
          <literal>debugfs</literal> tool can either be used to check status or
          modify information in the file system. In a Lustre file system, all
          objects that belong to a file are stored in an underlying
          <literal>ldiskfs</literal> file system on the OSTs. The file system
          uses the object IDs as the file names. Once the object IDs are known,
          use the <literal>debugfs</literal> tool to obtain the attributes of
          all objects from different OSTs.</para>
      <para>A sample run for the <literal>/mnt/testfs/frog</literal> file used
          in the above example is shown here:</para>
      <screen>$ debugfs -c -R "stat O/0/d$((818855 % 32))/818855" /dev/vgmyth/lvmythost2

debugfs 1.41.90.wc3 (28-May-2011)
/dev/vgmyth/lvmythost2: catastrophic mode - not reading inode or group bitmaps
Inode: 227649   Type: regular    Mode:  0666   Flags: 0x80000
Generation: 1375019198    Version: 0x0000002f:0000728f
User:  1000   Group:  1000   Size: 2800
File ACL: 0    Directory ACL: 0
Links: 1   Blockcount: 8
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x4e177fe5:00000000 -- Fri Jul  8 16:08:37 2011
 atime: 0x4d2e2397:00000000 -- Wed Jan 12 14:56:39 2011
 mtime: 0x4e177fe5:00000000 -- Fri Jul  8 16:08:37 2011
crtime: 0x4c3b5820:a364117c -- Mon Jul 12 12:00:00 2010
Size of extra inode fields: 28
Extended attributes stored in inode body: 
  fid = "08 80 24 00 00 00 00 00 28 8a e7 fc 00 00 00 00 a7 7e 0c 00 00 00 00 00
 00 00 00 00 00 00 00 00 " (32)
  fid: objid=818855 seq=0 parent=[0x248008:0xfce78a28:0x0] stripe=0
EXTENTS:
(0):63331288
      </screen>
    </section>
    <section remap="h3">
      <title>Finding the Lustre UUID of an OST</title>
      <para>To determine the Lustre UUID of an OST disk (for example, if you mix up the cables on your OST devices or the SCSI bus numbering suddenly changes and the SCSI devices get new names), it is possible to extract this from the last_rcvd file using debugfs:</para>
      <screen>debugfs -c -R "dump last_rcvd /tmp/last_rcvd" /dev/sdc
strings /tmp/last_rcvd | head -1
myth-OST0004_UUID
      </screen>
      <para>It is also possible (and easier) to extract this from the file system label using the
          <literal>dumpe2fs</literal> command:</para>
      <screen>dumpe2fs -h /dev/sdc | grep volume
dumpe2fs 1.41.90.wc3 (28-May-2011)
Filesystem volume name:   myth-OST0004
      </screen>
      <para>The debugfs and dumpe2fs commands are well documented in the <literal>debugfs(8)</literal> and <literal>dumpe2fs(8)</literal> manual pages.</para>
    </section>
    <section remap="h3">
      <title>Printing Debug Messages to the Console</title>
      <para>To dump debug messages to the console (<literal>/var/log/messages</literal>), set the corresponding debug mask in the <literal>printk</literal> flag:</para>
      <screen>lctl set_param printk=-1 </screen>
      <para>This slows down the system dramatically. It is also possible to selectively enable or disable this capability for particular flags using:<literal>lctl set_param printk=+vfstrace</literal> and <literal>lctl set_param printk=-vfstrace </literal>.</para>
      <para>It is possible to disable warning, error, and console messages, though it is strongly recommended to have something like <literal>lctl debug_daemon</literal> running to capture this data to a local file system for failure detection purposes.</para>
    </section>
    <section remap="h3">
      <title>Tracing Lock Traffic</title>
      <para>The Lustre software provides a specific debug type category for tracing lock traffic.
        Use:</para>
      <screen>lctl&gt; filter all_types 
lctl&gt; show dlmtrace 
lctl&gt; debug_kernel [<replaceable>filename</replaceable>] </screen>
    </section>
    <section remap="h3">
      <title>Controlling Console Message Rate Limiting</title>
      <para>Some console messages which are printed by Lustre are rate limited.  When such messages are printed, they may be followed by a message saying "Skipped N previous similar message(s)," where N is the number of messages skipped.  This rate limiting can be completely disabled by a libcfs module parameter called <literal>libcfs_console_ratelimit</literal>.  To disable console message rate limiting, add this line to <literal>/etc/modprobe.d/lustre.conf</literal> and then reload Lustre modules.</para>
      <screen>options libcfs libcfs_console_ratelimit=0</screen>
      <para>It is also possible to set the minimum and maximum delays between rate-limited console messages using the module parameters <literal>libcfs_console_max_delay</literal> and <literal>libcfs_console_min_delay</literal>.  Set these in <literal>/etc/modprobe.d/lustre.conf</literal> and then reload Lustre modules.  Additional information on libcfs module parameters is available via <literal>modinfo</literal>:</para>
      <screen>modinfo libcfs</screen>
    </section>
  </section>
  <section xml:id="dbdoclet.50438274_80443">
    <title><indexterm><primary>debugging</primary><secondary>developers tools</secondary></indexterm>Lustre Debugging for Developers</title>
    <para>The procedures in this section may be useful to developers debugging Lustre source
      code.</para>
    <section remap="h3">
      <title>Adding Debugging to the Lustre Source Code</title>
      <para>The debugging infrastructure provides a number of macros that can be used in Lustre source code to aid in debugging or reporting serious errors.</para>
      <para>To use these macros, you will need to set the <literal>DEBUG_SUBSYSTEM</literal> variable at the top of the file as shown below:</para>
      <screen>#define DEBUG_SUBSYSTEM S_PORTALS</screen>
      <para>A list of available macros with descriptions is provided in the table below.</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Macro</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>LBUG()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>A panic-style assertion in the kernel which causes the Lustre file system to
                  dump its circular log to the <literal>/tmp/lustre-log</literal> file. This file
                  can be retrieved after a reboot. <literal>LBUG()</literal> freezes the thread to
                  allow capture of the panic stack. A system reboot is needed to clear the
                  thread.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>LASSERT()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Validates a given expression as true, otherwise calls LBUG(). The failed expression is printed on the console, although the values that make up the expression are not printed.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>LASSERTF()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Similar to <literal>LASSERT()</literal> but allows a free-format message to be printed, like <literal>printf/printk</literal>.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>CDEBUG()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>The basic, most commonly used debug macro that takes just one more argument than standard <literal>printf()</literal> - the debug type. This message adds to the debug log with the debug mask set accordingly. Later, when a user retrieves the log for troubleshooting, they can filter based on this type.</para>
                <para><literal>CDEBUG(D_INFO, &quot;debug message: rc=%d\n&quot;, number);</literal></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>CDEBUG_LIMIT()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Behaves similarly to <literal>CDEBUG()</literal>, but rate limits this message when printing to the console (for <literal>D_WARN</literal>, <literal>D_ERROR</literal>, and <literal>D_CONSOLE</literal> message types. This is useful for messages that use a variable debug mask:</para>
                <para><literal>CDEBUG(mask, &quot;maybe bad: rc=%d\n&quot;, rc);</literal></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>CERROR()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Internally using <literal>CDEBUG_LIMIT(D_ERROR, ...)</literal>, which unconditionally prints the message in the debug log and to the console. This is appropriate for serious errors or fatal conditions.  Messages printed to the console are prefixed with <literal>LustreError:</literal>, and are rate-limited, to avoid flooding the console with duplicates.</para>
                <para><literal>CERROR(&quot;Something bad happened: rc=%d\n&quot;, rc);</literal></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>CWARN()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Behaves similarly to <literal>CERROR()</literal>, but prefixes the messages with <literal>Lustre:</literal>. This is appropriate for important, but not fatal conditions.  Messages printed to the console are rate-limited.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>CNETERR()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Behaves similarly to <literal>CERROR()</literal>, but prints error messages for LNet if <literal>D_NETERR</literal> is set in the <literal>debug</literal> mask. This is appropriate for serious networking errors. Messages printed to the console are rate-limited.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>DEBUG_REQ()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Prints information about the given <literal>ptlrpc_request</literal> structure.</para>
                <para><literal>DEBUG_REQ(D_RPCTRACE, req, &quot;"Handled RPC: rc=%d\n&quot;, rc);</literal></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>ENTRY</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Add messages to the entry of a function to aid in call tracing (takes no arguments). When using these macros, cover all exit conditions with a single <literal>EXIT</literal>, <literal>GOTO()</literal>, or <literal>RETURN()</literal> macro to avoid confusion when the debug log reports that a function was entered, but never exited.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>EXIT</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Mark the exit of a function, to match <literal>ENTRY</literal> (takes no arguments).</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>GOTO()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Mark when code jumps via <literal>goto</literal> to the end of a function, to match <literal>ENTRY</literal>, and prints out the goto label and function return code in signed and unsigned decimal, and hexadecimal format.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>RETURN()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Mark the exit of a function, to match <literal>ENTRY</literal>, and prints out the function return code in signed and unsigned decimal, and hexadecimal format.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>LDLM_DEBUG()</literal>
                  </emphasis></para>
                <para> <emphasis role="bold">
                    <literal>LDLM_DEBUG_NOLOCK()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Used when tracing LDLM locking operations. These macros build a thin trace that shows the locking requests on a node, and can also be linked across the client and server node using the printed lock handles.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>OBD_FAIL_CHECK()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Allows insertion of failure points into the Lustre source code. This is useful
                  to generate regression tests that can hit a very specific sequence of events. This
                  works in conjunction with &quot;<literal>lctl set_param
                      fail_loc=<replaceable>fail_loc</replaceable></literal>&quot; to set a specific
                  failure point for which a given <literal>OBD_FAIL_CHECK()</literal> will
                  test.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>OBD_FAIL_TIMEOUT()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Similar to <literal>OBD_FAIL_CHECK()</literal>. Useful to simulate hung, blocked or busy processes or network devices. If the given <literal>fail_loc</literal> is hit, <literal>OBD_FAIL_TIMEOUT()</literal> waits for the specified number of seconds.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>OBD_RACE()</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Similar to <literal>OBD_FAIL_CHECK()</literal>. Useful to have multiple processes execute the same code concurrently to provoke locking races. The first process to hit <literal>OBD_RACE()</literal> sleeps until a second process hits <literal>OBD_RACE()</literal>, then both processes continue.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>OBD_FAIL_ONCE</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>A flag set on a <literal>fail_loc</literal> breakpoint to cause the <literal>OBD_FAIL_CHECK()</literal> condition to be hit only one time. Otherwise, a <literal>fail_loc</literal> is permanent until it is cleared with &quot;<literal>lctl set_param fail_loc=0</literal>&quot;.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>OBD_FAIL_RAND</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>A flag set on a <literal>fail_loc</literal> breakpoint to cause <literal>OBD_FAIL_CHECK()</literal> to fail randomly; on average every (1 / fail_val) times.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>OBD_FAIL_SKIP</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>A flag set on a <literal>fail_loc</literal> breakpoint to cause <literal>OBD_FAIL_CHECK()</literal> to succeed <literal>fail_val</literal> times, and then fail permanently or once with <literal>OBD_FAIL_ONCE</literal>.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>OBD_FAIL_SOME</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>A flag set on <literal>fail_loc</literal> breakpoint to cause <literal>OBD_FAIL_CHECK</literal> to fail <literal>fail_val</literal> times, and then succeed.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section remap="h3">
      <title>Accessing the <literal>ptlrpc</literal> Request History</title>
      <para>Each service maintains a request history, which can be useful for first occurrence troubleshooting.</para>
      <para><literal>ptlrpc</literal> is an RPC protocol layered on LNet that deals with stateful servers and has semantics and built-in support for recovery.</para>
      <para>The ptlrpc request history works as follows:</para>
      <orderedlist>
        <listitem>
          <para><literal>request_in_callback()</literal> adds the new request to the service&apos;s request history.</para>
        </listitem>
        <listitem>
          <para>When a request buffer becomes idle, it is added to the service&apos;s request buffer history list.</para>
        </listitem>
        <listitem>
          <para>Buffers are culled from the service request buffer history if it has grown above <literal>req_buffer_history_max</literal> and its reqs are removed from the service request history.</para>
        </listitem>
      </orderedlist>
      <para>Request history is accessed and controlled using the following /proc files under the service directory:</para>
      <itemizedlist>
        <listitem>
          <para><literal>req_buffer_history_len </literal></para>
          <para>Number of request buffers currently in the history</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>req_buffer_history_max </literal></para>
          <para>Maximum number of request buffers to keep</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>req_history </literal> </para>
          <para>The request history</para>
        </listitem>
      </itemizedlist>
      <para>Requests in the history include &quot;live&quot; requests that are currently being handled. Each line in <literal>req_history</literal> looks like:</para>
      <screen><replaceable>sequence</replaceable>:<replaceable>target_NID</replaceable>:<replaceable>client_NID</replaceable>:<replaceable>cliet_xid</replaceable>:<replaceable>request_length</replaceable>:<replaceable>rpc_phase</replaceable> <replaceable>service_specific_data</replaceable> </screen>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Parameter</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>seq</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Request sequence number</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>
                    <replaceable>target NID</replaceable>
                  </literal></para>
              </entry>
              <entry>
                <para> Destination <literal>NID</literal> of the incoming request</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>
                    <replaceable>client ID</replaceable>
                  </literal></para>
              </entry>
              <entry>
                <para> Client <literal>PID</literal> and <literal>NID</literal></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> 
                        <literal>
                    <replaceable>xid</replaceable>
                  </literal>
                  </para>
              </entry>
              <entry>
                <para> <literal>rq_xid</literal></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>length</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Size of the request message</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>phase</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para><itemizedlist>
                    <listitem>
                      <para>New (waiting to be handled or could not be unpacked)</para>
                    </listitem>
                    <listitem>
                      <para>Interpret (unpacked or being handled)</para>
                    </listitem>
                    <listitem>
                      <para>Complete (handled)</para>
                    </listitem>
                  </itemizedlist></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>svc specific</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Service-specific request printout. Currently, the only service that does this is the OST (which prints the opcode if the message has been unpacked successfully</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section remap="h3">
      <title><indexterm><primary>debugging</primary><secondary>memory leaks</secondary></indexterm>Finding Memory Leaks Using <literal>leak_finder.pl</literal></title>
      <para>Memory leaks can occur in code when memory has been allocated and then not freed once it is no longer required. The <literal>leak_finder.pl</literal> program provides a way to find memory leaks.</para>
      <para>Before running this program, you must turn on debugging to collect all <literal>malloc</literal> and free entries. Run:</para>
      <screen>lctl set_param debug=+malloc </screen>
      <para>Then complete the following steps:</para>
      <orderedlist>
        <listitem>
          <para>Dump the log into a user-specified log file using lctl (see <xref linkend="dbdoclet.50438274_62472"/>).</para>
        </listitem>
        <listitem>
          <para>Run the leak finder on the newly-created log dump:</para>
          <screen>perl leak_finder.pl <replaceable>ascii-logname</replaceable></screen>
        </listitem>
      </orderedlist>
      <para>The output is:</para>
      <screen>malloced 8bytes at a3116744 (called pathcopy) 
(lprocfs_status.c:lprocfs_add_vars:80) 
freed 8bytes at a3116744 (called pathcopy) 
(lprocfs_status.c:lprocfs_add_vars:80) 
</screen>
      <para>The tool displays the following output to show the leaks found:</para>
      <screen>Leak:32bytes allocated at a23a8fc(service.c:ptlrpc_init_svc:144,debug file line 241)</screen>
    </section>
  </section>
</chapter>
