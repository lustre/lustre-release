<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:lang="en-US" xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" xml:id='lustredebugging'>
  <info>
    <title xml:id='lustredebugging.title'>Lustre Debugging</title>
  </info>

  <para>This chapter describes tips and information to debug Lustre, and includes the following sections:</para>
  <itemizedlist><listitem>
      <para><xref linkend="dbdoclet.50438274_15874"/></para>
    </listitem>

<listitem>
      <para><xref linkend="dbdoclet.50438274_23607"/></para>
    </listitem>

<listitem>
      <para><xref linkend="dbdoclet.50438274_80443"/></para>
    </listitem>

</itemizedlist>

    <section xml:id="dbdoclet.50438274_15874">
      <title>28.1 Diagnostic and Debugging Tools</title>
      <para>A variety of diagnostic and analysis tools are available to debug issues with the Lustre software. Some of these are provided in Linux distributions, while others have been developed and are made available by the Lustre project.</para>
      <section remap="h3">
        <title>28.1.1 Lustre Debugging Tools</title>
        <para>The following in-kernel debug mechanisms are incorporated into the Lustre software:</para>
        <itemizedlist><listitem>
            <para><emphasis role="bold">Debug logs</emphasis>  - A circular debug buffer to which Lustre internal debug messages are written (in contrast to error messages, which are printed to the syslog or console). Entries to the Lustre debug log are controlled by the mask set by /proc/sys/lnet/debug. The log size defaults to 5 MB per CPU but can be increased as a busy system will quickly overwrite 5 MB. When the buffer fills, the oldest information is discarded.</para>
          </listitem>

<listitem>
            <para><emphasis role="bold">Debug daemon</emphasis>  - The debug daemon controls logging of debug messages.</para>
          </listitem>

<listitem>
            <para><emphasis role="bold">/proc/sys/lnet/debug</emphasis>  - This file contains a mask that can be used to delimit the debugging information written out to the kernel debug logs.</para>
          </listitem>

</itemizedlist>
        <para>The following tools are also provided with the Lustre software:</para>
        <itemizedlist><listitem>
                <para><emphasis role="bold">lctl</emphasis>  - This tool is used with the debug_kernel option to manually dump the Lustre debugging log or post-process debugging logs that are dumped automatically. For more information about the lctl tool, see <xref linkend="dbdoclet.50438274_62472"/> and <xref linkend="systemconfigurationutilities"/>(lctl).</para>
          </listitem>

<listitem>
            <para><emphasis role="bold">Lustre subsystem asserts</emphasis>  - A panic-style assertion (LBUG) in the kernel causes Lustre to dump the debug log to the file /tmp/lustre-log.<emphasis>&lt;timestamp&gt;</emphasis> where it can be retrieved after a reboot. For more information, see <link xl:href="LustreTroubleshooting.html#50438198_40669">Viewing Error Messages</link>.</para>
          </listitem>

<listitem>
            <para><emphasis role="bold">lfs</emphasis>  - This utility provides access to the extended attributes (EAs) of a Lustre file (along with other information). For more inforamtion about lfs, see <link xl:href="UserUtilities.html#50438206_94597">lfs</link>.</para>
          </listitem>

</itemizedlist>
      </section>
      <section remap="h3">
        <title>28.1.2 External Debugging Tools</title>
        <para>The tools described in this section are provided in the Linux kernel or are available at an external website. For information about using some of these tools for Lustre debugging, see <link xl:href="LustreDebugging.html#50438274_23607">Lustre Debugging Procedures</link> and <link xl:href="LustreDebugging.html#50438274_80443">Lustre Debugging for Developers</link>.</para>
        <section remap="h4">
          <title>28.1.2.1 Tools for Administrators and Developers</title>
          <para>Some general debugging tools provided as a part of the standard Linux distro are:</para>
          <itemizedlist><listitem>
              <para><emphasis role="bold">strace</emphasis> . This tool allows a system call to be traced.</para>
            </listitem>

<listitem>
              <para><emphasis role="bold">/var/log/messages</emphasis> . syslogd prints fatal or serious messages at this log.</para>
            </listitem>

<listitem>
              <para><emphasis role="bold">Crash dumps</emphasis> . On crash-dump enabled kernels, sysrq c produces a crash dump. Lustre enhances this crash dump with a log dump (the last 64 KB of the log) to the console.</para>
            </listitem>

<listitem>
              <para><emphasis role="bold">debugfs</emphasis> . Interactive file system debugger.</para>
            </listitem>

</itemizedlist>
          <para>The following logging and data collection tools can be used to collect information for debugging Lustre kernel issues:</para>
          <itemizedlist><listitem>
              <para><emphasis role="bold">kdump</emphasis> . A Linux kernel crash utility useful for debugging a system running Red Hat Enterprise Linux. For more information about kdump, see the Red Hat knowledge base article <link xl:href="http://kbase.redhat.com/faq/docs/DOC-6039">How do I configure kexec/kdump on Red Hat Enterprise Linux 5?</link>. To download kdump, go to the <link xl:href="http://fedoraproject.org/wiki/SystemConfig/kdump#Download">Fedora Project Download</link> site.</para>
            </listitem>

<listitem>
              <para><emphasis role="bold">netconsole</emphasis> . Enables kernel-level network logging over UDP. A system requires (SysRq) allows users to collect relevant data through netconsole.</para>
            </listitem>

<listitem>
              <para><emphasis role="bold">netdump</emphasis> . A crash dump utility from Red Hat that allows memory images to be dumped over a network to a central server for analysis. The netdump utility was replaced by kdump in RHEL 5. For more information about netdump, see <link xl:href="http://www.redhat.com/support/wpapers/redhat/netdump/">Red Hat, Inc.&apos;s Network Console and Crash Dump Facility</link>.</para>
            </listitem>

</itemizedlist>
        </section>
        <section remap="h4">
          <title>28.1.2.2 Tools for Developers</title>
          <para>The tools described in this section may be useful for debugging Lustre in a development environment.</para>
          <para>Of general interest is:</para>
          <itemizedlist><listitem>
              <para><emphasis role="bold">leak_finder.pl</emphasis> . This program provided with Lustre is useful for finding memory leaks in the code.</para>
            </listitem>

</itemizedlist>
          <para>A virtual machine is often used to create an isolated development and test environment. Some commonly-used virtual machines are:</para>
          <itemizedlist><listitem>
              <para><emphasis role="bold">VirtualBox Open Source Edition</emphasis> . Provides enterprise-class virtualization capability for all major platforms and is available free at <link xl:href="http://www.sun.com/software/products/virtualbox/get.jsp?intcmp=2945">Get Sun VirtualBox</link>.</para>
            </listitem>

<listitem>
              <para><emphasis role="bold">VMware Server</emphasis> . Virtualization platform available as free introductory software at <link xl:href="http://downloads.vmware.com/d/info/datacenter_downloads/vmware_server/2_0">Download VMware Server</link>.</para>
            </listitem>

<listitem>
              <para><emphasis role="bold">Xen</emphasis> . A para-virtualized environment with virtualization capabilities similar to VMware Server and Virtual Box. However, Xen allows the use of modified kernels to provide near-native performance and the ability to emulate shared storage. For more information, go to <link xl:href="http://xen.org/">xen.org</link>.</para>
            </listitem>

</itemizedlist>
          <para>A variety of debuggers and analysis tools are available including:</para>
          <itemizedlist><listitem>
              <para><emphasis role="bold">kgdb</emphasis> . The Linux Kernel Source Level Debugger kgdb is used in conjunction with the GNU Debugger gdb for debugging the Linux kernel. For more information about using kgdb with gdb, see <link xl:href="http://www.linuxtopia.org/online_books/redhat_linux_debugging_with_gdb/running.html">Chapter 6. Running Programs Under gdb</link> in the <emphasis>Red Hat Linux 4 Debugging with GDB</emphasis> guide.</para>
            </listitem>

<listitem>
              <para><emphasis role="bold">crash</emphasis> . Used to analyze saved crash dump data when a system had panicked or locked up or appears unresponsive. For more information about using crash to analyze a crash dump, see:</para>
              <itemizedlist><listitem>
                  <para> Red Hat Magazine article: <link xl:href="http://magazine.redhat.com/2007/08/15/a-quick-overview-of-linux-kernel-crash-dump-analysis/">A quick overview of Linux kernel crash dump analysis</link></para>
                </listitem>

<listitem>
                  <para><link xl:href="http://people.redhat.com/anderson/crash_whitepaper/#EXAMPLES">Crash Usage: A Case Study</link>  from the white paper <emphasis>Red Hat Crash Utility</emphasis> by David Anderson</para>
                </listitem>

<listitem>
                  <para> Kernel Trap forum entry: <link xl:href="http://kerneltrap.org/node/5758">Linux: Kernel Crash Dumps</link></para>
                </listitem>

<listitem>
                  <para> White paper: <link xl:href="http://www.google.com/url?sa=t&amp;source=web&amp;ct=res&amp;cd=8&amp;ved=0CCUQFjAH&amp;url=http%3A%2F%2Fwww.kernel.sg%2Fpapers%2Fcrash-dump-analysis.pdf&amp;rct=j&amp;q=redhat+crash+dump&amp;ei=6aQBS-ifK4T8tAPcjdiHCw&amp;usg=AFQjCNEk03E3GDtAsawG3gfpwc1gGNELAg">A Quick Overview of Linux Kernel Crash Dump Analysis</link></para>
                </listitem>

</itemizedlist>
            </listitem>
</itemizedlist>
        </section>
      </section>
    </section>
    <section xml:id="dbdoclet.50438274_23607">
      <title>28.2 Lustre Debugging Procedures</title>
      <para>The procedures below may be useful to administrators or developers debugging a Lustre files system.</para>
      <section remap="h3">
        <title>28.2.1 Understanding the Lustre Debug Messaging Format</title>
        <para>Lustre debug messages are categorized by originating sybsystem, message type, and locaton in the source code. For a list of subsystems and message types, see <xref linkend="dbdoclet.50438274_57603"/>.</para>
                <note><para>For a current list of subsystems and debug message types, see lnet/include/libcfs/libcfs.h in the Lustre tree</para></note>
                <para>The elements of a Lustre debug message are described in <xref linkend="dbdoclet.50438274_57177"/>Format of Lustre Debug Messages.</para>
        <section remap="h4">
          <title>28.2.1.1 <anchor xml:id="dbdoclet.50438274_57603" xreflabel=""/>Lustre <anchor xml:id="dbdoclet.50438274_marker-1295746" xreflabel=""/>Debug Messages</title>
          <para>Each Lustre debug message has the tag of the subsystem it originated in, the message type, and the location in the source code. The subsystems and debug types used in Lustre are as follows:</para>
          <itemizedlist><listitem>
              <para>  Standard Subsystems:</para>
            </listitem>

</itemizedlist>
          <para> mdc, mds, osc, ost, obdclass, obdfilter, llite, ptlrpc, portals, lnd, ldlm, lov</para>
          <itemizedlist><listitem>
              <para>  Debug Types:</para>
            </listitem>
<listitem>
              <para><informaltable frame="all">
                  <tgroup cols="2">
                    <colspec colname="c1" colwidth="50*"/>
                    <colspec colname="c2" colwidth="50*"/>
                    <thead>
                      <row>
                        <entry><para><emphasis role="bold">Types</emphasis></para></entry>
                        <entry><para><emphasis role="bold">Description</emphasis></para></entry>
                      </row>
                    </thead>
                    <tbody>
                      <row>
                        <entry><para> <emphasis role="bold">trace</emphasis></para></entry>
                        <entry><para> Entry/Exit markers</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">dlmtrace</emphasis></para></entry>
                        <entry><para> Locking-related information</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">inode</emphasis></para></entry>
                        <entry><para>  </para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">super</emphasis></para></entry>
                        <entry><para>  </para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">ext2</emphasis></para></entry>
                        <entry><para> Anything from the ext2_debug</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">malloc</emphasis></para></entry>
                        <entry><para> Print malloc or free information</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">cache</emphasis></para></entry>
                        <entry><para> Cache-related information</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">info</emphasis></para></entry>
                        <entry><para> General information</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">ioctl</emphasis></para></entry>
                        <entry><para> IOCTL-related information</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">blocks</emphasis></para></entry>
                        <entry><para> Ext2 block allocation information</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">net</emphasis></para></entry>
                        <entry><para> Networking</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">warning</emphasis></para></entry>
                        <entry><para>  </para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">buffs</emphasis></para></entry>
                        <entry><para>  </para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">other</emphasis></para></entry>
                        <entry><para>  </para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">dentry</emphasis></para></entry>
                        <entry><para>  </para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">portals</emphasis></para></entry>
                        <entry><para> Entry/Exit markers</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">page</emphasis></para></entry>
                        <entry><para> Bulk page handling</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">error</emphasis></para></entry>
                        <entry><para> Error messages</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">emerg</emphasis></para></entry>
                        <entry><para>  </para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">rpctrace</emphasis></para></entry>
                        <entry><para> For distributed debugging</para></entry>
                      </row>
                      <row>
                        <entry><para> <emphasis role="bold">ha</emphasis></para></entry>
                        <entry><para> Failover and recovery-related information</para></entry>
                      </row>
                    </tbody>
                  </tgroup>
                </informaltable>
</para>
            </listitem>
</itemizedlist>
        </section>
        <section remap="h4">
          <title>28.2.1.2 <anchor xml:id="dbdoclet.50438274_57177" xreflabel=""/>Format of Lustre Debug Messages</title>
          <para>Lustre uses the CDEBUG and CERROR macros to print the debug or error messages. To print the message, the CDEBUG macro uses portals_debug_msg (portals/linux/oslib/debug.c). The message format is described below, along with an example.</para>
          <informaltable frame="all">
            <tgroup cols="2">
              <colspec colname="c1" colwidth="50*"/>
              <colspec colname="c2" colwidth="50*"/>
              <thead>
                <row>
                  <entry><para><emphasis role="bold">Parameter</emphasis></para></entry>
                  <entry><para><emphasis role="bold">Description</emphasis></para></entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><para> <emphasis role="bold">subsystem</emphasis></para></entry>
                  <entry><para> 800000</para></entry>
                </row>
                <row>
                  <entry><para> <emphasis role="bold">debug mask</emphasis></para></entry>
                  <entry><para> 000010</para></entry>
                </row>
                <row>
                  <entry><para> <emphasis role="bold">smp_processor_id</emphasis></para></entry>
                  <entry><para> 0</para></entry>
                </row>
                <row>
                  <entry><para> <emphasis role="bold">sec.used</emphasis></para></entry>
                  <entry><para> 10818808</para><para> 47.677302</para></entry>
                </row>
                <row>
                  <entry><para> <emphasis role="bold">stack size</emphasis></para></entry>
                  <entry><para> 1204:</para></entry>
                </row>
                <row>
                  <entry><para> <emphasis role="bold">pid</emphasis></para></entry>
                  <entry><para> 2973:</para></entry>
                </row>
                <row>
                  <entry><para> <emphasis role="bold">host pid (if uml) or zero</emphasis></para></entry>
                  <entry><para> 31070:</para></entry>
                </row>
                <row>
                  <entry><para> <emphasis role="bold">(file:line #:functional())</emphasis></para></entry>
                  <entry><para> (as_dev.c:144:create_write_buffers())</para></entry>
                </row>
                <row>
                  <entry><para> <emphasis role="bold">debug message</emphasis></para></entry>
                  <entry><para> kmalloced &apos;*obj&apos;: 24 at a375571c (tot 17447717)</para></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section remap="h4">
          <title>28.2.1.3 Lustre <anchor xml:id="dbdoclet.50438274_marker-1295885" xreflabel=""/>Debug Messages Buffer</title>
          <para>Lustre debug messages are maintained in a buffer, with the maximum buffer size specified (in MBs) by the debug_mb parameter (/proc/sys/lnet/debug_mb). The buffer is circular, so debug messages are kept until the allocated buffer limit is reached, and then the first messages are overwritten.</para>
        </section>
      </section>
      <section remap="h3">
        <title>28.2.2 <anchor xml:id="dbdoclet.50438274_62472" xreflabel=""/>Using the lctl Tool to View Debug Messages</title>
        <para>The lctl tool allows debug messages to be filtered based on subsystems and message types to extract information useful for troubleshooting from a kernel debug log. For a command reference, see <link xl:href="SystemConfigurationUtilities.html#50438219_38274">lctl</link>.</para>
        <para>You can use lctl to:</para>
        <itemizedlist><listitem>
            <para> Obtain a list of all the types and subsystems:</para>
          </listitem>

</itemizedlist>
        <screen>lctl &gt; debug_list <emphasis>&lt;subs | types&gt;</emphasis></screen>
        <itemizedlist><listitem>
            <para> Filter the debug log:</para>
          </listitem>

</itemizedlist>
        <screen>lctl &gt; filter <emphasis>&lt;subsystem name | debug type&gt;</emphasis></screen>
                <note><para>When lctl filters, it removes unwanted lines from the displayed output. This does not affect the contents of the debug log in the kernel&apos;s memory. As a result, you can print the log many times with different filtering levels without worrying about losing data.</para></note>

        <itemizedlist><listitem>
            <para> Show debug messages belonging to certain subsystem or type:</para>
          </listitem>

</itemizedlist>
        <screen>lctl &gt; show <emphasis>&lt;subsystem name | debug type&gt;</emphasis></screen>
        <para>debug_kernel pulls the data from the kernel logs, filters it appropriately, and displays or saves it as per the specified options</para>
        <screen>lctl &gt; debug_kernel [<emphasis>output filename</emphasis>]
</screen>
        <para>If the debugging is being done on User Mode Linux (UML), it might be useful to save the logs on the host machine so that they can be used at a later time.</para>
        <itemizedlist><listitem>
            <para> Filter a log on disk, if you already have a debug log saved to disk (likely from a crash):</para>
          </listitem>

</itemizedlist>
        <screen>lctl &gt; debug_file <emphasis>&lt;input filename&gt;</emphasis> [<emphasis>output filename</emphasis>] 
</screen>
        <para>During the debug session, you can add markers or breaks to the log for any reason:</para>
        <screen>lctl &gt; mark [marker text] 
</screen>
        <para>The marker text defaults to the current date and time in the debug log (similar to the example shown below):</para>
        <screen>DEBUG MARKER: Tue Mar 5 16:06:44 EST 2002 
</screen>
        <itemizedlist><listitem>
            <para> Completely flush the kernel debug buffer:</para>
          </listitem>

</itemizedlist>
        <screen>lctl &gt; clear
</screen>
                <note><para>Debug messages displayed with lctl are also subject to the kernel debug masks; the filters are additive.</para></note>
        <section remap="h4">
          <title>28.2.2.1 Sample lctl<anchor xml:id="dbdoclet.50438274_marker-1295914" xreflabel=""/>Run</title>
          <para>Below is a sample run using the lctl command.</para>
          <screen>bash-2.04# ./lctl 
lctl &gt; debug_kernel /tmp/lustre_logs/log_all 
Debug log: 324 lines, 324 kept, 0 dropped. 
lctl &gt; filter trace 
Disabling output of type &quot;trace&quot; 
lctl &gt; debug_kernel /tmp/lustre_logs/log_notrace 
Debug log: 324 lines, 282 kept, 42 dropped. 
lctl &gt; show trace 
Enabling output of type &quot;trace&quot; 
lctl &gt; filter portals 
Disabling output from subsystem &quot;portals&quot; 
lctl &gt; debug_kernel /tmp/lustre_logs/log_noportals 
Debug log: 324 lines, 258 kept, 66 dropped. 
</screen>
        </section>
      </section>
      <section remap="h3">
        <title>28.2.3 Dumping the Buffer to a File (debug_daemon)</title>
        <para>The debug_daemon option is used by lctl to control the dumping of the debug_kernel buffer to a user-specified file. This functionality uses a kernel thread on top of debug_kernel, which works in parallel with the debug_daemon command.</para>
        <para>The debug_daemon is highly dependent on file system write speed. File system write operations may not be fast enough to flush out all of the debug_buffer if the Lustre file system is under heavy system load and continues to CDEBUG to the debug_buffer. The debug_daemon will write the message DEBUG MARKER: Trace buffer full into the debug_buffer to indicate the debug_buffer contents are overlapping before the debug_daemon flushes data to a file.</para>
        <para>Users can use lctlcontrol to start or stop the Lustre daemon from dumping the debug_buffer to a file. Users can also temporarily hold daemon from dumping the file. Use of the debug_daemon sub-command to lctl can provide the same function.</para>
        <section remap="h4">
          <title>28.2.3.1 lctldebug_daemon Commands</title>
          <para>This section describes lctldebug_daemon commands.</para>
          <para>To initiate the debug_daemon to start dumping debug_buffer into a file., enter</para>
          <screen>$ lctl debug_daemon start [{file} {megabytes}]
</screen>
          <para>The file can be a system default file, as shown in /proc/sys/lnet/debug_path. After Lustre starts, the default path is /tmp/lustre-log-$HOSTNAME. Users can specify a new filename for debug_daemon to output debug_buffer. The new file name shows up in /proc/sys/lnet/debug_path. Megabytes is the limitation of the file size in MBs.</para>
          <para>The daemon wraps around and dumps data to the beginning of the file when the output file size is over the limit of the user-specified file size. To decode the dumped file to ASCII and order the log entries by time, run:</para>
          <screen>lctl debug_file {file} &gt; {newfile}
</screen>
          <para>The output is internally sorted by the lctl command using quicksort.</para>
          <para>To completely shut down the debug_daemon operation and flush the file output, enter:</para>
          <screen>debug_daemon stop
</screen>
          <para>Otherwise, debug_daemon is shut down as part of the Lustre file system shutdown process. Users can restart debug_daemon by using start command after each stop command issued.</para>
          <para>This is an example using debug_daemon with the interactive mode of lctl to dump debug logs to a 10 MB file.</para>
          <screen>#~/utils/lctl
</screen>
          <para>To start the daemon to dump debug_buffer into a 40 MB /tmp/dump file, enter:</para>
          <screen>lctl &gt; debug_daemon start /trace/log 40 
</screen>
          <para>To completely shut down the daemon, enter:</para>
          <screen>lctl &gt; debug_daemon stop 
</screen>
          <para>To start another daemon with an unlimited file size, enter:</para>
          <screen>lctl &gt; debug_daemon start /tmp/unlimited 
</screen>
          <para>The text message *** End of debug_daemon trace log *** appears at the end of each output file.</para>
        </section>
      </section>
      <section remap="h3">
        <title>28.2.4 Controlling Information Written to the Kernel <anchor xml:id="dbdoclet.50438274_marker-1295955" xreflabel=""/>Debug Log</title>
        <para>Masks are provided in /proc/sys/lnet/subsystem_debug and /proc/sys/lnet/debug to be used with the systctl command to determine what information is to be written to the debug log. The subsystem_debug mask determines the information written to the log based on the subsystem (such as iobdfilter, net, portals, or OSC). The debug mask controls information based on debug type (such as info, error, trace, or alloc).</para>
        <para>To turn off Lustre debugging completely:</para>
        <screen>sysctl -w lnet.debug=0 
</screen>
        <para>To turn on full Lustre debugging:</para>
        <screen>sysctl -w lnet.debug=-1 
</screen>
        <para>To turn on logging of messages related to network communications:</para>
        <screen>sysctl -w lnet.debug=net 
</screen>
        <para>To turn on logging of messages related to network communications and existing debug flags:</para>
        <screen>sysctl -w lnet.debug=+net 
</screen>
        <para>To turn off network logging with changing existing flags:</para>
        <screen>sysctl -w lnet.debug=-net 
</screen>
        <para>The various options available to print to kernel debug logs are listed in lnet/include/libcfs/libcfs.h</para>
      </section>
      <section remap="h3">
        <title>28.2.5 <anchor xml:id="dbdoclet.50438274_26909" xreflabel=""/>Troubleshooting with strace<anchor xml:id="dbdoclet.50438274_marker-1295969" xreflabel=""/></title>
        <para>The strace utility provided with the Linux distribution enables system calls to be traced by intercepting all the system calls made by a process and recording the system call name, aruguments, and return values.</para>
        <para>To invoke strace on a program, enter:</para>
        <screen>$ strace <emphasis>&lt;program&gt; &lt;args&gt;</emphasis> 
</screen>
        <para>Sometimes, a system call may fork child processes. In this situation, use the -f option of strace to trace the child processes:</para>
        <screen>$ strace -f <emphasis>&lt;program&gt; &lt;args&gt;</emphasis> 
</screen>
        <para>To redirect the strace output to a file, enter:</para>
        <screen>$ strace -o <emphasis>&lt;filename&gt; &lt;program&gt; &lt;args&gt;</emphasis> 
</screen>
        <para>Use the -ff option, along with -o, to save the trace output in filename.pid, where pid is the process ID of the process being traced. Use the -ttt option to timestamp all lines in the strace output, so they can be correlated to operations in the lustre kernel debug log.</para>
        <para>If the debugging is done in UML, save the traces on the host machine. In this example, hostfs is mounted on /r:</para>
        <screen>$ strace -o /r/tmp/vi.strace 
</screen>
      </section>
      <section remap="h3">
        <title>28.2.6 <anchor xml:id="dbdoclet.50438274_54455" xreflabel=""/>Looking at Disk <anchor xml:id="dbdoclet.50438274_marker-1295982" xreflabel=""/>Content</title>
        <para>In Lustre, the inodes on the metadata server contain extended attributes (EAs) that store information about file striping. EAs contain a list of all object IDs and their locations (that is, the OST that stores them). The lfs tool can be used to obtain this information for a given file using the getstripe subcommand. Use a corresponding lfs setstripe command to specify striping attributes for a new file or directory.</para>
        <para>The lfsgetstripe utility is written in C; it takes a Lustre filename as input and lists all the objects that form a part of this file. To obtain this information for the file /mnt/lustre/frog in Lustre file system, run:</para>
        <screen>$ lfs getstripe /mnt/lustre/frog
$
   obdix                           objid
   0                               17
   1                               4
</screen>
        <para>The debugfs tool is provided in the e2fsprogs package. It can be used for interactive debugging of an ldiskfs file system. The debugfs tool can either be used to check status or modify information in the file system. In Lustre, all objects that belong to a file are stored in an underlying ldiskfs file system on the OSTs. The file system uses the object IDs as the file names. Once the object IDs are known, use the debugfs tool to obtain the attributes of all objects from different OSTs.</para>
        <para>A sample run for the /mnt/lustre/frog file used in the above example is shown here:</para>
        <screen>     $ debugfs -c /tmp/ost1
   debugfs: cd O
   debugfs: cd 0                                   /* for files in group 0 \
*/
   debugfs: cd d&lt;objid % 32&gt;
   debugfs: stat &lt;objid&gt;                             /* for getattr on object\
 */
   debugfs: quit
## Suppose object id is 36, then follow the steps below:
   $ debugfs /tmp/ost1
   debugfs: cd O
   debugfs: cd 0
   debugfs: cd d4                                  /* objid % 32 */
   debugfs: stat 36                                /* for getattr on obj 4*\
/
   debugfs: dump 36 /tmp/obj.36                    /* dump contents of obj \
4 */
   debugfs: quit
</screen>
      </section>
      <section remap="h3">
        <title>28.2.7 Finding the Lustre <anchor xml:id="dbdoclet.50438274_marker-1296007" xreflabel=""/>UUID of an OST</title>
        <para>To determine the Lustre UUID of an obdfilter disk (for example, if you mix up the cables on your OST devices or the SCSI bus numbering suddenly changes and the SCSI devices get new names), use debugfs to get the last_rcvd file.</para>
      </section>
      <section remap="h3">
        <title>28.2.8 Printing Debug Messages to the Console</title>
        <para>To dump debug messages to the console (/var/log/messages), set the corresponding debug mask in the printk flag:</para>
        <screen>sysctl -w lnet.printk=-1 
</screen>
        <para>This slows down the system dramatically. It is also possible to selectively enable or disable this capability for particular flags using:</para>
        <screen>sysctl -w lnet.printk=+vfstrace 
sysctl -w lnet.printk=-vfstrace 
</screen>
        <para>It is possible to disable warning, error , and console messages, though it is strongly recommended to have something like lctldebug_daemon runing to capture this data to a local file system for debugging purposes.</para>
      </section>
      <section remap="h3">
        <title>28.2.9 Tracing <anchor xml:id="dbdoclet.50438274_marker-1296017" xreflabel=""/>Lock Traffic</title>
        <para>Lustre has a specific debug type category for tracing lock traffic. Use:</para>
        <screen>lctl&gt; filter all_types 
lctl&gt; show dlmtrace 
lctl&gt; debug_kernel [filename] 
</screen>
      </section>
    </section>
    <section xml:id="dbdoclet.50438274_80443">
      <title>28.3 Lustre Debugging for Developers</title>
      <para>The procedures in this section may be useful to developers debugging Lustre code.</para>
      <section remap="h3">
        <title>28.3.1 Adding Debugging to the <anchor xml:id="dbdoclet.50438274_marker-1296026" xreflabel=""/>Lustre Source Code</title>
        <para>The debugging infrastructure provides a number of macros that can be used in Lustre source code to aid in debugging or reporting serious errors.</para>
        <para>To use these macros, you will need to set the DEBUG_SUBSYSTEM variable at the top of the file as shown below:</para>
        <screen>#define DEBUG_SUBSYSTEM S_PORTALS
</screen>
        <para>A list of available macros with descritions is provided in the table below.</para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50*"/>
            <colspec colname="c2" colwidth="50*"/>
            <thead>
              <row>
                <entry><para><emphasis role="bold">Macro</emphasis></para></entry>
                <entry><para><emphasis role="bold">Description</emphasis></para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><para> <emphasis role="bold">LBUG</emphasis></para></entry>
                <entry><para> A panic-style assertion in the kernel which causes Lustre to dump its circular log to the /tmp/lustre-log file. This file can be retrieved after a reboot. LBUG freezes the thread to allow capture of the panic stack. A system reboot is needed to clear the thread.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">LASSERT</emphasis></para></entry>
                <entry><para> Validates a given expression as true, otherwise calls LBUG. The failed expression is printed on the console, although the values that make up the expression are not printed.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">LASSERTF</emphasis></para></entry>
                <entry><para> Similar to LASSERT but allows a free-format message to be printed, like printf/printk.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">CDEBUG</emphasis></para></entry>
                <entry><para> The basic, most commonly used debug macro that takes just one more argument than standard printf - the debug type. This message adds to the debug log with the debug mask set accordingly. Later, when a user retrieves the log for troubleshooting, they can filter based on this type.</para><para>CDEBUG(D_INFO, &quot;This is my debug message: the number is %d\n&quot;, number).</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">CERROR</emphasis></para></entry>
                <entry><para> Behaves similarly to CDEBUG, but unconditionally prints the message in the debug log and to the console. This is appropriate for serious errors or fatal conditions:</para><para>CERROR(&quot;Something very bad has happened, and the return code is %d.\n&quot;, rc);</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">ENTRY and EXIT</emphasis></para></entry>
                <entry><para> Add messages to aid in call tracing (takes no arguments). When using these macros, cover all exit conditions to avoid confusion when the debug log reports that a function was entered, but never exited.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">LDLM_DEBUG and LDLM_DEBUG_NOLOCK</emphasis></para></entry>
                <entry><para> Used when tracing MDS and VFS operations for locking. These macros build a thin trace that shows the protocol exchanges between nodes.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">DEBUG_REQ</emphasis></para></entry>
                <entry><para> Prints information about the given ptlrpc_request structure.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">OBD_FAIL_CHECK</emphasis></para></entry>
                <entry><para> Allows insertion of failure points into the Lustre code. This is useful to generate regression tests that can hit a very specific sequence of events. This works in conjunction with &quot;sysctl -w lustre.fail_loc={fail_loc}&quot; to set a specific failure point for which a given OBD_FAIL_CHECK will test.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">OBD_FAIL_TIMEOUT</emphasis></para></entry>
                <entry><para> Similar to OBD_FAIL_CHECK. Useful to simulate hung, blocked or busy processes or network devices. If the given fail_loc is hit, OBD_FAIL_TIMEOUT waits for the specified number of seconds.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">OBD_RACE</emphasis></para></entry>
                <entry><para> Similar to OBD_FAIL_CHECK. Useful to have multiple processes execute the same code concurrently to provoke locking races. The first process to hit OBD_RACE sleeps until a second process hits OBD_RACE, then both processes continue.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">OBD_FAIL_ONCE</emphasis></para></entry>
                <entry><para> A flag set on a lustre.fail_loc breakpoint to cause the OBD_FAIL_CHECK condition to be hit only one time. Otherwise, a fail_loc is permanent until it is cleared with &quot;sysctl -w lustre.fail_loc=0&quot;.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">OBD_FAIL_RAND</emphasis></para></entry>
                <entry><para> Has OBD_FAIL_CHECK fail randomly; on average every (1 / lustre.fail_val) times.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">OBD_FAIL_SKIP</emphasis></para></entry>
                <entry><para> Has OBD_FAIL_CHECK succeed lustre.fail_val times, and then fail permanently or once with OBD_FAIL_ONCE.</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">OBD_FAIL_SOME</emphasis></para></entry>
                <entry><para> Has OBD_FAIL_CHECK fail lustre.fail_val times, and then succeed.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
      <section remap="h3">
        <title>28.3.2 Accessing a Ptlrpc <anchor xml:id="dbdoclet.50438274_marker-1296099" xreflabel=""/>Request History</title>
        <para>Each service maintains a request history, which can be useful for first occurrence troubleshooting.</para>
        <para>Ptlrpc is an RPC protocol layered on LNET that deals with stateful servers and has semantics and built-in support for recovery.</para>
        <para>A prlrpc request history works as follows:</para>
        <orderedlist><listitem>
        <para>Request_in_callback() adds the new request to the service&apos;s request history.</para>
    </listitem><listitem>
        <para>When a request buffer becomes idle, it is added to the service&apos;s request buffer history list.</para>
    </listitem><listitem>
        <para>Buffers are culled from the service&apos;s request buffer history if it has grown above</para>
        <para>req_buffer_history_max and its reqs are removed from the service&apos;s request history.</para>
    </listitem></orderedlist>
        <para>Request history is accessed and controlled using the following /proc files under the service directory:</para>
        <itemizedlist><listitem>
            <para>req_buffer_history_len</para>
          </listitem>

</itemizedlist>
        <para>Number of request buffers currently in the history</para>
        <itemizedlist><listitem>
            <para>req_buffer_history_max</para>
          </listitem>

</itemizedlist>
        <para>Maximum number of request buffers to keep</para>
        <itemizedlist><listitem>
            <para>req_history</para>
          </listitem>

</itemizedlist>
        <para>The request history</para>
        <para>Requests in the history include &quot;live&quot; requests that are currently being handled. Each line in req_history looks like:</para>
        <screen>&lt;seq&gt;:&lt;target NID&gt;:&lt;client ID&gt;:&lt;xid&gt;:&lt;length&gt;:&lt;phase&gt; &lt;svc specific&gt; 
</screen>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50*"/>
            <colspec colname="c2" colwidth="50*"/>
            <thead>
              <row>
                <entry><para><emphasis role="bold">Parameter</emphasis></para></entry>
                <entry><para><emphasis role="bold">Description</emphasis></para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><para> <emphasis role="bold">seq</emphasis></para></entry>
                <entry><para> Request sequence number</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">target NID</emphasis></para></entry>
                <entry><para> Destination NID of the incoming request</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">client ID</emphasis></para></entry>
                <entry><para> Client PID and NID</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">xid</emphasis></para></entry>
                <entry><para> rq_xid</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">length</emphasis></para></entry>
                <entry><para> Size of the request message</para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">phase</emphasis></para></entry>
                <entry><para><itemizedlist><listitem>
                        <para> New (waiting to be handled or could not be unpacked)</para>
                      </listitem>
<listitem>
                        <para> Interpret (unpacked or being handled)</para>
                      </listitem>
<listitem>
                        <para> Complete (handled)</para>
                      </listitem>
</itemizedlist></para></entry>
              </row>
              <row>
                <entry><para> <emphasis role="bold">svc specific</emphasis></para></entry>
                <entry><para> Service-specific request printout. Currently, the only service that does this is the OST (which prints the opcode if the message has been unpacked successfully</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
      <section remap="h3">
        <title>28.3.3 Finding Memory <anchor xml:id="dbdoclet.50438274_marker-1296153" xreflabel=""/>Leaks Using leak_finder.pl</title>
        <para>Memory leaks can occur in code when memory has been allocated and then not freed once it is no longer required. The leak_finder.pl program provides a way to find memory leaks.</para>
        <para>Before running this program, you must turn on debugging to collect all malloc and free entries. Run:</para>
        <screen>sysctl -w lnet.debug=+malloc 
</screen>
        <para>Then complete the following steps:</para>
        <orderedlist><listitem> 
        <para> 1. Dump the log into a user-specified log file using lctl (see <link xl:href="LustreDebugging.html#50438274_62472">Using the lctl Tool to View Debug Messages</link>).</para>
        </listitem><listitem>
        <para> 2. Run the leak finder on the newly-created log dump:</para>
        <screen>perl leak_finder.pl &lt;ascii-logname&gt;
</screen>
        </listitem></orderedlist>
        <para>The output is:</para>
        <screen>malloced 8bytes at a3116744 (called pathcopy) 
(lprocfs_status.c:lprocfs_add_vars:80) 
freed 8bytes at a3116744 (called pathcopy) 
(lprocfs_status.c:lprocfs_add_vars:80) 
</screen>
        <para>The tool displays the following output to show the leaks found:</para>
        <screen>Leak:32bytes allocated at a23a8fc(service.c:ptlrpc_init_svc:144,debug file \
line 241)
</screen>
      </section>
  </section>
</chapter>
