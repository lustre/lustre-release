<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. -->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en-US" xml:id="lustredebugging">
  <info>
    <title xml:id="lustredebugging.title">Lustre Debugging</title>
  </info>
  <para>This chapter describes tips and information to debug Lustre, and includes the following sections:</para>
  <itemizedlist>
    <listitem>
      <para><xref linkend="dbdoclet.50438274_15874"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438274_23607"/></para>
    </listitem>
    <listitem>
      <para><xref linkend="dbdoclet.50438274_80443"/></para>
    </listitem>
  </itemizedlist>
  <section xml:id="dbdoclet.50438274_15874">
    <title>28.1 Diagnostic and Debugging Tools</title>
    <para>A variety of diagnostic and analysis tools are available to debug issues with the Lustre software. Some of these are provided in Linux distributions, while others have been developed and are made available by the Lustre project.</para>
    <section remap="h3">
      <title>28.1.1 Lustre Debugging Tools</title>
      <para>The following in-kernel debug mechanisms are incorporated into the Lustre software:</para>
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Debug logs</emphasis>  - A circular debug buffer to which Lustre internal debug messages are written (in contrast to error messages, which are printed to the syslog or console). Entries to the Lustre debug log are controlled by the mask set by <literal>/proc/sys/lnet/debug</literal>. The log size defaults to 5 MB per CPU but can be increased as a busy system will quickly overwrite 5 MB. When the buffer fills, the oldest information is discarded.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Debug daemon</emphasis>  - The debug daemon controls logging of debug messages.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">
              <literal>/proc/sys/lnet/debug</literal>
            </emphasis>  - This file contains a mask that can be used to delimit the debugging information written out to the kernel debug logs.</para>
        </listitem>
      </itemizedlist>
      <para>The following tools are also provided with the Lustre software:</para>
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">
              <literal>lctl</literal>
            </emphasis>  - This tool is used with the debug_kernel option to manually dump the Lustre debugging log or post-process debugging logs that are dumped automatically. For more information about the lctl tool, see <xref linkend="dbdoclet.50438274_62472"/> and <xref linkend="dbdoclet.50438219_38274"/>.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Lustre subsystem asserts</emphasis>  - A panic-style assertion (LBUG) in the kernel causes Lustre to dump the debug log to the file <literal>/tmp/lustre-log.<emphasis>&lt;timestamp&gt;</emphasis></literal> where it can be retrieved after a reboot. For more information, see <xref linkend="dbdoclet.50438198_40669">Viewing Error Messages</xref>.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">
              <literal>lfs</literal>
            </emphasis>  - This utility provides access to the extended attributes (EAs) of a Lustre file (along with other information). For more inforamtion about lfs, see <xref linkend="dbdoclet.50438206_94597">lfs</xref>.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section remap="h3">
      <title>28.1.2 External Debugging Tools</title>
      <para>The tools described in this section are provided in the Linux kernel or are available at an external website. For information about using some of these tools for Lustre debugging, see <xref linkend="dbdoclet.50438274_23607">Lustre Debugging Procedures</xref> and <xref linkend="dbdoclet.50438274_80443">Lustre Debugging for Developers</xref>.</para>
      <section remap="h4">
        <title>28.1.2.1 Tools for Administrators and Developers</title>
        <para>Some general debugging tools provided as a part of the standard Linux distro are:</para>
        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">
                <literal>strace</literal>
              </emphasis> . This tool allows a system call to be traced.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">
                <literal>/var/log/messages</literal>
              </emphasis> . <literal>syslogd</literal> prints fatal or serious messages at this log.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">Crash dumps</emphasis> . On crash-dump enabled kernels, sysrq c produces a crash dump. Lustre enhances this crash dump with a log dump (the last 64 KB of the log) to the console.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">
                <literal>debugfs</literal>
              </emphasis>. Interactive file system debugger.</para>
          </listitem>
        </itemizedlist>
        <para>The following logging and data collection tools can be used to collect information for debugging Lustre kernel issues:</para>
        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">
                <literal>kdump</literal>
              </emphasis> . A Linux kernel crash utility useful for debugging a system running Red Hat Enterprise Linux. For more information about <literal>kdump</literal>, see the Red Hat knowledge base article <link xl:href="http://kbase.redhat.com/faq/docs/DOC-6039">How do I configure kexec/kdump on Red Hat Enterprise Linux 5?</link>. To download <literal>kdump</literal>, go to the <link xl:href="http://fedoraproject.org/wiki/SystemConfig/kdump#Download">Fedora Project Download</link> site.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">
                <literal>netconsole</literal>
              </emphasis>. Enables kernel-level network logging over UDP. A system requires (SysRq) allows users to collect relevant data through <literal>netconsole</literal>.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">
                <literal>netdump</literal>
              </emphasis>. A crash dump utility from Red Hat that allows memory images to be dumped over a network to a central server for analysis. The <literal>netdump</literal> utility was replaced by <literal>kdump</literal> in RHEL 5. For more information about <literal>netdump</literal>, see <link xl:href="http://www.redhat.com/support/wpapers/redhat/netdump/">Red Hat, Inc.&apos;s Network Console and Crash Dump Facility</link>.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section remap="h4">
        <title>28.1.2.2 Tools for Developers</title>
        <para>The tools described in this section may be useful for debugging Lustre in a development environment.</para>
        <para>Of general interest is:</para>
        <itemizedlist>
          <listitem>
            <para><literal>
                <emphasis role="bold">leak_finder.pl</emphasis>
              </literal> . This program provided with Lustre is useful for finding memory leaks in the code.</para>
          </listitem>
        </itemizedlist>
        <para>A virtual machine is often used to create an isolated development and test environment. Some commonly-used virtual machines are:</para>
        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">VirtualBox Open Source Edition</emphasis> . Provides enterprise-class virtualization capability for all major platforms and is available free at <link xl:href="http://www.sun.com/software/products/virtualbox/get.jsp?intcmp=2945">Get Sun VirtualBox</link>.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">VMware Server</emphasis> . Virtualization platform available as free introductory software at <link xl:href="http://downloads.vmware.com/d/info/datacenter_downloads/vmware_server/2_0">Download VMware Server</link>.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">Xen</emphasis> . A para-virtualized environment with virtualization capabilities similar to VMware Server and Virtual Box. However, Xen allows the use of modified kernels to provide near-native performance and the ability to emulate shared storage. For more information, go to <link xl:href="http://xen.org/">xen.org</link>.</para>
          </listitem>
        </itemizedlist>
        <para>A variety of debuggers and analysis tools are available including:</para>
        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">
                <literal>kgdb</literal>
              </emphasis> . The Linux Kernel Source Level Debugger kgdb is used in conjunction with the GNU Debugger <literal>gdb</literal> for debugging the Linux kernel. For more information about using <literal>kgdb</literal> with <literal>gdb</literal>, see <link xl:href="http://www.linuxtopia.org/online_books/redhat_linux_debugging_with_gdb/running.html">Chapter 6. Running Programs Under gdb</link> in the <emphasis>Red Hat Linux 4 Debugging with GDB</emphasis> guide.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">
                <literal>crash</literal>
              </emphasis> . Used to analyze saved crash dump data when a system had panicked or locked up or appears unresponsive. For more information about using crash to analyze a crash dump, see:</para>
            <itemizedlist>
              <listitem>
                <para> Red Hat Magazine article: <link xl:href="http://magazine.redhat.com/2007/08/15/a-quick-overview-of-linux-kernel-crash-dump-analysis/">A quick overview of Linux kernel crash dump analysis</link></para>
              </listitem>
              <listitem>
                <para><link xl:href="http://people.redhat.com/anderson/crash_whitepaper/#EXAMPLES">Crash Usage: A Case Study</link>  from the white paper <emphasis>Red Hat Crash Utility</emphasis> by David Anderson</para>
              </listitem>
              <listitem>
                <para> Kernel Trap forum entry: <link xl:href="http://kerneltrap.org/node/5758">Linux: Kernel Crash Dumps</link></para>
              </listitem>
              <listitem>
                <para> White paper: <link xl:href="http://www.google.com/url?sa=t&amp;source=web&amp;ct=res&amp;cd=8&amp;ved=0CCUQFjAH&amp;url=http%3A%2F%2Fwww.kernel.sg%2Fpapers%2Fcrash-dump-analysis.pdf&amp;rct=j&amp;q=redhat+crash+dump&amp;ei=6aQBS-ifK4T8tAPcjdiHCw&amp;usg=AFQjCNEk03E3GDtAsawG3gfpwc1gGNELAg">A Quick Overview of Linux Kernel Crash Dump Analysis</link></para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>
  <section xml:id="dbdoclet.50438274_23607">
    <title>28.2 Lustre Debugging Procedures</title>
    <para>The procedures below may be useful to administrators or developers debugging a Lustre files system.</para>
    <section remap="h3">
      <title>28.2.1 Understanding the Lustre Debug Messaging Format</title>
      <para>Lustre debug messages are categorized by originating sybsystem, message type, and locaton in the source code. For a list of subsystems and message types, see <xref linkend="dbdoclet.50438274_57603"/>.</para>
      <note>
        <para>For a current list of subsystems and debug message types, see <literal>lnet/include/libcfs/libcfs.h</literal> in the Lustre tree</para>
      </note>
      <para>The elements of a Lustre debug message are described in <xref linkend="dbdoclet.50438274_57177"/> Format of Lustre Debug Messages.</para>
      <section xml:id="dbdoclet.50438274_57603">
        <title>28.2.1.1 Lustre Debug Messages</title>
        <para>Each Lustre debug message has the tag of the subsystem it originated in, the message type, and the location in the source code. The subsystems and debug types used in Lustre are as follows:</para>
        <itemizedlist>
          <listitem>
            <para>  Standard Subsystems:</para>
            <para> mdc, mds, osc, ost, obdclass, obdfilter, llite, ptlrpc, portals, lnd, ldlm, lov</para>
          </listitem>
        </itemizedlist>
        <itemizedlist>
          <listitem>
            <para>  Debug Types:</para>
          </listitem>
          <listitem>
            <para><informaltable frame="all">
                <tgroup cols="2">
                  <colspec colname="c1" colwidth="50*"/>
                  <colspec colname="c2" colwidth="50*"/>
                  <thead>
                    <row>
                      <entry>
                        <para><emphasis role="bold">Types</emphasis></para>
                      </entry>
                      <entry>
                        <para><emphasis role="bold">Description</emphasis></para>
                      </entry>
                    </row>
                  </thead>
                  <tbody>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">trace</emphasis></para>
                      </entry>
                      <entry>
                        <para> Entry/Exit markers</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">dlmtrace</emphasis></para>
                      </entry>
                      <entry>
                        <para> Locking-related information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">inode</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">super</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">ext2</emphasis></para>
                      </entry>
                      <entry>
                        <para> Anything from the ext2_debug</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">malloc</emphasis></para>
                      </entry>
                      <entry>
                        <para> Print malloc or free information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">cache</emphasis></para>
                      </entry>
                      <entry>
                        <para> Cache-related information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">info</emphasis></para>
                      </entry>
                      <entry>
                        <para> General information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">ioctl</emphasis></para>
                      </entry>
                      <entry>
                        <para> IOCTL-related information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">blocks</emphasis></para>
                      </entry>
                      <entry>
                        <para> Ext2 block allocation information</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">net</emphasis></para>
                      </entry>
                      <entry>
                        <para> Networking</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">warning</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">buffs</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">other</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">dentry</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">portals</emphasis></para>
                      </entry>
                      <entry>
                        <para> Entry/Exit markers</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">page</emphasis></para>
                      </entry>
                      <entry>
                        <para> Bulk page handling</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">error</emphasis></para>
                      </entry>
                      <entry>
                        <para> Error messages</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">emerg</emphasis></para>
                      </entry>
                      <entry>
                        <para> &#160;</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">rpctrace</emphasis></para>
                      </entry>
                      <entry>
                        <para> For distributed debugging</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> <emphasis role="bold">ha</emphasis></para>
                      </entry>
                      <entry>
                        <para> Failover and recovery-related information</para>
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
</para>
          </listitem>
        </itemizedlist>
      </section>
      <section xml:id="dbdoclet.50438274_57177">
        <title>28.2.1.2 Format of Lustre Debug Messages</title>
        <para>Lustre uses the <literal>CDEBUG</literal> and <literal>CERROR</literal> macros to print the debug or error messages. To print the message, the <literal>CDEBUG</literal> macro uses <literal>portals_debug_msg</literal> (<literal>portals/linux/oslib/debug.c</literal>). The message format is described below, along with an example.</para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50*"/>
            <colspec colname="c2" colwidth="50*"/>
            <thead>
              <row>
                <entry>
                  <para><emphasis role="bold">Parameter</emphasis></para>
                </entry>
                <entry>
                  <para><emphasis role="bold">Description</emphasis></para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para> <emphasis role="bold">subsystem</emphasis></para>
                </entry>
                <entry>
                  <para> 800000</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">debug mask</emphasis></para>
                </entry>
                <entry>
                  <para> 000010</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">smp_processor_id</emphasis></para>
                </entry>
                <entry>
                  <para> 0</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">sec.used</emphasis></para>
                </entry>
                <entry>
                  <para> 10818808</para>
                  <para> 47.677302</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">stack size</emphasis></para>
                </entry>
                <entry>
                  <para> 1204:</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">pid</emphasis></para>
                </entry>
                <entry>
                  <para> 2973:</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">host pid (if uml) or zero</emphasis></para>
                </entry>
                <entry>
                  <para> 31070:</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">(file:line #:functional())</emphasis></para>
                </entry>
                <entry>
                  <para> (as_dev.c:144:create_write_buffers())</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para> <emphasis role="bold">debug message</emphasis></para>
                </entry>
                <entry>
                  <para> kmalloced &apos;*obj&apos;: 24 at a375571c (tot 17447717)</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
      <section remap="h4">
        <title>28.2.1.3 Lustre Debug Messages Buffer</title>
        <para>Lustre debug messages are maintained in a buffer, with the maximum buffer size specified (in MBs) by the <literal>debug_mb</literal> parameter (<literal>/proc/sys/lnet/debug_mb</literal>). The buffer is circular, so debug messages are kept until the allocated buffer limit is reached, and then the first messages are overwritten.</para>
      </section>
    </section>
    <section xml:id='dbdoclet.50438274_62472'>
      <title>28.2.2 Using the lctl Tool to View Debug Messages</title>
      <para>The <literal>lctl</literal> tool allows debug messages to be filtered based on subsystems and message types to extract information useful for troubleshooting from a kernel debug log. For a command reference, see <xref linkend="dbdoclet.50438219_38274">lctl</xref>.</para>
      <para>You can use <literal>lctl</literal> to:</para>
      <itemizedlist>
        <listitem>
          <para>Obtain a list of all the types and subsystems:</para>
          <screen>lctl &gt; debug_list <emphasis>&lt;subs | types&gt;</emphasis></screen>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>Filter the debug log:</para>
          <screen>lctl &gt; filter <emphasis>&lt;subsystem name | debug type&gt;</emphasis></screen>
        </listitem>
      </itemizedlist>
      <note>
        <para>When <literal>lctl</literal> filters, it removes unwanted lines from the displayed output. This does not affect the contents of the debug log in the kernel&apos;s memory. As a result, you can print the log many times with different filtering levels without worrying about losing data.</para>
      </note>
      <itemizedlist>
        <listitem>
          <para>Show debug messages belonging to certain subsystem or type:</para>
          <screen>lctl &gt; show <emphasis>&lt;subsystem name | debug type&gt;</emphasis></screen>
          <para><literal>debug_kernel</literal> pulls the data from the kernel logs, filters it appropriately, and displays or saves it as per the specified options</para>
          <screen>lctl &gt; debug_kernel [<emphasis>output filename</emphasis>]</screen>
          <para>If the debugging is being done on User Mode Linux (UML), it might be useful to save the logs on the host machine so that they can be used at a later time.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>Filter a log on disk, if you already have a debug log saved to disk (likely from a crash):</para>
          <screen>lctl &gt; debug_file <emphasis>&lt;input filename&gt;</emphasis> [<emphasis>output filename</emphasis>] </screen>
          <para>During the debug session, you can add markers or breaks to the log for any reason:</para>
          <screen>lctl &gt; mark [marker text] </screen>
          <para>The marker text defaults to the current date and time in the debug log (similar to the example shown below):</para>
          <screen>DEBUG MARKER: Tue Mar 5 16:06:44 EST 2002 
</screen>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>Completely flush the kernel debug buffer:</para>
          <screen>lctl &gt; clear
</screen>
        </listitem>
      </itemizedlist>
      <note>
        <para>Debug messages displayed with <literal>lctl</literal> are also subject to the kernel debug masks; the filters are additive.</para>
      </note>
      <section remap="h4">
        <title>28.2.2.1 Sample <literal>lctl</literal> Run</title>
        <para>Below is a sample run using the <literal>lctl</literal> command.</para>
        <screen>bash-2.04# ./lctl 
lctl &gt; debug_kernel /tmp/lustre_logs/log_all 
Debug log: 324 lines, 324 kept, 0 dropped. 
lctl &gt; filter trace 
Disabling output of type &quot;trace&quot; 
lctl &gt; debug_kernel /tmp/lustre_logs/log_notrace 
Debug log: 324 lines, 282 kept, 42 dropped. 
lctl &gt; show trace 
Enabling output of type &quot;trace&quot; 
lctl &gt; filter portals 
Disabling output from subsystem &quot;portals&quot; 
lctl &gt; debug_kernel /tmp/lustre_logs/log_noportals 
Debug log: 324 lines, 258 kept, 66 dropped. 
</screen>
      </section>
    </section>
    <section remap="h3">
      <title>28.2.3 Dumping the Buffer to a File (<literal>debug_daemon</literal>)</title>
      <para>The <literal>debug_daemon</literal> option is used by <literal>lctl</literal> to control the dumping of the <literal>debug_kernel</literal> buffer to a user-specified file. This functionality uses a kernel thread on top of <literal>debug_kernel</literal>, which works in parallel with the <literal>debug_daemon</literal> command.</para>
      <para>The <literal>debug_daemon</literal> is highly dependent on file system write speed. File system write operations may not be fast enough to flush out all of the <literal>debug_buffer</literal> if the Lustre file system is under heavy system load and continues to <literal>CDEBUG</literal> to the <literal>debug_buffer</literal>. The <literal>debug_daemon</literal> will write the message <literal>DEBUG MARKER:</literal> Trace buffer full into the <literal>debug_buffer</literal> to indicate the <literal>debug_buffer</literal> contents are overlapping before the <literal>debug_daemon</literal> flushes data to a file.</para>
      <para>Users can use <literal>lctl control</literal> to start or stop the Lustre daemon from dumping the <literal>debug_buffe</literal>r to a file. Users can also temporarily hold daemon from dumping the file. Use of the <literal>debug_daemon</literal> sub-command to <literal>lctl</literal> can provide the same function.</para>
      <section remap="h4">
        <title>28.2.3.1 <literal>lctl debug_daemon</literal> Commands</title>
        <para>This section describes <literal>lctl debug_daemon</literal> commands.</para>
        <para>To initiate the <literal>debug_daemon</literal> to start dumping <literal>debug_buffer</literal> into a file., enter</para>
        <screen>$ lctl debug_daemon start [{file} {megabytes}]</screen>
        <para>The file can be a system default file, as shown in <literal>/proc/sys/lnet/debug_path</literal>. After Lustre starts, the default path is <literal>/tmp/lustre-log-$HOSTNAME</literal>. Users can specify a new filename for <literal>debug_daemon</literal> to output <literal>debug_buffer</literal>. The new file name shows up in <literal>/proc/sys/lnet/debug_path</literal>. Megabytes is the limitation of the file size in MBs.</para>
        <para>The daemon wraps around and dumps data to the beginning of the file when the output file size is over the limit of the user-specified file size. To decode the dumped file to ASCII and order the log entries by time, run:</para>
        <screen>lctl debug_file {file} &gt; {newfile}</screen>
        <para>The output is internally sorted by the <literal>lct</literal>l command using quicksort.</para>
        <para>To completely shut down the <literal>debug_daemon</literal> operation and flush the file output, enter:</para>
        <screen>debug_daemon stop</screen>
        <para>Otherwise, <literal>debug_daemon</literal> is shut down as part of the Lustre file system shutdown process. Users can restart <literal>debug_daemon</literal> by using start command after each stop command issued.</para>
        <para>This is an example using <literal>debug_daemon</literal> with the interactive mode of <literal>lctl</literal> to dump debug logs to a 10 MB file.</para>
        <screen>#~/utils/lctl</screen>
        <para>To start the daemon to dump debug_buffer into a 40 MB <literal>/tmp/dump</literal> file, enter:</para>
        <screen>lctl &gt; debug_daemon start /trace/log 40 </screen>
        <para>To completely shut down the daemon, enter:</para>
        <screen>lctl &gt; debug_daemon stop </screen>
        <para>To start another daemon with an unlimited file size, enter:</para>
        <screen>lctl &gt; debug_daemon start /tmp/unlimited </screen>
        <para>The text message <literal>*** End of debug_daemon trace log ***</literal> appears at the end of each output file.</para>
      </section>
    </section>
    <section remap="h3">
      <title>28.2.4 Controlling Information Written to the Kernel Debug Log</title>
      <para>Masks are provided in <literal>/proc/sys/lnet/subsystem_debug</literal> and <literal>/proc/sys/lnet/debug</literal> to be used with the systctl command to determine what information is to be written to the debug log. The subsystem_debug mask determines the information written to the log based on the subsystem (such as iobdfilter, net, portals, or OSC). The debug mask controls information based on debug type (such as info, error, trace, or alloc).</para>
      <para>To turn off Lustre debugging completely:</para>
      <screen>sysctl -w lnet.debug=0 </screen>
      <para>To turn on full Lustre debugging:</para>
      <screen>sysctl -w lnet.debug=-1 </screen>
      <para>To turn on logging of messages related to network communications:</para>
      <screen>sysctl -w lnet.debug=net </screen>
      <para>To turn on logging of messages related to network communications and existing debug flags:</para>
      <screen>sysctl -w lnet.debug=+net </screen>
      <para>To turn off network logging with changing existing flags:</para>
      <screen>sysctl -w lnet.debug=-net </screen>
      <para>The various options available to print to kernel debug logs are listed in <literal>lnet/include/libcfs/libcfs.h</literal></para>
    </section>
    <section remap="h3">
      <title>28.2.5 Troubleshooting with <literal>strace</literal></title>
      <para>The <literal>strace</literal> utility provided with the Linux distribution enables system calls to be traced by intercepting all the system calls made by a process and recording the system call name, arguments, and return values.</para>
      <para>To invoke <literal>strace</literal> on a program, enter:</para>
      <screen>$ strace <emphasis>&lt;program&gt; &lt;args&gt;</emphasis> </screen>
      <para>Sometimes, a system call may fork child processes. In this situation, use the <literal>-f</literal> option of <literal>strace</literal> to trace the child processes:</para>
      <screen>$ strace -f <emphasis>&lt;program&gt; &lt;args&gt;</emphasis> </screen>
      <para>To redirect the <literal>strace</literal> output to a file, enter:</para>
      <screen>$ strace -o <emphasis>&lt;filename&gt; &lt;program&gt; &lt;args&gt;</emphasis> </screen>
      <para>Use the <literal>-ff</literal> option, along with <literal>-o</literal>, to save the trace output in <literal>filename.pid</literal>, where <literal>pid</literal> is the process ID of the process being traced. Use the <literal>-ttt</literal> option to timestamp all lines in the strace output, so they can be correlated to operations in the lustre kernel debug log.</para>
      <para>If the debugging is done in UML, save the traces on the host machine. In this example, <literal>hostfs</literal> is mounted on <literal>/r</literal>:</para>
      <screen>$ strace -o /r/tmp/vi.strace </screen>
    </section>
    <section remap="h3">
      <title>28.2.6 Looking at Disk Content</title>
      <para>In Lustre, the inodes on the metadata server contain extended attributes (EAs) that store information about file striping. EAs contain a list of all object IDs and their locations (that is, the OST that stores them). The <literal>lfs</literal> tool can be used to obtain this information for a given file using the <literal>getstripe</literal> subcommand. Use a corresponding <literal>lfs setstripe</literal> command to specify striping attributes for a new file or directory.</para>
      <para>The <literal>lfs getstripe</literal> utility is written in C; it takes a Lustre filename as input and lists all the objects that form a part of this file. To obtain this information for the file <literal>/mnt/lustre/frog</literal> in Lustre file system, run:</para>
      <screen>$ lfs getstripe /mnt/lustre/frog
$
   obdix                           objid
   0                               17
   1                               4
</screen>
      <para>The <literal>debugfs</literal> tool is provided in the <literal>e2fsprogs</literal> package. It can be used for interactive debugging of an <literal>ldiskfs</literal> file system. The <literal>debugfs</literal> tool can either be used to check status or modify information in the file system. In Lustre, all objects that belong to a file are stored in an underlying <literal>ldiskfs</literal> file system on the OSTs. The file system uses the object IDs as the file names. Once the object IDs are known, use the <literal>debugfs</literal> tool to obtain the attributes of all objects from different OSTs.</para>
      <para>A sample run for the <literal>/mnt/lustre/frog</literal> file used in the above example is shown here:</para>
      <screen>     $ debugfs -c /tmp/ost1
   debugfs: cd O
   debugfs: cd 0                                   /* for files in group 0 */
   debugfs: cd d&lt;objid % 32&gt;
   debugfs: stat &lt;objid&gt;                           /* for getattr on object */
   debugfs: quit
## Suppose object id is 36, then follow the steps below:
   $ debugfs /tmp/ost1
   debugfs: cd O
   debugfs: cd 0
   debugfs: cd d4                                  /* objid % 32 */
   debugfs: stat 36                                /* for getattr on obj 4*/
   debugfs: dump 36 /tmp/obj.36                    /* dump contents of obj 4 */
   debugfs: quit</screen>
    </section>
    <section remap="h3">
      <title>28.2.7 Finding the Lustre UUID of an OST</title>
      <para>To determine the Lustre UUID of an obdfilter disk (for example, if you mix up the cables on your OST devices or the SCSI bus numbering suddenly changes and the SCSI devices get new names), use <literal>debugfs</literal> to get the <literal>last_rcvd</literal> file.</para>
    </section>
    <section remap="h3">
      <title>28.2.8 Printing Debug Messages to the Console</title>
      <para>To dump debug messages to the console (<literal>/var/log/messages</literal>), set the corresponding debug mask in the <literal>printk</literal> flag:</para>
      <screen>sysctl -w lnet.printk=-1 </screen>
      <para>This slows down the system dramatically. It is also possible to selectively enable or disable this capability for particular flags using:</para>
      <screen>sysctl -w lnet.printk=+vfstrace 
sysctl -w lnet.printk=-vfstrace </screen>
      <para>It is possible to disable warning, error, and console messages, though it is strongly recommended to have something like <literal>lctl debug_daemon</literal> running to capture this data to a local file system for debugging purposes.</para>
    </section>
    <section remap="h3">
      <title>28.2.9 Tracing Lock Traffic</title>
      <para>Lustre has a specific debug type category for tracing lock traffic. Use:</para>
      <screen>lctl&gt; filter all_types 
lctl&gt; show dlmtrace 
lctl&gt; debug_kernel [filename] </screen>
    </section>
  </section>
  <section xml:id="dbdoclet.50438274_80443">
    <title>28.3 Lustre Debugging for Developers</title>
    <para>The procedures in this section may be useful to developers debugging Lustre code.</para>
    <section remap="h3">
      <title>28.3.1 Adding Debugging to the Lustre Source Code</title>
      <para>The debugging infrastructure provides a number of macros that can be used in Lustre source code to aid in debugging or reporting serious errors.</para>
      <para>To use these macros, you will need to set the <literal>DEBUG_SUBSYSTEM</literal> variable at the top of the file as shown below:</para>
      <screen>#define DEBUG_SUBSYSTEM S_PORTALS</screen>
      <para>A list of available macros with descriptions is provided in the table below.</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Macro</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>LBUG</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>A panic-style assertion in the kernel which causes Lustre to dump its circular log to the <literal>/tmp/lustre-log</literal> file. This file can be retrieved after a reboot. LBUG freezes the thread to allow capture of the panic stack. A system reboot is needed to clear the thread.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>LASSERT</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Validates a given expression as true, otherwise calls LBUG. The failed expression is printed on the console, although the values that make up the expression are not printed.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>LASSERTF</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Similar to LASSERT but allows a free-format message to be printed, like <literal>printf/printk</literal>.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>CDEBUG</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>The basic, most commonly used debug macro that takes just one more argument than standard <literal>printf</literal> - the debug type. This message adds to the debug log with the debug mask set accordingly. Later, when a user retrieves the log for troubleshooting, they can filter based on this type.</para>
                <para><literal>CDEBUG(D_INFO, &quot;This is my debug message: the number is %d\n&quot;, number)</literal>.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>CERROR</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Behaves similarly to <literal>CDEBUG</literal>, but unconditionally prints the message in the debug log and to the console. This is appropriate for serious errors or fatal conditions:</para>
                <para><literal>CERROR(&quot;Something very bad has happened, and the return code is %d.\n&quot;, rc);</literal></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold"><literal>ENTRY</literal> and <literal>EXIT</literal></emphasis></para>
              </entry>
              <entry>
                <para> Add messages to aid in call tracing (takes no arguments). When using these macros, cover all exit conditions to avoid confusion when the debug log reports that a function was entered, but never exited.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold"><literal>LDLM_DEBUG</literal> and <literal>LDLM_DEBUG_NOLOCK</literal></emphasis></para>
              </entry>
              <entry>
                <para>Used when tracing MDS and VFS operations for locking. These macros build a thin trace that shows the protocol exchanges between nodes.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>
                    <emphasis role="bold">DEBUG_REQ</emphasis>
                  </literal></para>
              </entry>
              <entry>
                <para>Prints information about the given <literal>ptlrpc_request</literal> structure.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>
                    <emphasis role="bold">OBD_FAIL_CHECK</emphasis>
                  </literal></para>
              </entry>
              <entry>
                <para>Allows insertion of failure points into the Lustre code. This is useful to generate regression tests that can hit a very specific sequence of events. This works in conjunction with &quot;<literal>sysctl -w lustre.fail_loc={fail_loc}</literal>&quot; to set a specific failure point for which a given <literal>OBD_FAIL_CHECK</literal> will test.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>
                    <emphasis role="bold">OBD_FAIL_TIMEOUT</emphasis>
                  </literal></para>
              </entry>
              <entry>
                <para>Similar to <literal>OBD_FAIL_CHECK</literal>. Useful to simulate hung, blocked or busy processes or network devices. If the given <literal>fail_loc</literal> is hit, <literal>OBD_FAIL_TIMEOUT</literal> waits for the specified number of seconds.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>
                    <emphasis role="bold">OBD_RACE</emphasis>
                  </literal></para>
              </entry>
              <entry>
                <para>Similar to <literal>OBD_FAIL_CHECK</literal>. Useful to have multiple processes execute the same code concurrently to provoke locking races. The first process to hit <literal>OBD_RACE</literal> sleeps until a second process hits <literal>OBD_RACE</literal>, then both processes continue.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>
                    <emphasis role="bold">OBD_FAIL_ONCE</emphasis>
                  </literal></para>
              </entry>
              <entry>
                <para>A flag set on a <literal>lustre.fail_loc</literal> breakpoint to cause the <literal>OBD_FAIL_CHECK</literal> condition to be hit only one time. Otherwise, a <literal>fail_loc</literal> is permanent until it is cleared with &quot;<literal>sysctl -w lustre.fail_loc=0</literal>&quot;.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para><literal>
                     <emphasis role="bold">OBD_FAIL_RAND</emphasis>
                  </literal></para>
              </entry>
              <entry>
                <para>Has <literal>OBD_FAIL_CHECK</literal> fail randomly; on average every (1 / lustre.fail_val) times.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>OBD_FAIL_SKIP</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Has <literal>OBD_FAIL_CHECK</literal> succeed <literal>lustre.fail_val</literal> times, and then fail permanently or once with <literal>OBD_FAIL_ONCE</literal>.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>
                    <emphasis role="bold">OBD_FAIL_SOME</emphasis>
                  </literal></para>
              </entry>
              <entry>
                <para>Has <literal>OBD_FAIL_CHECK</literal> fail <literal>lustre.fail_val</literal> times, and then succeed.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section remap="h3">
      <title>28.3.2 Accessing a <literal>ptlrpc</literal> Request History</title>
      <para>Each service maintains a request history, which can be useful for first occurrence troubleshooting.</para>
      <para><literal>ptlrpc</literal> is an RPC protocol layered on LNET that deals with stateful servers and has semantics and built-in support for recovery.</para>
      <para>A <literal>prlrpc</literal> request history works as follows:</para>
      <orderedlist>
        <listitem>
          <para><literal>request_in_callback()</literal> adds the new request to the service&apos;s request history.</para>
        </listitem>
        <listitem>
          <para>When a request buffer becomes idle, it is added to the service&apos;s request buffer history list.</para>
        </listitem>
        <listitem>
          <para>Buffers are culled from the service&apos;s request buffer history if it has grown above</para>
          <para><literal>req_buffer_history_max</literal> and its reqs are removed from the service&apos;s request history.</para>
        </listitem>
      </orderedlist>
      <para>Request history is accessed and controlled using the following /proc files under the service directory:</para>
      <itemizedlist>
        <listitem>
          <literal>
            <para>req_buffer_history_len</para>
          </literal>
          <para>Number of request buffers currently in the history</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <literal>
            <para>req_buffer_history_max</para>
          </literal>
          <para>Maximum number of request buffers to keep</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <literal>
            <para>req_history</para>
          </literal>
          <para>The request history</para>
        </listitem>
      </itemizedlist>
      <para>Requests in the history include &quot;live&quot; requests that are currently being handled. Each line in <literal>req_history</literal> looks like:</para>
      <screen>&lt;seq&gt;:&lt;target NID&gt;:&lt;client ID&gt;:&lt;xid&gt;:&lt;length&gt;:&lt;phase&gt; &lt;svc specific&gt; </screen>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <thead>
            <row>
              <entry>
                <para><emphasis role="bold">Parameter</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>seq</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Request sequence number</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>
                    <emphasis role="bold">target NID</emphasis>
                  </literal></para>
              </entry>
              <entry>
                <para> Destination <literal>NID</literal> of the incoming request</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal>
                    <emphasis role="bold">client ID</emphasis>
                  </literal></para>
              </entry>
              <entry>
                <para> Client <literal>PID</literal> and <literal>NID</literal></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>xid</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> <literal>rq_xid</literal></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>length</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para> Size of the request message</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>phase</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para><itemizedlist>
                    <listitem>
                      <para>New (waiting to be handled or could not be unpacked)</para>
                    </listitem>
                    <listitem>
                      <para>Interpret (unpacked or being handled)</para>
                    </listitem>
                    <listitem>
                      <para>Complete (handled)</para>
                    </listitem>
                  </itemizedlist></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <emphasis role="bold">
                    <literal>svc specific</literal>
                  </emphasis></para>
              </entry>
              <entry>
                <para>Service-specific request printout. Currently, the only service that does this is the OST (which prints the opcode if the message has been unpacked successfully</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section remap="h3">
      <title>28.3.3 Finding Memory Leaks Using <literal>leak_finder.pl</literal></title>
      <para>Memory leaks can occur in code when memory has been allocated and then not freed once it is no longer required. The <literal>leak_finder.pl</literal> program provides a way to find memory leaks.</para>
      <para>Before running this program, you must turn on debugging to collect all <literal>malloc</literal> and free entries. Run:</para>
      <screen>sysctl -w lnet.debug=+malloc </screen>
      <para>Then complete the following steps:</para>
      <orderedlist>
        <listitem>
          <para>Dump the log into a user-specified log file using lctl (see <xref linkend="dbdoclet.50438274_62472">Using the <literal>lctl</literal> Tool to View Debug Messages</xref>).</para>
        </listitem>
        <listitem>
          <para>Run the leak finder on the newly-created log dump:</para>
          <screen>perl leak_finder.pl &lt;ascii-logname&gt;</screen>
        </listitem>
      </orderedlist>
      <para>The output is:</para>
      <screen>malloced 8bytes at a3116744 (called pathcopy) 
(lprocfs_status.c:lprocfs_add_vars:80) 
freed 8bytes at a3116744 (called pathcopy) 
(lprocfs_status.c:lprocfs_add_vars:80) 
</screen>
      <para>The tool displays the following output to show the leaks found:</para>
      <screen>Leak:32bytes allocated at a23a8fc(service.c:ptlrpc_init_svc:144,debug file line 241)</screen>
    </section>
  </section>
</chapter>
